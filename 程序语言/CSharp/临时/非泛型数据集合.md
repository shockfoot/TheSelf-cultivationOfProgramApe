# 概述

C#提供了许多集合类型，用于存储和管理相关对象的组。不同的集合具有不同的特性，用于不同场景。

相关集合接口有：

| 接口名 | 说明 |
| --- | --- |
| `System.IComparable`和`System.IComparable<T>` | 可比较类型接口，实现此接口以向外提供与另一实例进行比较的方法。 |
| `System.IEquatable<T>` | 可做相等性比较类型接口，实现此接口以向外提供与另一实例进行相等性比较的方法。 |

相关集合委托有：

| 委托名 | 说明 |
| --- | --- |
| `Comparison<T>` | 表示两个对象比较的委托。 |

相关集合类有：

| 类名 | 说明 |
| --- | --- |
| `` | 默认的比较器。 |

相关集合结构体有：

| 结构体名 | 说明 |
| --- | --- |
|  |  |

# 比较

## System.IComparable和System.IComparable&lt;T&gt;

``` csharp
public interface IComparable
{
    int CompareTo(object obj);
}

public interface IComparable<in T>
{
    int CompareTo(T other);
}
```

`System.IComparable`和`System.IComparable<T>`接口定义了与另一个对象比较的方法`CompareTo()`，可以用于排序（C#内部默认升序）等。

`CompareTo()`必须返回以下三个`int`类型结果之一：

- 小于0：当前实例小于比较的对象。
- 0：当前实例等于比较的对象。
- 大于0：当前实例大于比较的对象。

## System.Comparison&lt;T&gt;

``` csharp
public delegate int Comparison<in T>(T x, T y);
```

`System.Comparison<T>`表示比较两个相同类型对象的方法

# 相等

## System.IEquatable&lt;T&gt;

``` csharp
public interface IEquatable<T>
{
    bool Equals(T other);
}
```

`System.IEquatable<T>`接口定义了与另一个对象进行相等性比较的方法`Equals()`。

通常实现此接口的类型，应该重写`Equals()`和`GetHashCode()`基类方法，还应当重载`op_Equality`和`op_Inequality`运算符，以确保所有相等性比较都返回一致的结果。对于值类型，实现此接口并重写`Equals()`基类方法可以提高性能。

# 集合

## System.Array

``` csharp
public abstract class Array
```

`System.Array`是所有数组的基类，提供用于创建、操作、搜索和排序数组的方法。只有系统和编译器可以从`Array`中显示派生类。

元素（Element）是数组中的值。数组的长度是可以包含的元素总数。数组的下限是其第一个元素的索引。**数组可以具有任意下限，默认为0。** 通过C#提供的数组构造语法创建的数组下限为0且无法更改，使用`Array.CreateInstance()`方法创建的数组可以自定义下限。多维数组可以为每个维度定义不同边界。数组最多可以有**32个维度**。

数组一经创建则容量固定，最多可以容纳40亿个元素（最大索引为0X7FEFFFFF，对于字节数组和单字节结构的数组为0X7FFFFFC7）。若要增加容量，必须创建具有所需容量的新数组并将旧数组的元素复制到新数组，并删除旧数组。

具有相同数据类型的数组使用同一`System.Type`对象。




# 临时


| `IEnumerator` | 枚举器接口，定义枚举器应该具有的行为以支持对非泛型集合进行枚举操作。 |
| `IEnumerable` | 可枚举接口，提供一个枚举器以对非泛型集合进行枚举操作。 |
| `IComparer` | 比较器接口，提供一个比较两对象大小的方法。 |
| `ICollection` | 定义了非泛型集合。 |

| 接口名 | 说明 |
| --- | --- |
| `IEnumerator` | 枚举器接口，定义枚举器应该具有的行为以支持对非泛型集合进行枚举操作。 |
| `IEnumerable` | 可枚举接口，提供一个枚举器以对非泛型集合进行枚举操作。 |
| `IComparer` | 比较器接口，提供一个比较两对象大小的方法。 |
| `ICollection` | 定义了非泛型集合。 |

# 枚举

## IEnumerator

`IEnumerator`接口定义了一个枚举器应该具有的行为以支持非泛型集合进行迭代遍历，包括`Current`属性、`MoveNext()`和`Reset()`方法。

``` csharp
public interface IEnumerator
{
    object Current { get; }

    bool MoveNext();

    void Reset();
}
```

示例如下：

```csharp
public class People { }

public class PeopleEnum : IEnumerator
{
    private People[] _collection;
    private int _position = -1;

    public PeopleEnum(People[] collection)
    {
        _collection = collection;
    }

    object IEnumerator.Current { get { return Current; }}

    public People Current
    {
        get
        {
            try
            {
                return _collection[_position];
            }
            catch (IndexOutOfRangeException e)
            {
                throw e;
            }
        }
    }

    public bool MoveNext()
    {
        _position++;
        return _position < _collection.Length;
    }

    public void Reset()
    {
        _position = -1;
    }
}
```

`foreach`语句可以方便快速地对枚举器进行枚举。枚举器只能读取集合而无法修改集合。

最初，枚举器位于集合中的第一个元素之前。在读取`Current`之前，必须调用`MoveNext()`将枚举器推进到集合的第一个元素；否则`Current`未定义。

`Current`返回相同的对象，直到调用`MoveNext()`或`Reset()`。`MoveNext()`将集合推进到下一个元素。`Reset()`重置枚举器。

枚举器对集合没有独占访问权。因此，在集合中枚举不是线程安全的。为了保证枚举期间的线程安全，可以在整个枚举过程中锁定集合或捕获由其他线程更改引起的异常。

## IEnumeratable

`IEnumeratable`接口定义了一个可枚举对象，该对象拥有获取枚举器的方法`GetEnumerator()`以对非泛型集合进行迭代遍历。

``` csharp
public interface IEnumerable
{
    IEnumerator GetEnumerator();
}
```

 如果集合没有实现`IEnumerable`接口，但提供`GetEnumerator()`方法仍支持`foreach`。

 ## IDictionaryEnumerator

 `IDictionaryEnumerator`接口定义了非泛型字典的枚举器。

 # 比较

## IComparer

`IComparer`接口提供了比较两个对象的方法，即比较器。`IComparer`接口的默认实现是`Comparer`类。

``` csharp
public interface IComparer
{
    int Compare(object x, object y);
}
```

`Compare()`方法返回一个`int`结果，指示两者的大小。

建议使用`System.Comparable`接口提供的`CompareTo()`。`null`可以与任何类型比较，并且在使用`IComparable`时不会抛出异常。排序时，`null`被认为小于任何其他对象。

## Comparer

`Comparer`类是`IComparer`接口的默认实现，用于比较两个对象是否相等，其中字符串比较区分大小写。

比较程序使用`Thread.CurrentCulture`，除非另有指定。字符串比较可能会产生不同的结果，具体取决于区域性。

`Comparer`类比较时，如果a实现了`IComparable`，则返回`a.CompareTo(b)`；如果b实现了`IComparable`，则返回`-b.CompareTo(a)`。

# 集合

## ICollection

`ICollection`接口定义了一个非泛型集合，该集合具有元素数量`Count`、枚举器、同步等相关属性或方法。`ICollection`接口继承了`IEnumerable`接口。

``` csharp
public interface ICollection : IEnumerable
{
    int Count { get; }

    object SyncRoot { get; }

    bool IsSynchronized { get; }

    void CopyTo(Array array, int index);
}
```

## CollectionBase

`CollectionBase`类是非泛型集合的抽象基类，用于开发者扩展自己的集合，而非使用自己的基类实现集合。

# IList接口

`IList`接口定义了一个可通过索引访问的非泛型集合，包含索引器、增、删、查等方法。`IList`接口继承了`ICollection`和`IEnumerable`接口。

``` csharp
public interface IList : ICollection, IEnumerable
{
    object this[int index] { get; set; }

    bool IsReadOnly { get; }

    bool IsFixedSize { get; }

    int Add(object value);

    bool Contains(object value);

    void Clear();

    int IndexOf(object value);

    void Insert(int index, object value);

    void Remove(object value);

    void RemoveAt(int index);
}
```

# DictionaryEntry和DictionaryBase

`DictionaryEntry`类封装了非泛型键值对对象，包含键`Key`和值`Value`两个属性，解析键值对`Deconstruct()`方法。

`DictionaryBase`类是非泛型键值对集合的抽象基类，通常用于为键值对集合拓展方法。

# IDictionaryEnumerator和IDictionary接口

`IDictionaryEnumerator`接口定义了用于非泛型键值对集合的枚举器。`IDictionaryEnumerator`接口继承了`IEnumerator`接口。

``` csharp
public interface IDictionaryEnumerator : IEnumerator
{
    object Key { get; }

    object Value { get; }

    DictionaryEntry Entry { get; }
}
```

`IDictionary`接口定义了非泛型键值对集合。`IDictionary`接口继承了`ICollection`和`IEnumerable`接口。

``` csharp
public interface IDictionary : ICollection, IEnumerable
{
    object this[object key] { get; set; }

    ICollection Keys { get; }

    ICollection Values { get; }

    bool IsReadOnly { get; }

    bool IsFixedSize { get; }

    bool Contains(object key);

    void Add(object key, object value);

    void Clear();

    new IDictionaryEnumerator GetEnumerator();

    void Remove(object key);
}
```

# IHashCodeProvider和IEqualityComparer接口

`IHashCodeProvider`接口定义了提供获取哈希值的方法`GetHashCode()`。

``` csharp
public interface IHashCodeProvider
{
    int GetHashCode(object obj);
}
```

`IEqualityComparer`接口定义了比较对象相对性的方法`Equials()`。

``` csharp
public interface IEqualityComparer
{
    new bool Equals(object x, object y);

    int GetHashCode(object obj);
}
```

# ArryaList类

数组列表`ArryaList`是C#封装的`object`数组类，位于`System.Collections`命名空间，继承自`object`，实现了`ICollection`、`IEnumerable`、`IList`等接口，可以动态扩容和增删改查等。`ArrayList`的元素可为`null`但不支持多维数组，可以通过索引访问，允许重复。

ArrayList类被设计用来保存异构的对象集合，但是由于装/拆箱（存储值类型时）和类型转换而性能较差。对于异构的对象集合建议使用`List<Object>`以提高性能。

## API

构造：

通过构造函数可以创建一个具有默认容量或指定容量的`ArryaList`对象；也可以在构造函数传入一个集合，创建一个包含该集合中所有元素且容量等于该集合元素数量的`ArryaList`对象。

属性：

- 容量`Capacity`。
- 元素数量`Count`。
- 是否尺寸固定`IsFixedSize`。
- 是否只读`IsReadOnly`。
- 是否同步访问（线程安全）`IsSynchronized`。
- 可同步访问的访问器`SyncRoot`。

成员方法：

增加：`Add()`、`AddRange()`。
插入：`Insert()`、`InsertRange()`。
删除：`Remove()`、`RemoveAt()`、`RemoveRange()`、`Clear()`。
更改：`SetRange()`。
查找：是否包含`Constains()`，二分查找`BinarySearch()`，`GetRange()`，获取索引`IndexOf()`、`LastIndexOf()`。
复制：`Adapter()`、`Clone()`、`CopyTo()`、`Repeat()`，`FixedSize()`、`ReadOnly()`、`Syschronized()`。
排序：`Sort()`。
反转：`Reverse()`。
转换：`ToString()`、`ToArray()`。
更改状态：设置容量`TrimToSize()`。

# Stack类

栈`Statck`类定义了一个简单的**后进先出**（last-in-first-out，LIFO）`object`集合，位于`System.Collections`命名空间，继承自`object`，实现了`ICollection`、`IEnumerable`，支持动态扩容和增删改查等操作。`Statck`的元素可为`null`，允许重复。

## API

构造：

通过构造函数可以创建一个具有默认容量或指定容量的`Statck`对象；也可以在构造函数传入一个集合，创建一个包含该集合中所有元素且容量等于该集合元素数量的`Statck`对象。

属性：

- 元素数量`Count`。
- 是否同步访问（线程安全）`IsSynchronized`。
- 可同步访问的访问器`SyncRoot`。

成员方法：

增加：`Push()`。
删除：`Pop()`、`Clear()`。
查找：`Peek()`，是否包含`Constains()`。
复制：`Clone()`、`CopyTo()`、`Syschronized()`。
转换：`ToString()`、`ToArray()`。

# Queue类

队列`Queue`类定义了一个简单的先进先出（first-in-first-out，FIFO）`object`集合，位于`System.Collections`命名空间，继承自`object`，实现了`ICollection`、`IEnumerable`，支持动态扩容（与增长因子相关）和增删改查等操作。`Queue`的元素可为`null`，允许重复。

## API

构造：

通过构造函数可以创建一个具有默认容量或指定容量（与增长因子）的`Statck`对象；也可以在构造函数传入一个集合，创建一个包含该集合中所有元素且容量等于该集合元素数量的`Statck`对象。

属性：

- 元素数量`Count`。
- 是否同步访问（线程安全）`IsSynchronized`。
- 可同步访问的访问器`SyncRoot`。

成员方法：

增加：`Enqueue()`。
删除：`Dequeue()`、`Clear()`。
查找：`Peek()`，是否包含`Constains()`。
复制：`Clone()`、`CopyTo()`、`Syschronized()`。
转换：`ToString()`、`ToArray()`。
更改状态：设置容量`TrimToSize()`。

# Hashtable类

哈希表`Hashtable`类定义了基于键的哈希值组织的键值对的集合，位于`System.Collections`命名空间，继承自`object`，实现了`ICollection`、`IDictionary`、`IEnumerable`，支持动态扩容和增删改查等操作。`Hashtable`的元素为`DictionaryEntry`，其中键不能为`null`且不允许重复。

当一个元素被添加到`Hashtable`中时，该元素会根据键的哈希值被放入一个桶bucket中。键的后续查找使用键的哈希值仅在一个特定桶中搜索，从而大大减少了查找元素所需的键比较次数。

`Hashtable`的**负载因子**决定了元素与桶的最大比例。较小的负载因子（桶多）具有更快的平均查找时间，但代价是增加内存消耗。默认的负载因子1.0通常提供了查找速度和内存占用之间的最佳平衡。可以在创建`Hashtable`时指定负载因子。

当元素被添加到`Hashtable`中时，`Hashtable`的**实际负载因子**会增加。当实际负载因子达到指定的负载因子时，`Hashtable`中的桶数自动增加到下一个素数（必定大于当前桶数的两倍）。

`Hashtable`中的每个键必须提供获取哈希值的方法`GetHashCode()`或实现`IHashCodeProvider`接口。

## API

构造：

通过构造函数可以创建一个具有默认容量或指定容量（负载因子、获取键哈希值方法、相等性比较方法）的`Hashtable`对象；也可以在构造函数传入一个键值对集合，创建一个包含该集合中所有元素且容量等于该集合元素数量的`Hashtable`对象。

属性：

- 元素数量`Count`。
- 相等性比较器`EqualityComparer`。
- 键集合`Keys`。
- 值几何`Values`。
- 是否尺寸固定`IsFixedSize`。
- 是否只读`IsReadOnly`。
- 是否同步访问（线程安全）`IsSynchronized`。
- 可同步访问的访问器`SyncRoot`。

成员方法：

增加：`Add()`。
删除：`Remove()`、`Clear()`。
查找：是否包含`Constains()`、`ConstainsKey()`、`ConstainsValue()`。
复制：`Clone()`、`CopyTo()`、`Syschronized()`。
转换：`ToString()`。