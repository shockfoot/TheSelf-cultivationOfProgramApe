# 协程

从迭代器了解协程：

```` C#
IEnumerator iterator;
void OnGui()
{
    if (GUILayout.Button("启动"))
        iterator = Fun(); // Fun()方法直接调用不执行
    if (GUILayout.Button("执行一次"))
        iterator.MoveNext(); // Fun()方法在调用MoveNext()时执行
    if (GUILayout.Button("协程"))
        StartCoroutine(iterator); // StartCoroutine按帧调用MoveNext()
}

IEnumerator Fun()
{
    for (int i = 0; i < 5; i++)
    {
        print(i);
        // yield return将Fun()分成了多个部分，并让该方法分部执行
        yield return null; // 执行时间，null表示等待一帧执行
        // yield return new WaitForSeconds(1); // 等待一秒执行，内部是计时后调用MoveNext()
    }
}
````

协程（协同程序，Coroutine）是指具有多个返回点`yield`、可以在**特定时机**分部执行的方法/函数。

原理：Unity每帧处理`GameObject`中的协同函数，直到函数执行完毕，因此协程由`GameObject`而不是脚本管理。

当一个协程函数启动时，本质是创建迭代器对象，调用`MoveNext()`方法，执行到`yield`时暂时退出；待满足调节后再次调用`MoveNext()`，执行后续代码，直到遇到下一个`yield`为止，如此循环直到整个函数结束。

协程通过`MonoBehaviour`中的`StartCoroutine()`方法启动，用`StopCoroutine()`方法停止。协程函数返回值类型为`IEnumerator`，方法体中通过`yield`关键字定义返回点，通过`return`对象定义继续执行的条件。可以被`yield return`的对象：

- `null`或数字：在`Update`后执行，适合分解耗时的逻辑处理，
- `WaitForFixedUpdate()`：在`FixedUpdate`后执行，适合分解物理操作。
- `WaitForSeconds()`：在指定时间后执行，适合延迟调用。
- `WaitForSecondsRealtime`：在指定时间后执行，不受时间缩放影响。
- `WaitForEndOfFrame`：在每帧结束后执行，适合相机的跟随操作。
- `Coroutine`：在另一个协程执行完毕后再执行。
- `WaitUntil`：在委托返回`true`时执行，适合等待某一操作。
- `WaitWhile`：在委托返回`false`时执行，适合等待某一操作。
- `WWW`：在请求结束后执行，适合加载数据（文件、贴图、材质等）。

``` C#
Coroutine coroutine;
void Start()
{
    print("a--" + Time.frameCount);
    coroutine = StartCoroutine(Fun1());
    print("d--" + Time.frameCount);
    StartCoroutine(Fun2());
    print("f--" + Time.frameCount);
}
IEnumerator Fun1()
{
    print("b--" + Time.frameCount);
    yield return new WaitForSeconds(2);
    print("c--" + Time.frameCount);
}
IEnumerator Fun2()
{
    yield return coroutine;
    print("e--" + Time.frameCount);
}

// Output:
// a--1
// b--1
// d--1
// f--1
// c--106
// e--106
```

协程通常用于**延时调用**和**分解操作**。

## 案例：淡出

``` C#
// 角色死亡后身体逐渐消失（淡出）
void Start()
{
    Material material = GetComponent<MeshRenderer>().material;
}

void FadeOut()
{
    Color color;
    float speed = 1; // 淡出速度
    while (color.a > 0)
    {
        color = material.color;
        color.a -= speed * Time.deltaTime; // 透明度变小
        material.color = color;
        yield return null; // 每帧执行
    }
    color.a = 0;
    material.color = color;
}

// 变速淡出
Color endColor;
AnimationCurve curve; // 提供了数值可视化变化的面板
float time;
void FadeOut()
{
    Color OriginalColor = material.color;
    for (float x = 0; x < 1; x += Time.deltaTime / time)
    {
        // 将数值的变化转化为颜色的变化
        material.color = Color.Lerp(originalColor, endColor, curve.Evaluate(x));
        yield return null; // 每帧执行
    }
}
```

## 练习：寻路

物体通过协程移动到路点A、B、C等。

``` C#
Transform[] wayPath;
float moveSpeed;
void Start()
{
    StartCoroutine(MoveNext());
}
// 寻路
IEnumerator MoveNext()
{
    for (int i = 0; i < wayPath.Length; i++)
    {
        yield return StartCoroutine(Move(wayPath[i]));
    }
}
// 移动到目标
IEnumerator MoveTo(Vector3 target)
{
    transform.LookAt(targert);
    while (Vector3.Distance(transform.position, target) > 0.1f)
    {
        transform.position = Vector3.MoveTowards(transform.position, 
            target, moveSpeed * Time.deltaTime);
        yield return new WaitForFixedUpdate();
    }
}
```
