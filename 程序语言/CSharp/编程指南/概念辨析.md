# 结构体和类

结构体和类最大的区别在于存储空间：结构体是值类型，在栈；类是引用类型，在堆。

相同点

- 结构体和类在使用上很相似，都具备封装特性。
- 都可以实现接口（接口是行为的抽象）。
- 都可以包含静态成员。

不同点

- 结构体是值类型；类是引用类型。
- 结构体不支持继承和多态，结构体不能使用`sealed`、`abstract`，成员不能使用`protected`、`abstract`、`virtual`修饰符；类可以。
- 结构体声明成员变量时不能指定初始值；类可以。
- 结构体不能包含自身类型的成员变量；而类可以。
- 结构体不能显示声明无参构造函数和析构函数；类可以。
- 结构体声明含参构造函数后，无参构造函数不会消失；而类的无参构造函数会被顶掉。
- 结构体需要在含参构造函数中初始化所有成员变量；而类不需要。
- 结构体不能使用`static`，没有静态结构体；而类可以。
- 结构体可以不使用`new`即可被实例化，但需要初始化后所有成员变量后才能调用方法；而类只能通过`new`才能实例化。

通常使用结构体设计以数据为中心的轻量级类型，这些类型仅具有较少的行为或者没有行为。如果侧重类型的行为，则应使用类类型定义。

# const和static

相同点

- `const`和`static`修饰的成员都属于类，可以通过类名访问。

不同点

- `const`只能修饰基本数据类型变量；而`static`可以修饰任何类型的字段、属性、方法、构造函数等。
- `const`必须再声明时初始化且无法修改。
- 访问修饰符必须写在`const`关键字前。

# 虚方法和抽象方法

相同点

- 都是需要子类通过`override`关键字来重写/实现。
- 都可以更深层次继承的子类重写/实现，并使用`base`关键字。
- 都可以实现多态。

不同点

- 抽象方法只能存在于抽象类中。
- 虚方法是父类可以实现，子类选择性实现；抽象方法是父类不能实现，推迟给子类实现。

# 抽象类和接口

相同点

- 都可以被继承/实现。
- 都不能实例化，但都遵循里氏替换。
- 都可以包含抽象成员。
- 子/实现类必须实现抽象成员。

不同点

- 抽象类可定义字段，可包含成员/虚/静态方法和构造函数；接口只能包含抽象成员（方法、属性、索引器、事件）。
- 抽象类只能单继承；接口可以多实现。
- 抽象类成员可以使用任何访问修饰符；接口中只能使用`public`和`protected`。
- 抽象类是不完整的类；而接口是一个行为规范。
- **抽象类是关系相关的类概念的抽象；而接口是关系疏松的类行为的抽象**。

通常表示同一类对象的使用抽象类，而用于行为扩展的则优先使用接口。



# 常用接口

- `IComparable`可比较类型：使类型支持比大小的功能。
- `IComparer`比较器：提共比较的方法，常用于排序。
- `IEnumerable`、`IEnumerable<T>`可枚举类型：使类型支持简单迭代`foreach`。
- `IEnumerator`、`IEnumerator<T>`枚举器：支持`MoveNext`，自己可以控制迭代的节奏。

# 内置委托

.Net框架内置了两个泛型委托：`Action<T>`和`Func<TParams, TResult>`。其中`Action`为无返回值、0-16个可选参数的委托。`Func`具有一个返回值和0-16个可选参数，在实例化时，最后一个参数为指定的返回值类型。