# 进程

进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。打开一个应用程序就是在操作系统上开启了一个进程。进程之间可以相互独立运行，互补干扰，同时也可以相互访问、操作。

进程包含资源，如Window句柄、文件系统句柄或其他内核对象。每个进程都分配虚拟内存。

# 线程

线程（Thread）被定义为程序的执行路径。每个线程都定义了一个独特的控制流。线程是操作系统能够进行运算调度的最小单位。

程序是静态的，进程是运行中的程序。进程由操作系统启动，线程由进程启动。

一个进程至少包含一个线程。一个应用程序启动，会启动一个进程，然后进程启动多个线程。进程中第一个被执行的线程称为**主线程**。一个进程的多个线程可以同时运行在单核CPU或多核CPU的不同内核上。

线程是轻量级进程。使用线程减少了CPU周期的浪费，同时提高了应用程序的效率。如果应用程序涉及到复杂的和耗时的操作，那么设置不同的线程执行路径往往是有益的。每个线程可以执行特定的工作。

到目前为止我们编写的程序是一个单线程作为应用程序的运行实例的单一的过程运行的。但是，这样子应用程序同时只能执行一个任务。为了同时执行多个任务，它可以被划分为更小的线程。

## Thread

.Net框架提供了`Thread`类来创建、控制和管理线程，设置其优先级并获取其状态。`Thread`类构造函数的参数是一个无返回值无参数或无返回值一个参数的委托，所以此参数可以传入一个方法或者Lambda表达式。

``` csharp
static void Test()
{
    Console.WriteLine("Test started");
    Thread.Sleep(3000); // 让线程暂停3s
    Console.WriteLine("Test completed");
}

static void Main()
{
    Thread t = new Thread(Test); // 创建线程
    // 使用Lambda表达式创建线程
    Thread t2 = new Thread(() => Console.WriteLine(
        "Child Thread" + Thread.CurrentThread.ManagedThreadId));
    t.Start(); // 启动线程
}
```

## 前/后台线程

只要有一个前台线程在运行，应用程序就在运行。如果有多个前台线程在运行，但是`Main`方法已经结束，此时应用程序仍然在运行，直到所有前台线程结束其任务为止。

当应用程序停止运行时，该程序中所有的后台线程会被立即关闭，即使后台线程任务还未完成。

默认情况下，使用`Thread`类创建的线程是前台线程。线程池中的线程总是后台线程。在使用`Thread`类创建的线程创建线程时，可以使用类似命名参数形式`{ 属性 = 值 }`设置`IsBackground`属性表示此线程是否是后台线程，设置为`true`时此线程为后台线程，否则为前台线程。 

``` csharp
static void Test()
{
    Console.WriteLine("Test started");
    Thread.Sleep(3000); // 让线程暂停3s
    Console.WriteLine("Test completed");
}

static void Main()
{
    Thread t = new Thread(Test) { IsBackgrount = true };
    t.Start();
    Console.WriteLine("Main completed");
}
// Output:
// Main completed
// Test started
```

## 控制线程

当通过调用`Thread`对象的`Start()`方法启动线程时，线程不是马上进入`Running`状态，而是处于`UnStarted`状态。只有线程调度器选择了要运行的线程，此线程状态才会修改为`Running`状态。调用`Thread.Sleep()`方法可以让当前线程进入`WaitSleepJoin`状态。

使用`Thread`对象的`Abort`方法可以终止线程。调用此方法，会在线程将要终止时抛出`ThreadAbortException`异常，可以通过`try-catch`捕获此异常，然后在线程终止前做一些清理工作。最新版本已不支持此方法。

如果需要等待线程的结束，可以调用`Thread`对象的`Join()`方法，表示将该`Thread`对象加入进来，暂停当前线程，并把它设置为`WaitSleepJoin`状态，直到加入的线程完成为止。

## 传递数据

可以采用两种方式给线程传递数据：一是使用`Start()`方法，二是创建自定义类，将线程方法定义为实例方法，这样即可初始化实例的数据，之后启动线程。

`Thread`类构造函数有两个重载，其参数可以是一个无返回值无参数或无返回值一个参数的委托。当用参数是无返回值一个参数的委托的构造方法创建线程时，使用`Start()`启动该线程可以传递一个参数。

``` csharp
public struct Data
{
    public string url;
    public int size;
}
static void Download(object o)
{
    string url = o as string;
    Console.WriteLine(url);
    
    Data data = (Data)o;
    Console.WriteLine(data.url);
}

static void Main()
{
    // 对于只需要一个参数的方法，可以使用Start来传递参数
    Thread t = new Thread(Download); // 构造函数参数可以是有一个参数的委托类型
    t.Start("https://www.Zhengxingstudio.com"); // Output: "https://www.Zhengxingstudio.com"
    // 如果要传递多个数据，可以将数据封装成结构，传递结构体即可
    Data data = new Data();
    data.url = "https://www.Zhengxingstudio.com";
    data.size = 100;
    t.Start(data); // Output: "https://www.Zhengxingstudio.com"
}
```

当在创建线程时，给`Thread`构造函数传递一个自定义类的实例方法。此时，通过线程即可启动该实例方法，此方法可以访问实例中的数据成员。

``` csharp
internal class DownloadTool
{
    public string URL { get; set; }
    public string Name { get; set; }
    public DownloadTool(string url, string name)
    {
        URL = url;
        Name = name;
    }
    public void Download()
    {
        Console.WriteLine("从" + URL + "中下载" + Name);
    }
}

static void Main()
{
    DownloadTool downloadTool = new DownloadTool("https://www.Zhengxingstudio.com", "音乐");
    Thread t = new Thread(downloadTool.Download); // 传递一个实例方法
    t.Start();  // Output: "从https://www.Zhengxingstudio.com中下载音乐"
}
```

## 线程优先级

线程由操作系统调度。一个CPU同一时间只能运行一个线程中的计算任务。当有很多线程需要CPU去执行时，线程调度器会根据线程的优先级去判断执行哪一个线程。如果优先级相同，则使用循环调度规则，逐个执行每个线程。

在`Thread`类中，可以设置`Priority`属性来影响线程的基本优先级。`Priority`属性是一个`ThreadPriority`枚举定义的值，级别有`Highest`、`AboveNormal`、`Normal`、`BelowNormal`、`Lowest`。

## 资源访问冲突

当多个线程同时访问一个资源（变量、文件等）时（通常进行又读又写的操作），不同线程访问资源会产生冲突，导致出现程序异常或逻辑错误。

可以使用**锁**来解决。可以声明一个任意类型的对象，通常是`Object`类型，并且这个对象不能为`null`。使用`lock`关键字加锁来包裹相应的读写操作语句，此范围内的语句同一时间只能被一个线程访问。对同一个目标，控制线程访问时应使用同一把锁。运行过程中，在一个线程释放锁之前，其他线程无法获取到该锁，只能等待。锁解决了资源访问冲突，但降低了多线程的效率。

``` csharp
private object _lock = new Object();

lock(_lock)
{
    // 语句
}
```

如果多个资源需要同时被访问（如t1需要访问资源a和b，t2需要访问资源a和b），可以简单的用一把锁将这些资源锁住。但如果不同的线程需要访问不同的资源（如t1需要访问资源a和b，t2需要访问a，t3需要访问a和b），此时使用一把锁会降低效率。这时需要使用多个锁，但多个锁的使用会导致**死锁**（如t1已取得a的锁，而t3已取得b的锁，此时两个线程都无法结束且都无法取得对方的锁）。解决死锁问题需要设计*锁的拿取顺序*。

# 线程池

创建线程需要时间。如果有许多小任务需要完成，可以事先创建许多线程。，在应完成这些任务时发出请求。线程池中线程的数量最好在需要更多线程时增加，在需要释放资源时减少。

不需要自己创建线程池，系统有一个`ThreadPool`类管理线程。这个类会在需要时增减线程池中线程数量，直到达到最大线程数。池中的最大线程数是可配置的，也可以指定创建线程池时应立即启动的最小线程数以及池中最大可用线程数。如果有更多的作业要处理且线程池中线程数已达到极限，最新的作业就要排队，且必须等待线程完成其他任务。

通过调用`ThreadPool.QueueUserWorkItem()`方法传递一个`WaitCallBack`类型的委托，从而将方法赋予线程池中的线程。线程池收到请求后就会从池中选择一个线程来调用该方法。如果线程池还未运行，就会创建一个线程池并启动第一个线程。如果线程池已在运行并有空闲的线程，就把该作业传递给此线程。

线程池中所有线程都是后台线程。如果进程中的所有前台线程结束了，所有后台线程就会停止。不能把入池的线程改为前台线程。不能给入池的线程设置优先级或名称。入池的线程只能用于时间较短的任务。如果线程要一直运行，就要使用`Thread`类创建一个线程。
