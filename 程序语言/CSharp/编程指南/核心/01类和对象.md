# 类

**类**是最基本的C#类型，是引用类型。类是一种数据结构，可在一个单元中将状态（字段、常量、属性等）和操作（方法、事件、索引器、构造函数等）结合起来。

类是对一类事物的抽象，具有相同的特征和行为。类为**对象**（亦称**实例**）提供了定义，是创建对象的模板/蓝图，包含每个对象都应具有的数据（特征），并提供了处理和访问数据的⽅法（行为）。

类以`class`定义，声明签名包含特性和修饰符、类名、基类、实现的接口。声明签名后为类主体，由在`{}`内编写的成员声明列表组成。

``` csharp
// 定义一个二维坐标类
public calss Point2D { }
```

类支持**继承**和**多态**，即**派生类**可以扩展和专门针对**基类**的机制。

在类中、方法外声明的变量为**全局变量**。在方法内部声明的变量为**局部变量**。局部变量在使用前必须初始化。局部变量的作用域在相应方法的代码块内，全局变量的作用域在整个类中有效。

> **注意**：在类中声明全局变量而不初始化，则在实例化对象时编译器会自动给全局变量赋默认值，且全局变量的赋值和访问顺序是不确定的；而局部变量则一定是先赋值再访问，因此强制局部变量初始化可减少编程时的疏忽。

# 对象

类定义对象类型，但不是对象本身。对象是基于类的具体实体，有时称为类的实例。类实例是使用`new`运算符进行创建，后跟对象要基于的类名来创建对象，该运算符为新实例分配内存，调用构造函数来初始化实例，并返回对实例的引用。

``` csharp
// 创建一个Point2D实例
Point2D point1;
Point2D point2 = null;
Point2D point3 = new Point2D();
```

当无法再访问对象时，对象占用的内存会被自动回收。没有必要也无法在C#中显式解除分配对象。

# 成员

类中具有不同的成员，用以描述类或定义类的行为。类中可包含成员有：常量、字段、方法、构造函数、析构函数、属性、索引器、事件、运算符、嵌套类型。

类的成员包括在类中声明的所有成员以及基类的所有成员（除构造函数和析构函数）。

## 字段

**字段（成员变量）**是对象的属性（从设计角度），用来描述对象的特征。字段可以是任意变量类型，数量无限制，是否赋值根据需求而定，不赋值时为默认值，且通常保持私有来实现封装，外界只能使用公共成员方法来访问这些字段。

``` csharp
public calss Point2D
{
    public float X;
    public float Y;
}
```

类中自己相同类型的字段不能对其进行`new`实例化，会陷入死循环，导致内存溢出。

字段可以使用`readonly`修饰符声明**只读**字段。只能在字段声明期间或在同一个类的构造函数中向只读字段赋值。

注意字段的**内联初始化**（在代码中直接赋值来初始化）。

``` csharp
public calss Point2D
{
    public float X = 0;
    public float Y = 0;

    public Point2D() {}
    public Point2D(float x, float y) {}
}
```

定义字段并初始化值，是一种很常见的代码编写习惯。但IL代码结构中，一行代码（定义字段+赋值）被拆成了两块，最终的赋值都在构造函数里执行的。那么如果**有多个构造函数，会在构造函数.ctor中重复产生对字段赋值的IL代码，造成不必要的代码膨胀**。解决方法可以在非默认构造函数后加一个`:this()`，或显示的在构造函数里初始化字段。

## 方法

**成员方法**是一个在类定义中有它的定义或原型的方法，用来描述对象的行为。作为类的一个成员，能访问该对象的所有成员。

``` csharp
public calss Point2D
{
    public float X;
    public float Y;

    public string ToString() => $"({x}, {y})"
}
```

## 构造函数和析构函数

**构造函数**是类的一个特殊的成员方法，当**创建类的新对象时执行**。构造函数的声明方式与方法一样，**与类同名，没有任何返回类型**。默认的构造函数没有任何参数，可以显示声明任意数量参数的含参构造函数以便在创建对象时为字段赋初值。

**如果没有在类中显示声明任何构造函数则会默认包含一个无参构造函数，如果实现了含参构造函数而未显示声明无参构造函数则会失去默认的无参构造函数。**

``` csharp
public calss Point2D
{
    public float X = 0;
    public float Y = 0;

    public Point2D(float x, float y) { this.X = x; this.Y = y; }
}
```

构造函数不能被继承，可以重载。多参数构造函数可以`:this()`先调用其他构造函数。

``` csharp
public calss Point2D
{
    public float X = 0;
    public float Y = 0;

    public Point2D(float x) { this.X = x; }
    public Point2D(float x, float y) : this(x) { this.Y = y; }
}
```

**析构函数（终结器）** 也是类的一个特殊的成员方法，当引用类型对象的堆内存被回收时调用。析构函数的名称是在**类的名称前加上一个波浪形`~`作为前缀，无访问修饰符，不返回值，也不带任何参数**。

析构函数仅用于类，不能继承或重载，不能手动调用。

``` csharp
public calss Point2D
{
    ~Point2D()
    {
        // 操作
    }
}
```

析构函数隐式调用基类的`Finalize()`方法，因此析构函数会在调用时隐式转换为以下代码：

``` csharp
protected override void Finalize()
{
    try
    {
        // Cleanup statements...
    }
    finally
    {
        base.Finalize();
    }
}
```

析构函数用于在结束程序（比如关闭文件、释放内存等）之前释放资源。对于需要手动管理内存的语言，如C++等，需要在析构函数中做一些内存回收处理，但在C#中存在自动垃圾回收机制GC，所以不怎么会使用析构函数，除非想在对某对象被垃圾回收时做一些特殊处理。

## 属性

属性是字段的自然扩展，与字段同名，但首字母应大写，访问字段和属性的语法相同。类或结构中的字段称为域（Field）。属性是域的扩展，且可使用相同的语法来访问。**属性的本质还是方法**，使用面对对象的思想对字段进行封装。

**属性用于保护字段，为字段的获取和赋值添加逻辑处理，解决访问修饰符的局限性**，即属性可以让字段在外部只读/写，提供了对私有字段安全和灵活的访问封装。

属性不指明存储位置。属性的声明方式与字段相似，区别是属性声明以在分隔符`{`和`}`之间写入的`get`访问器或`set`访问器结束，而不是以分号结束。

属性包含访问器，用于指定在读取或写入属性值时执行的语句。`get`访问器对应于包含属性类型的返回值的无参数方法，会计算并读取属性的值。`set`访问器对应于包含一个名为`value`的参数但不含返回类型的方法，会为属性提供新值。

当属性是赋值的目标，或者是`++`或`--`的操作数时，会调用`set`访问器。在引用了属性的其他情况下，会调用`get`访问器。

属性的访问器可以是虚的、私有的。如果属性声明包含`virtual`、`abstract`或`override`修饰符，则适用于属性的访问器。

访问器可以添加访问修饰符。默认不加时使用属性声明时的访问权限，添加的访问修饰符要低于属性的访问权限，不能让`get`和`set`的访问权限都低于属性的访问权限。

当不需要在访问器中进行其他额外操作时，可以写成**自动属性**，`get`和`set`成对出现。自动属性在IL代码中被分为三部分：自动生成的私有字段（由编译器自动命名，不受开发人员控制）、获取字段值的方法和设置字段值的方法。

``` csharp
// 字段
private string roleName;
// 标准属性
public string RoleName
{
    get { return roleName; }
    set { roleName = value; }
}
// 自动属性
public int RoleAge { get; set; }
```

## 索引器

索引器（Indexer）允许一个对象可以像数组一样使用索引的方式来访问成员。当为类定义一个索引器时，该类的行为就会像一个虚拟数组（virtual array）一样，可以使用数组访问运算符`[]`来访问其成员。

索引器在某种程度上类似于属性。但属性返回或设置一个特定的数据成员，而索引器返回或设置对象实例的一个特定值。换句话说，它把实例数据分为更小的部分，并索引每个部分，获取或设置每个部分。索引器定义的时候不带有名称，但使用`this`关键字，以指向对象实例。

``` csharp
public calss Point2D
{
    public float X = 0;
    public float Y = 0;

    public float this[string index]
    {
        get
        {
            if (index.Equials("X")) return X;
            if (index.Equials("Y")) return Y;
            return default(float);
        }
        set
        {
            if (index.Equials("X")) X = value;
            if (index.Equials("Y")) Y = value;
        }
    }
}
```

索引器可被重载。索引器声明的时候也可带有多个参数，且每个参数可以是不同的类型。C#允许索引器可以是其他类型（如字符串类型）而没有必要让索引器必须是整型的。

## 运算符

类或结构体中可以重定义或重载C#中内置的运算符。**重载运算符是具有特殊名称的公共静态方法**，通过关键字`operator`后跟运算符的符号来定义的。重载运算符有返回类型和参数列表。运算符只能采用值参数，不能采用`ref`或`out`参数。一个运算符可以有多个重载。

``` csharp
public calss Point2D
{
    public float X = 0;
    public float Y = 0;

    public static bool operator ==(Point2D p1, point2D p2)
    {
        return p1.X == p2.X && p1.Y == p2.Y
    }
    public static bool operator !=(Point2D p1, point2D p2)
    {
        return !(p1 == p2);
    }
}
```

| 运算符 | 描述 |
| :--- | :--- |
| +，-，!，++，--，~ | 可以被重载 |
| +，-，*，/，%，&，\|，^，>>，<< | 可以被重载 |
| ==，!=，<，>，<=，>= | 比较运算符需要成对被重载 |
| &&，\|\| | 这些条件逻辑运算符不能被直接重载 |
| +=，-=，*=，/=，%= | 复合运算符不能被重载 |
| =，.，?:，->，new，is，sizeof，typeof, [], () | 不能被重载 |

C#要求成对重载比较运算符。如果重载了`==`，则也必须重载`!=`，否则产生编译错误。同时，比较运算符必须返回`bool`类型的值，这是与其他算术运算符的根本区别。

C#不允许重载`=`运算符，但如果重载例如`+`运算符，编译器会自动使用`+`运算符的重载来执行`+=`运算符的操作。

运算符重载的其实就是函数重载。首先通过指定的运算表达式调用对应的运算符函数，然后再将运算对象转化为运算符函数的实参，接着根据实参的类型来确定需要调用的函数的重载，这个过程是由编译器完成。

# 访问修饰符

**所有类型和成员都具有可访问性级别，该级别控制是否可以从同一或其他程序集中的其他代码使用它们。** 使用以下访问修饰符在进行声明时指定类型或成员的可访问性：

- `public`公共的：同一或其他程序集中任何地方都可以访问。公共访问是允许的最高访问级别。
- `private`私有的：只有自己才可以访问。自己的嵌套类型也可以访问。私有访问是允许的最低访问级别。
- `protected`保护的：只有自己或派生类才可以访问。
- `internal`内部的：同一程序集中任何地方才可以访问。
- `private protected`：只有自己或当前程序集中的派生类才可以访问。
- `protected internal`：只有当前程序集或派生类才可以访问。

| 调用方的位置 | public | protected internal | protected | internal | private protected | private |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 内部 | √ | √ | √ | √ | √ | √ |
| 相同程序集派生类 | √ | √ | √ | √ | √ | × |
| 相同程序集非派生类 | √ | √ | × | √ | × | × |
| 不同程序集派生类 | √ | √ | √ | × | × | × |
| 不同程序集非派生类 | √ | × | × | × | × | × |

命名空间不能使用访问修饰符，默认是`public`的。直接在编译单元或命名空间下声明的类型默认是`internal`的，可以声明为`public`或`internal`。类成员默认为`private`的，可以声明为任何可访问性级别。结构体成员默认为`private`的，因为结构体不支持继承所以其成员只能声明为`public`、`private`或`internal`。接口成员和枚举成员默认是`public`的，不能显式使用访问修饰符。

# 扩展方法

**扩展方法可以在创建新派生类型或不修改原类型的情况下为现有非静态类、变量类型增加新功能（成员方法）**，不违反开闭原则的基础上提升程序拓展性。

扩展方法的三要素：扩展方法所在类必须是静态类（静态类无法实例化），且自身为静态方法；第一个参数必须是被扩展的目标，且用`this`修饰。**如果扩展方法与成员方法的名字、参数列表一样则优先调用成员方法。**

``` csharp
// 定义一个二维坐标类
public static calss Point2DExtension
{
    public static Point2D ToVector2(this Point2D point) {}
}
```