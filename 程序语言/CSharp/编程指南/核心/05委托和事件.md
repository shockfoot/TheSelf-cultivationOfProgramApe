# 委托

委托（Delegate）是存有对某个具有特定参数列表和返回类型的方法的引用的一种引用类型变量，即**表示方法的引用类型**，可在运行时被改变，用来**存储和传递方法**。委托是面对对象、类型安全的。

**委托本质是一个类**，用来定义方法的类型（返回值和参数），所有的委托都派生自`System.Delegate`类。

委托使用`delegate`定义，并指定返回类型和参数列表，不包含方法体。定义了委托之后，就可以声明该委托类型的实例，接着就可以把⼀个**返回类型跟参数列表跟委托⼀样的方法**赋值给该实例，然后可以通过该委托实例调用此方法。可将任何可访问类或结构中与委托类型匹配的任何方法分配给委托。该方法可以是静态方法，也可以是实例方法。

``` csharp
// 定义：<访问修饰符> delegate <返回类型> <委托名>(参数列表);
public delefate void ShowMoney(int money);
// 声明并赋值
puloic void Show(int have) { Cnonsole.Write(have); }
ShowMoney show1 = new ShowMoney(Show);
ShowMoney show2 = Show;
// 调用
show1.Invoke();
show2();
```

> **注意**：当使用`new`关键字来创建委托实例时必须关联一个特定的方法。委托没有方法体，默认访问权限为`public`。委托无重载说法。

委托实例化后会将对其进行的方法调用传递给目标方法：调用方传递到委托的参数将传递给目标方法，并且委托会将目标方法的返回值（如果有）返回到调用方，这被称为**调用委托**。实例化的委托可以按封装的方法本身进行调用。**调用的委托不能为空。**

当委托构造为封装实例方法时，委托将同时引用实例和方法。委托不知道除其所封装方法以外的实例类型，因此委托可以引用任何类型的对象，只要该对象上有与委托签名匹配的方法。当委托构造为封装静态方法时，委托仅引用方法。

委托类型不能显示派生出自定义类。由于实例化的委托是一个对象，因此可以作为**类的成员**和**方法的参数**。这允许方法接受委托作为参数并在稍后调用委托，即**回调**。当以这种方式使用委托时，使用委托的代码不需要知道要使用的实现方法，功能类似于封装接口提供的功能。回调的另一个常见用途是定义自定义比较方法并将该委托传递到短方法，它允许调用方的代码成为排序算法的一部分。

``` csharp
public double DoubleNum (double x) => x * 2;
public double SqureNum (double x) => x * x;
// 定义委托
delegate double DoubleOpDelegate (double x);
// 委托数组
DoubleOpDelegate[] ops = {DoubleNum, SqureNum};
foreach (DoubldOpDelegate op in ops)
    Console.WriteLine(op(3)); // Output: 6 9
// 委托作为参数
public void ProcessAndDisplayResult(Delegate op, double value)
{
    Console.WriteLine(op(value));
}
foreach (DoubldOpDelegate op in ops)
    ProcessAndDisplayResult(op, 4); // Output: 8 16
```

查看IL代码，当使用一行定义了一个委托，编译器自动生成一堆代码：自动创建一个类，继承自`System.MulticastDelegate`（继承`System.Delegate`），是一个多播委托；该为委托类中包含`Invoke()`（签名与定义时的一致）、`BeginInvoke()`和`EndInvoke()`方法，其中`BeginInvoke()`和`EndInvoke()`是异步执行版本。因此，当调用委托时，实际是调用委托的`Invoke()`方法。

委托对象可采用两种方式进行构造，一是提供委托要封装的方法的名称，二是使用**匿名方法**。

# 匿名方法

**匿名方法是没有名字的方法，直接定义方法体而不需要单独声明方法**，减少了代码复杂度，主要配合委托和事件使用，脱离委托和事件无法使用匿名方法。

**匿名方法需要使用`delegate`声明并省略返回类型和方法名，然后将方法引用作为参数传递给方法或者赋值给委托实例或事件。** 同样的匿名方法写两次，尽管逻辑相同，但由于方法引用不同，两者仍为两个独立的方法。

``` csharp
// 匿名方法
Func<int, int, int> plus = delegate (int a, int b)
{
    return a + b;
};
```

匿名方法由于没有名字，如果不记录则**无法单独移除**。

## Lambda表达式

可以**使用Lambda表达式来创建匿名方法**。任何Lambda表达式都可以转换为委托类型。Lambda表达式可以转换的委托类型由其参数和返回值的类型定义。Lambda表达式还可以转换为表达式树类型。

Lambda表达式分表达式和语句两种形式。**创建Lambda表达式需要在Lambda运算符`=>`左侧指定参数列表（如果有），然后在另一侧指定表达式或语句块。** `delegate`关键字可以省略。 

``` csharp
// 表达式形式
delegate (<参数列表>) => 表达式
// 语句形式
delegate (<参数列表>) => { <方法体> }
```

位于表达式运算符`=>`右侧的Lambda表达式称为“表达式Lambda”。表达式Lambda会返回表达式的结果。表达式Lambda的主体可以包含方法调用。不过，若要创建在.NET公共语言运行时CLR的上下文之外计算的表达式树，则不得在Lambda表达式中使用方法调用。在CLR上下文之外，方法将没有任何意义。

位于表达式运算符`=>`右侧的Lambda语句称为“语句Lambda”，被一组大括号`{}`包裹。语句Lambda的主体可以包含任意数量的语句，但通常不会多于两个或三个，当主体只有一条语句时可以省略大括号和`return`（即表达式形式），编译器会自动添加。不能使用语句Lambda创建表达式树。

``` csharp
(x, y) => { return x + y; };
// 进一步简化
(x, y) => x + y;
```

Lambda表达式的输入参数被`()`包裹。使用空括号指定零个输入参数。如果只有一个输入参数，则括号可省略。多个输入参数以`,`分隔。

编写Lambda表达式时，通常不必为输入参数指定类型，因为编译器可以根据表达式主体、参数类型、匿名方法容器以及C#语言规范中描述的其他因素来推断类型。有时，编译器无法推断输入参数的类型，可显式指定类型。输入参数类型必须全部为显式或全部为隐式，否则便会生成CS0748错误。从C# 9.0开始，可以使用**弃元**指定Lambda表达式中不使用的两个或更多输入参数。

``` csharp
// 零个参数时使用空括号
() => Console.WriteLine();
// 一个参数时可以省略参数括号
x => x * x * x;
// 多参数以','分隔
(x, y) => x == y;
// 显示指定类型
(int x, string s) => s.Length > x;
// 弃元
(_, _) => 42;
```

通常，Lambda表达式的返回类型是显而易见的并且是推断出来的。但对于某些表达式，编译器可能无法推断返回类型。从C# 10开始，可以在输入参数前面指定Lambda表达式的返回类型。指定显式返回类型时，必须将输入参数括起来。

``` csharp
(bool b) => b ? 1 : "two"; // 无法推断返回类型
// 需显示指定返回类型
object (bool b) => b ? 1 : "two";
```

从C# 10开始，可以将属性添加到Lambda表达式、其参数或返回值。将属性添加到Lambda表达式或其参数时，必须将输入参数括起来。

``` csharp
[Example(1)] (s) => int.Parse(s);
[Example(2)][Example(3)] object (bool b) => b ? 1 : "two";
([Example(1)] int a, [Example(2), Example(3)] int b) => a + b;
[return: Example(1)] (int s) => s++;
```

# 多播委托

委托对象可使用加法或加法赋值运算符（`+`或`+=`）进行合并。只有相同类型的委托可被合并。**一个合并委托按合并顺序调用它所合并的多个委托，即多播。** 如果委托使用引用参数，引用将按**相反的顺序**传递到所有方法，并且一种方法进行的任何更改都将在另一种方法上见到。当方法引发未在方法内捕获到的异常时，该异常将传递到委托的调用方，并且不会调用后续的方法。如果委托具有返回值和/或输出参数，它将返回上次调用方法即最后一次调用的方法的返回值和参数。通常多播委托的返回值为空。

减法或减法赋值运算符（`-`或`-=`）可以从合并的委托中移除组件委托。

添加和移除操作不会更改现有委托。而是会返回一个未更改的委托或`null`。当请求的操作无效时，委托操作将返回未更改的委托。委托的调用列表是一组有序的委托，其中列表中的每个元素只调用委托所表示的一个方法。调用列表可以包含重复的方法。在调用期间，方法按照在调用列表中出现的顺序被调用。委托试图调用其调用列表中的每个方法；重复项每次出现在调用列表中时都会调用一次。委托是不可变的；一旦创建，委托的调用列表就不会更改。

# 闭包

``` csharp
Action action;

public void Test()
{
    for (int i = 0; i < 5; i++)
    {
        action = () => { Console.Write(i); };
    }
}
// Output: 5 5 5 5 5
```

**内存方法引用外层方法变量时即形成闭包。** 由于委托本质是一个类，而当委托引用了外层方法的局部变量`i`时，在IL代码中，该局部变量被提升为委托类的一个字段以便在调用委托时使用，该字段的生命周期跟此随委托类（直到此委托对象被回收），该字段的值并非局部变量创建时的值，而是在外层方法范围内的最终值。

在外层方法中无法看见委托因提升而产生的字段。委托无法从外层方法直接捕获`in`、`ref`或`out`参数。委托中的`return`不会导致外层方法直接返回。如果相应跳转语句的目标位于委托之外，委托内不得包含`goto`、`break`或`continue`语句；同样，如果目标在内部时，在委托外部使用跳转语句也是错误的。从C# 9.0开始，可以将`static`修饰符应用于Lambda表达式，以防止由Lambda无意中捕获本地变量或实例状态。静态Lambda无法从封闭范围中捕获本地变量或实例状态，但可以引用静态成员和常量定义。

只需要让委托方法使用一个临时局部变量即可防止委托方法共享数据。

委托的调用列表是一组有序的委托，其中列表中的每个元素只调用委托所表示的一个方法。调用列表可以包含重复的方法。在调用期间，方法按照它们在调用列表中出现的顺序被调用。委托试图调用其调用列表中的每个方法；重复项每次出现在调用列表中时都会调用一次。委托是不可变的；一旦创建，委托的调用列表就不会更改。

``` csharp
class Test
{
    public event Action action;
    public void Test()
    {
    	int a = 10;
    	action = () => { Console.WriteLine(a); };
    	for (int i = 0; i < 10; i++)
        {
            action = () => { Console.Write(i); };
        }
        Console.Write("******");
        for (int j = 0; j < 10; j++)
        {
            // 使用临时局部变量以防止委托方法共享数据
            int index = j;
            action = () => { Console.Write(index); };
        }
	}
}
// Output：
// 10
// ******
// 10 10 10 10 10 10 10 10 10 10
// 1 2 3 4 5 6 7 8 9 10
```

# 事件

**事件（Event）基于委托，只能作为成员存在于结构体、类和接口之中。** 首先必须声明该事件的委托类型；然后使用`event`关键字声明事件。事件被触发时会调用委托。

``` csharp
// 声明委托
public delegate void <委托名>(<参数列表>);
// 基于委托定义事件
public event <委托名> <事件名>;
```

包含事件的类用于发布事件，被称为**发布器**类。其他接受该事件的类被称为**订阅器**类。事件使用**发布-订阅**模型。发布器是一个包含事件和委托定义的对象。事件和委托之间的联系也定义在这个对象中。发布器类的对象调用这个事件，并通知其他的对象。订阅器是一个接受事件并提供事件处理程序的对象。在发布器类中的委托调用订阅器类中的方法（事件处理程序）。

``` csharp
/***********发布器类***********/
class ToolMan
{
    public string Name { get; private set; }
    public ToolMan (string name) { Name = name; }
    // 定义委托
    public delegate void DownStairDelegate ();
    // 委托实例
    public DownStairDelegate downStairDelegate = null;
    // 事件
    public event DownStairDelegate downStairEvent = null;
    
    public void DownStairs ()
    {
        Console.WriteLine("工具人" + Name + "下楼了");
        if (downStairDelegate != null) downStairDelegate(); // 触发委托
        if (downStairEvent != null) downStairEvent(); // 触发事件
    }
}
/***********订阅器类***********/
class LazyMan
{
    public string Name { get; private set; }
    public LazyMan (string name) { Name = name; }
    
    public void TakeFood () { Console.WriteLine("给" + Name + "拿外卖"); }
    public void TakePackage () { Console.WriteLine("给" + Name + "拿快递"); }
}
/***********触发***********/
public class MainClass
{
    public static void Main()
    {
        ToolMan XiaoMing = new ToolMan("小明");
        
        LazyMan ZhangSan = new LazyMan("张三");
        LazyMan LiSi = new LazyMan("李四");
        
        XiaoMing.downStairDelegate += ZhangSan.TakeFood; // 订阅
        XiaoMing.downStairDelegate += LiSi.TakePackage; // 订阅
        XiaoMing.DownStairs();
        // Output:
        // 工具人小明下楼了
        // 给张三拿外卖
        // 给李四拿快递
        
        // 委托的弊端
        LazyMan WangWu = new LazyMan("王五");
        XiaoMing.downStairDelegate = WangWu.TakeFood; // 赋值操作将清除之前的订阅
        XiaoMing.downStairDelegate(); // 类外部可以直接触发委托
        
        // 事件的限制
        XiaoMing.downStairEvent = WangWu.TakePackage; // 异常：事件不能直接赋值
        XiaoMing.downStairEvent(); // 异常：事件不能在类外部直接触发
    }
}

```

**事件是类或对象向其他类或对象发送通知的一种具有特殊签名的委托，或者说是受限制的委托，为委托提供了发布/订阅功能，是委托的一种特殊应用。事件是对委托的安全包裹，让委托的使用更具有安全性。** 事件允许在类外部订阅`+=`、取消订阅`-=`事件，但**无法使用`=`直接赋值**（*防止此前的委托链被清除*）。**事件不允许在类的外部被直接触发**，只能在类内部的合适时机触发，*防止外部随意调用委托和引发事件的不正当操作，让委托更加安全*，体现了封装思想。

委托可以在外部触发，但通常使用委托表达回调，使用事件表达外发的接口。

``` csharp
// 标准事件写法：sender为事件发布者，EventArgs为事件参数类
public delegate void EventHandler (object sender, EventArgs e);
```