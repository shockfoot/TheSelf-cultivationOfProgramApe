# 概述

接口（Interface）是一种自定义类型，是**一组对外的行为的抽象规范**，即定义了类实现接口时应遵循的语法合同，要求它的实现类必须遵循。接口仅定义了语法合同**是什么**部分，派生类则实现接口中语法合同**怎么做**部分。

- 一组：接口中可包含多个成员。
- 对外：接口的成是要求子类实现，自己不用，因此接口成员不允许使用`private`，默认`public`。
- 行为的抽象：接口只能包含抽象成员（属性、方法、索引器和事件，不能有构造函数、字段，不允许运算符重载），成员不能被实现，接口不可被实例化（不能`new`，但遵循里氏替换，可以指向实现类）。
- 规范：接口的成员要求实现类必须自行实现。

接口使用`interface`关键字声明，通常以I字母开头，只能包含抽象成员，不允许提供任何成员的实现方式。

``` csharp
interface IMyInterface
{
    void MethodToImplement();
}
```

接口的实现与类继承类似，使用`:`后加接口名称。实现接口后，需要实现接口的所有成员，成员必须与接口定义的一致。

**类与类是单继承，类与接口是多实现，接口与接口是多继承（不需要实现）。如果一个接口继承其他接口，那么实现类或结构就需要实现所有接口的成员。**

# 显示实现

**当多个接口具有相同的方法成员时，实现类按需使用显示实现接口**，即`接口名.方法名`，不能用访问修饰符，因为只能通过接口类型引用调用显示实现的接口成员。显示实现接口解决了多接口实现时的二义性和接口中成员对实现类的不适应问题。

接口中使用`protected`修饰的成员必须显示实现接口。

``` csharp
interface IGrammar1 { void Fun(); }
interface IGrammar2 { void Fun(); }
class Grammar : IGrammar1, IGrammar2
{
    void IGrammar1.Fun() { }
    void IGrammar2.Fun() { }
}
// 调用
IGrammar1 grammar1 = new Grammar();
grammar1.Fun();
IGrammar2 grammar2 = new Grammar();
grammar2.Fun();
```

# 作用

**接口是一组行为的抽象，接口只关注行为，不关注数据，且不关注行为的实现，实现由实现类完成。**

接口提供了实现类应遵循的标准结构，**规范了不同类的行为**，使得实现接口的类或结构在形式上保持一致，并扩展已有类的行为。

子类与父类（继承）是“is a（是一种）”的关系，所以只能单继承；而实现接口的类与接口是“can do（能够做）”的关系，支持多实现。如果能同时使用继承和接口，优先选择接口实现。