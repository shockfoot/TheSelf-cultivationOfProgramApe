# 内部类

在一个类中声明的类为内部类，使用时需要包裹者访问，是亲密关系的表现。内部类默认访问权限为`private`。

# 分部类

分为几部分声明的类为分部类，需用`partial`关键字定义。分部描述类可以提高程序的拓展性。

分部类可以写在多个脚本文件中，但访问修饰符需要一致，且不能有重复成员。

在分部类中可以声明分部方法。分部方法是将方法的声明和实现分离，用`partial`关键字，默认私有，不能添加访问修饰符，只能在分部类中声明，返回值只能是`void`，可以有参数但不能使用`out`关键字。

# 静态

## 静态成员

可以使用`static`关键字**把类成员定义为属于类本身而不属于特定对象**的静态成员。`static`可用于字段、方法、属性、运算符、事件和构造函数，但不能用于索引器、析构函数，不能与`abstract`、`sealed`⼀起使用。

**静态构造函数是实现在首次加载类时初始化类本身所需执行的操作的成员，没有访问修饰符和参数，无法调用，只执行一次，不能被继承。一个类只能拥有一个静态构造函数。** 实例构造函数是实现初始化类实例所需执行的操作的成员，可重载并且可具有可选参数，使用`new`运算符实例化类时自动调用。

**静态字段属于类，永远只有一个副本，只指明一个存储位置。** 实例字段属于实例，单独存储。每个类实例均包含相应类的所有实例字段的单独副本。静态字段通常用于记录已实例化对象的个数或存储必须在所有实例之间共享的值。

> 注意：虽然字段不能声明为`static const`，但`const`常量字段的行为在本质上是静态的，即常量隐式地是静态成员。这样的字段属于类，不属于实例。因此，可以同对待静态字段一样使用类名访问`const`字段而不需要对象实例。C#不支持静态局部变量（在方法范围内声明的变量）。

**静态方法通过类调用，在对象被创建之前就已经存在，只能访问静态成员（非静态成员需要实例化后才存在）。静态方法可以被重载但不能被重写，因为它们属于类，不属于类的任何实例。** **实例方法通过类实例调用，能访问静态和实例成员。** 对静态方法的调用以Microsoft中间语言（MSIL）生成调用指令，而对实例方法的调用生成callvirt指令，该指令还检查`null`对象引用。但是，两者之间的性能差异在大多数时候并不明显。**静态方法可以实现扩展方法。**

**成员要么是静态的，要么是实例的。静态成员属于类，通过类名访问；而实例成员属于对象，用变量/对象访问。** 无论对一个类创建多少个实例，其静态成员都只有一个副本。静态成员在程序第一次运行时就会分配内存空间，在被访问之前并且在调用静态构造函数（若有）时进行初始化。

## 静态类

使用`static`可以将类定义为静态类。**静态类的成员都必须是静态的。静态类不能被实例化（体现工具类的唯一性），是密封的（无法继承，不能从除`object`外的任何类中继承），不能包含实例构造函数，但可以包含静态构造函数。** 如果非静态类包含需要进行重要的初始化的静态成员，也应定义静态构造函数。

当加载引用静态类的程序时，CLR将加载该静态类的类型信息。程序不能指定加载静态类的确切时间，但可以保证在程序中首次引用该类前加载该类，并初始化该类的字段并调用其静态构造函数。

> **经测试，静态类中的静态变量初始化与静态构造函数调用有时间差异。**
> 类有一个隐藏属性beforefieldinit，即JIT编译器会在首次访问静态字段或静态/实例方法之前，或创建类型的实例之前，随便找一个时间生成调用，具体时机由CLR决定，其只保证在访问成员之前会执行（隐式）静态构造函数，但可能会提早执行。
> 当静态类拥有显式构造函数时，beforefieldinit属性会被precise属性替换，确保静态成员在类第一次使用之前的那一刻进行初始化。

静态构造函数仅调用一次，在程序驻留的应用程序域的生存期内，静态类一直保留在内存中。

非静态类可以包含静态的方法、字段、属性或事件。即使没有创建类的实例，也可以调用该类中的静态成员。无论对一个类创建多少个实例，其静态成员都只有一个副本。静态方法和属性不能访问其包含类型中的非静态字段和事件，并且不能访问任何对象的实例变量（除非在方法参数中显式传递）。

# 抽象

## 抽象类

类可以声明为`abstract`（不能与`sealed`、`static`⼀起使用）。**抽象类可以包含普通方法和抽象方法。抽象类不能实例化，即不能`new`（但遵循里氏替换，可以指向子类实例），只能通过可实现抽象方法的子类来使用该类。抽象类要求其子类必须实现其抽象方法。抽象类可继承抽象类。**

抽象类表示一个概念的抽象，只表示能做什么、拥有什么数据，而不表达具体做法，适用于有行为而不需要实现、行为在做法上有多种可能但又不希望客户了解具体做法、不希望类创建对象。抽象类常与多态配合用于框架设计。

## 抽象方法

**`abstract`可以修饰抽象类中的方法或属性，此时，方法或属性不能包含实现，且访问级别不能为私有。抽象方法就是只有方法定义没有方法体，只能存在于抽象类中，非抽象子类必须通过`override`关键字实现。显然，抽象方法本⾝也是虚拟的（只有方法定义，没有方法体实现）。**

# 密封

C#允许把类和方法声明为`sealed`（密封，不能和`abstract`、`static`⼀起使用）。**对于类，表示不能被继承；对于方法或属性，必须与`override`一起使用，表示不能被重写，即只能将已经重写的方法或属性声明为密封的。**

通常将底层子类密封以使程序保持规范性和安全性。