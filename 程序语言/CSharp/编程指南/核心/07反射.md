# 程序集

**程序集（Assembly）是经由编译器编译得到的，供进一步编译执行的中间程序。在Windos系统中，通常以动态链接库文件.dll或可执行文件.exe为后缀**（.exe文件包含Main函数，可以直接运行，而.dll不能直接运行）。程序集中包含有Microsoft 中间语言 (MSIL) 和必需的元数据。在执行时，MSIL会被实时 (Just-in-time，JIT) 编译为本机代码。应用程序结构分为应用程序域AppDomain—程序集Assembly—模块Module—类型Type—成员EventInfo、FieldInfo、MethodInfo和PropertyInfo几个层次。公共语言运行时加载程序（CLR Loader）管理应用程序域（Application Domain），这些域构成具有相同应用程序范围的对象的作用边界。这种管理包括将每个程序集加载到适当的应用程序域中，以及控制每个程序集中类型层次结构的内存布局。

程序集包含资源文件、元数据和IL代码。使用程序集可以在程序中只引用必须的程序集，减小程序尺寸；程序集可以封装代码，只提供必要的接口并方便扩展。

由于程序集在编译后并不一定会生成单个文件，而可能会生成多个物理文件，甚至可能会生成分布在不同位置的多个物理文件，所以**程序集是一个逻辑单元**，而不是一个物理单元，即程序集在逻辑上是一个编译单元，但在物理储存上可以有多种存在形式。对于静态程序集可以生成单个或多个文件，而动态程序集是存在于内存中的。一个程序集可以只由一个文件组成，也可由多个文件组成。不管是单文件程序集还是多文件程序集，它们都由固定的结构组成。

# 元数据

程序本身（类的定义和基础类库（Basic Class Lib，BCL）中的类）是数据。**有关程序及其类型的数据被称为元数据**，它们保存在程序的程序集中。元数据是用来描述数据的数据。

元数据存储以下信息：

- **程序集的说明**：标识（名称、版本、区域性、公钥）、导出的类型、该程序集所依赖的其他程序集、运行所需的安全权限。
- **类型的说明**：名称、可见性、基类和实现的接口、成员（方法、字段、属性、事件、嵌套的类型）。
- **特性**：修饰类型和成员的其他说明性元素。

# 反射

程序在运行时，可以查看其他程序集和其本身的元数据。**一个运行的程序查看其他程序集或其本身元数据的行为被称为反射（Reflection）。** 反射是用来处理数据的。

> **注意**：反射读取的是元数据，反编译读取的IL代码。

**无论类型及其成员的访问级别如何，使用反射获取有关类型及其成员的信息都不需要任何权限，访问公共的成员也不需要权限，但通常不可访问的成员，例如私有或内部方法、受保护字段时，代码必须具有`ReflectionPermission`。**

反射是程序可以访问、检测和修改它本身状态或行为的一种能力。反射提供了封装程序集、模块和类型的对象。可以使用反射**动态（在运行时）**获取类型信息、动态创建对象、动态访问成员、延迟绑定属性和方法、查看特性信息。然后，可以调用类型的方法或访问其字段和属性。

作用：反射可以在编译后获得程序的信息，提高了程序的灵活性和拓展性。

- 程序运行时得到所有元数据，包括元数据的特性。
- 在编译时无法了解类型，在运行时获取类型信息，可以创建、操作对象。

优点：

- 反射提高了程序的灵活性和扩展性。
- 降低了程序的耦合性，提高自适应能力。
- 允许程序创建和控制任何类的对象，无需提前硬编码目标类。

缺点：

- 编译时无法保证类型安全。
- 使用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码：依据目标类型字符串扫描程序集元数据耗时，反射调用方法和属性耗时（必须先将实参打包pack成数组，然后在内部解包unpack到线程栈）。因此反射机制主要应用在对灵活性和拓展性要求很高的系统框架上，普通程序不建议使用。
- 使用反射会模糊程序内部逻辑。程序员希望在源代码中看到程序的逻辑，反射却绕过了源代码的技术，因而会带来维护的问题，反射代码比相应的直接代码更复杂。

通过使用多态以减少对反射的使用。

# Type

BCL声明了一个名为`Type`的抽象类。`Type`包含类型的特性。`Type`的对象可以获取程序相应类型的信息，是反射系统的核心，是访问元数据的主要方式。

对于程序中用到的每一个类型，CLR都会创建一个包含这个类型信息的`Type`类对象。程序中用到的每一个类型都会关联到独立的一个`Type`类对象。不管创建的类型有多少个实例，只有`Type`类对象会关联到这些实例。

反射流程：得到数据类型，动态创建对象，查看类型信息（本身信息和成员信息）。

取得数据类型

- `对象.GetType()`：根据对象获取类型，适合未知类型。
- `typeof(类型名)`：根据数据类型获取类型，适合已知类型。
- `Type.GetType("命名空间.类型名")`：根据完整类型名称获取类型，适合已知类型。

获取程序集：`typeObject.Assembly`。

获取所有公共成员：`typeObject.GetMembers()`。

获取所有公共构造函数：`typeObject.GetConstructors()`。

获取某构造函数并执行：获取构造函数`typeObject.GetConstructor(参数的Type数组)`，传入`Type`数组，为按顺序传入的参数的`Type`对象；执行构造函数`custructorInfoObj.Invoke(参数的Object数组)`，传入`Object`数组，为按顺序传入的参数。

``` csharp
Type t = typeof(Test);
// 获取无参构造函数
ConstructorInfo info = t.GetConstructor(new Type[0]);
// 执行无参构造函数
object obj = info.Invoke(null);
```

获取所有公共成员变量：`typeObject.GetFields()`。

获取指定名称的公共成员变量：`typeObject.GetField("成员变量名")`。

获取公共成员变量的值：`fieldInfoObj.GetValue(obj)`。

设置公共成员变量的值：`fieldInfoObj.SetValue(value)`。

获取所有公共成员方法：`typeObject.GetMethods()`。

获取并执行指定的公共成员方法：`typeObject.GetMethod("方法名", 参数的Type对象数组)`；调用方法：`methodInfoObj.Invoke(执行方法的对象, 参数的Object数组)`，如果是静态方法，第一个参数为`null`。

获取枚举：`GetEnumNames()`、`GetEnumName()`。

获取事件：`GetEvents()`、`GetEvent()`。

获取接口：`GetInterfaces()`、`GetInterface()`。

获取属性：`GetPropertys()`、`GetProperty()`。

判断是否使用了某个特性：`typeObj.IsDefined(特性的类型, 是否搜索继承链)`。

获取所有特性：`GetCustomAttributes(是否搜索继承链)`。

# Activator

`Activator`类用于快速实例化对象，即将`Type`对象快捷实例化为对象。

- `Activator.CreateInstance(Type)`：无参构造函数实例化。
- `Activator.CreateInstance(Type, 参数列表)`：含参构造函数实例化。

# Assembly

程序集`Assembly`类主要用于加载其他程序集，加载后才能用`Type`对象使用该程序集中的信息。

加载程序集：

- `Assembly.Load("程序集名称")`：加载同一文件下的其他程序集。
- `Assembly.LoadFrom("包含程序集清单的文件的路径名")`：加载其他文件下的程序集。
- `Assembly.LoadFile("程序集文件的完全限定路径")`：加载其他文件下的程序集。

获取程序集中的类型

- `assemblyObj.GetTypes()`：获取该程序集中的所有类型。
- `assemblyObj.GetType("命名空间.类型名")`：获取该程序集中指定的类型。

# 汇总

取得数据类型

- `对象.GetType()`：根据对象获取类型，适合未知类型。
- `typeof(类型名)`：根据数据类型获取类型，适合已知类型。
- `Type.GetType("命名空间.类型名")`：根据完整类型名称获取类型，适合已知类型。
- `Assembly.Load("路径").GetType("类型名")`：适合其他程序集中的类型。

动态创建对象：

- `Activator.CreateInstance(Type)`
- `Assembly assembly = Assembly.Load(程序集); assembly.CreateInstance(Type);`
- `type.GetConstructor(typeof(string)).Invoke()`：找到含参构造方法，动态调用该构造方法。

# 练习

JSON解析器：对象与JSON字符串的相互转化。

``` csharp
public string Object2Json(object obj)
{
    Type type = obj.GetType();
    PropertyInfo[] properties = type.GetProperties();
    StringBuilder jsonString = new StringBuilder();
    jsonString.Append("{");
    foreach (PropertyInfo item in properties)
        jsonString.AppendFormat("\"{0}\":\"{1}\",", item.Name, item.GetValue(obj));
    jsonString.Remove(properties.Length - 1, 1);
    jsonString.Append("}");
    return jsonString;
}

public T Json2Object<T>(string json) where T : new()
{
    T instance = new T();
    Type type = instance.GetType();
    json.Replace("\"", string.Empty).Replace("{", string.Empty).Replace("}", string.Empty);
    string[] keyValue = json.Split(":", ",");
    for (int i = 0; i < keyValue.Lengthl; i += 2)
    {
        PropertyInfo property = type.GetProperty(keyValue[i]);
        object value = Convert.ChangeType(keyValue[i + 1], property.PropertyType)
        property.SetValue(instance, value);
    }
    return instance;
}
```
