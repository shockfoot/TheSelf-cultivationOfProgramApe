# 特性

特性（Attribute）是用于在运行时传递程序中各种元素（比如类、方法、结构、枚举、组件等）的行为信息的声明性标签，是一种允许向程序所在的程序集添加元数据的语言结构，是用于保存程序结构信息的特殊类型的类。

特性提供功能强大的方法以将声明信息与C#代码关联。程序员可以将特性附加到各种程序实体，并在运行时环境中通过反射检索特性信息。

特性的目的是告诉编译器把程序结构的某组元数据嵌入程序集中。

特性本质是个类，可使用特性为元数据添加额外信息，如编译器指令和注释、描述、方法、类等其他信息。应用了特性的程序结构被称为目标，获取或使用元数据的程序被称为消费者。

将特性应用于程序结构时，编译器获取源代码并从特性产生元数据，并将元数据放到程序集中。消费者程序可以获取特性产生的元数据和程序中其他组件的元数据。编译器同时产生和消费特性。

特性的名称和值是在方括号内规定的（本质上是在调用特性类的构造函数），放置在它所应用的元素之前。`positional_parameters`规定必需的信息，`name_parameter`规定可选的信息。

``` csharp
[特性(参数列表)]
类/方法/变量声明
```

.Net框架提供了两种类型的特性：预定义特性和自定义特性。每个特性都对应一个类。预定义特性是.Net框架定义的特性类。

# 自定义特性

自定义特性类命名时应使用Pascal命名法，必须以`Attribute`后缀结尾，必须继承`System.Attribute`类。

特性类应该表示目标结构的一些状态。如果特性需要字段，可以包含具有位置参数（按构造函数中参数的位置赋值）的构造函数来收集数据，可选字段可以采用命名参数（按照属性的名字进行初始化）按需初始化。除了属性之外，不要使用公共方法和其他方法成员。为了安全，把特性类声明为`sealed`（不能被继承）。

通过为特性类加特性`[ArrtributeUasge(AttributeTargets, AllowMultiple, Inherited)]`以限制其使用范围，即指定可应用到的目标组。

``` csharp
[AttributeUsage(AttributeTargets.Class)] // 此特性仅用于类
internal sealed class InformationAttribute : Attribute
{
    public string Description; // 描述，位置参数
    public string Developer; // 开发者，命名参数
    public string Version; // 版本，命名参数
    
    public InformationAttribute (string description, string developer = "ZhengXing", string version = "v0.1")
    {
        this.Developer = developer;
        this.Version = version;
        this.Description = description;
    }
}
```

当为目标应用特性时，可以省略`Attribute`后缀结尾。使用特性时，需要调用特性内部的构造方法并且传递相应参数。特性构造方法的参数必须是能在编译期间确定值的实参。如果调用无参构造方法，则可以省略`()`。

``` csharp
[Information("这是一个无用类", Developer = "LaLa", Version = "v0.1")]
class Program
{
    static void Main ()
    {
        // 提供反射消费特性
        Type t = typeof(Program);
        bool rel = t.IsDefined(typeof(InformationAttribute), flase); // 检查此类是否某应用特性
        object[] attributes = t.GetCustomAttibutes(false); // 获取此类上应用的特性
        for (int i = 0; i < attributes.Length; i++)
        {
            if (attributes[i] is Information information)
            {
                Console.WriteLine(information.Developer);
            }
        }
    }
}
```

# 预定义特性

## AttributeUsage特性应用范围

预定义特性`System.AttributeUsageAttribute`描述了如何使用一个自定义特性类。它规定了特性可应用到的项目的类型。

``` csharp
[AttributeUsage(validOn, AllowMultiple = allowmultiple, Inherited = inherited)]
```

其中参数`validOn`规定特性可被放置的语言元素。它是枚举器`AttributeTargets`的值的组合，默认值是`AttributeTargets.All`。可选参数`allowmultiple`为该特性的`AllowMultiple`属性提供一个布尔值。如果为`true`，则该特性是多用的，否则是单用的，默认值是`false`。可选参数`inherited`为该特性的`Inherited`属性提供一个布尔值。如果为`true`，则该特性可被派生类继承，否则不能被派生类继承，默认值是`false`。

``` csharp
[AttributeUsage(
    AttributeTargets.Class | AttributeTargets.Constructor | AttributeTargets.Field |
    	AttributeTargets.Method | AttributeTargets.Property, 
    AllowMultiple = true
)]
```

## Obsolete弃用

预定义特性`System.ObsoleteAttribute`标记了不应被使用的程序实体。它可以通知编译器丢弃某个特定的目标元素。

``` csharp
[Obsolete(message, iserror)]
```

`()`中参数都是可选的。其中参数`message`是一个字符串，描述项目为什么过时以及该替代使用什么。参数`iserror`是一个布尔值。如果该值为`true`，编译器应把该目标的使用当作一个错误，否则仅生成一个警告，默认值是`false`。

``` csharp
[Obsolete("此方法已被弃用，请使用NewTest代替", true)]
public void Test () => Console.WriteLine("Test");
// 当尝试编译该程序时，编译器会给出一个错误消息说明:
// 此方法已被弃用，请使用NewTest代替
```

## Conditional条件

预定义特性`System.Diagnostics.ConditionalAttribute`标记了一个条件方法，其执行依赖于指定的预处理标识符。条件方法只能是类或结构中未被`override`修饰的返回类型为`void`的方法，并且不能是接口方法的实现。它会根据指定的值包括或取消特定方法的调用，即条件编译。标记方法的CIL代码本身总会是包含在程序集中，只是调用代码会被插入或忽略。

``` csharp
#define conditionalSymbol
[Conditional(conditionalSymbol)]
```

Conditional特性会根据指定参数是否被定义条件编译标记元素。当指定参数未被定义时，会忽略调用标记元素，反之则包括目标的调用。

``` csharp
// 宏
#define IsShowMessage

class Program
{
    // Conditional特性：根据指定参数是否被定义条件编译标记元素
    [Conditional(IsShowMessage)]
    static void ShowMessage(string str) => Console.WriteLine(str);
    
    static void Main()
    {
        // IsShowMessage被定义时，ShowMessage方法不会被调用
        ShowMessage("Main方法开始执行");
        Console.WriteLine("Main方法的工作");
        ShowMessage("Main方法执行完毕");
    }
    // Output: Main方法的工作
}
```

## 调用者信息

`System.Runtime.CompilerServices`提供了三个用于向**可选参数**提供有关调用上下文的信息的特性：`CallerLineNumberAttribute`、`CallerFilePathAttribute`和`CallerMemberNameAttribute`。在方法形参之前添加调用者信息特性可以获取相应的调用者信息。被调用者信息特性批注的参数需要赋初值。

``` csharp
public void Log(
    [CallerLineNumber] int line = -1, // 获取调用者行号
    [CallerFilePath]   string path = null, // 获取调用者所在文件路径
    [CallerMemberName] string name = null // 获取调用者的名称
)
```

当使用调用者信息特性之一批注可选参数时，忽略调用中的相应参数不一定会导致替换默认参数值。相反，如果指定的有关调用上下文的信息可用，则会将该信息作为参数值传递。

调用者信息特性可以出现在任何地方的可选参数上，包括在委托声明中。但是，特定的调用者信息特性对它们可以批注的参数类型有限制，因此将始终进行从替代值到参数类型的隐式转换。

调用者信息不会影响重载解析。由于特性化可选参数仍会从调用方的源代码中省略，因此重载将忽略这些参数。仅当在源代码中显式调用函数时，才会替换调用方信息。隐式调用（如隐式父构造函数调用）没有源位置，并且不会替换调用方信息。而且，动态绑定的调用不会替换调用方信息。如果在这种情况下省略了调用方信息特性化参数，则改为使用参数的指定默认值。

如果在给定参数上指定了多个调用方信息特性，则它们将按以下顺序执行：`CallerLineNumber` 、`CallerFilePath` 、`CallerMemberName` 。

## DebuggerStepThrough

`System.Diagnostics.DebuggerStepThroughAttribute`指示调试器逐句通过代码，而不是单步执行代码，即Visual Studio调试器不会在用此特性标记的目标（类、结构、构造方法、方法、访问器）中停止，即使在此方法中设置了断点。提供此特性以供源代码调试器使用，公共语言运行时不受此特性的影响。

## 外部Dll包方法

`System.Runtime.InteropServices.DllImport`用来标记非.Net方法，表明该方法在一个外部的Dll中定义，一般用来调用C或C++的Dll包中写好的方法。

``` csharp
[DllImport("Dll包路径名")]
public static extern 返回值 方法名(参数列表);
```