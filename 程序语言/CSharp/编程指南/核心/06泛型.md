# 泛型

泛型（Generic）是C# 2.0推出的新语法，不是语法糖，是由框架升级提供的新功能。泛型允许延迟编写类或方法中的数据类型，直到在程序中使用时确定，即泛型允许编写可与任何数据类型工作的类或方法。

使用泛型是一种增强程序功能的技术：

- 实现了类型参数化，通过类型参数化实现同一代码操作多种类型，有助于**最大限度地重用代码、保护类型安全性以及提高性能（避免类型换行和装/拆箱）**。
- 经常用于创建集合类。
- 可以自定义泛型接口、泛型类、泛型方法、泛型事件和泛型委托。
- 可以对泛型类进行约束以限制数据类型。
- 在泛型数据类型中所用类型的信息可在运行时通过使用反射来获取。

可以创建自己的泛型接口、泛型类、泛型方法、泛型事件和泛型委托；可以对泛型类进行约束以访问特定数据类型的方法；关于泛型数据类型中使用的类型的信息可在运行时通过使用反射获取。在继承/实现时，如果子类/实现类不是泛型的，可以不指定具体类型，否则必须指定具体类型。

# 类型参数

在泛型类型或方法定义中，泛型类型参数`T`是在其创建泛型类型的一个实例时，指定的特定类型的占位符。

泛型类无法按原样使用，因为它不是真正的类型，更像是类型的蓝图。在使用时，必须通过指定尖括号内的类型参数来声明并实例化构造类型。此特定类的类型参数可以是编译器可识别的任何类型。可创建任意数量的构造类型实例，其中每个使用不同的类型参数，以逗号`,`分隔。

``` csharp
GenericList<float> list1 = new GenericList<float>();
GenericList<ExampleClass> list2 = new GenericList<ExampleClass>();
GenericList<int, bool> list3 = new GenericList<int, bool>();
```

类型参数命名时需使用描述性名称命名泛型类型参数，除非单个字母名称完全具有自我说明性且描述性名称不会增加任何作用。对具有单个字母类型参数的类型，考虑使用`T`作为类型参数名称。在类型参数描述性名称前添加前缀 “T”。在参数名称中指示出类型参数的约束。

## 泛型约束

泛型类型约束可以限制类型参数的类型，即确保泛型用于预期的特定类型。

在没有任何约束的情况下，类型参数可以是任何类型。声明这些约束意味着可以使用约束类型的操作和方法调用。如果泛型类或方法对泛型成员使用除简单赋值之外的任何操作或调用`object`不支持的任何方法，则将对类型参数应用约束。如果使用不满足约束的类型，编译器将发出错误。通过使用`where`上下文关键字指定约束。

- ` where T : struct`：类型参数必须是不可为`null`值类型。由于所有值类型都具有可访问的无参数构造函数，因此`struct`约束表示`new()`约束且不能与之合用。`struct`约束也不能与 `unmanaged`约束合用。
- `where T : class`：类型参数必须是引用类型。在可为`null`的上下文中，`T`必须是不可为`null`的引用类型。
- `where T : class?`：类型参数必须是可或不可为`null`的引用类型。
- `where T : notnull`：类型参数必须是不可为`null`的类型。
- `where T : default`：重写方法或提供显式接口实现时，如果需要指定不受约束的类型参数，此约束可解决歧义。`default`约束表示基方法，但不包含`class`或`struct`约束。
- `where T : unmanaged`：类型参数必须是不可为`null`的非托管类型。`unmanaged`约束表示`struct`约束，且不能与`struct`约束或`new()`约束结合使用。
- `where T : new()`：类型参数必须具有公共无参数构造函数，且为非抽象类型。与其他约束一起使用时，`new()`约束必须最后指定。`new()`约束不能与`struct`和`unmanaged`约束结合使用。
- `where T : <基类名>`：类型参数必须是指定的基类或派生自指定的基类。在可为`null`的上下文中，`T`必须是指定基类派生的不可为`null`的引用类型。
- `where T : <基类名>?`：类型参数必须是指定的基类或派生自指定的可或不可为`null`的基类。
- `where T : <接口名称>`：类型参数必须是指定的接口或实现指定的接口。可指定多个接口约束。约束接口也可以是泛型。在可为`null`的上下文中，`T`必须是实现指定接口的不可为`null`的类型。
- `where T : <接口名称>?`：类型参数必须是指定的接口或实现指定的可为`null`的引用类型、不可为`null`的引用类型或值类型的接口，不能是可为`null`的值类型。可指定多个接口约束。约束接口也可以是泛型。
- `where T : U`：类型参数必须是`U`或派生自`U`的类型。在可为`null`的上下文中，如果`U`是不可为`null`的引用类型，`T`必须是不可为`null`的引用类型；如果`U`是可为`null`的引用类型，则`T`可以是可为或不可为`null`的引用类型。

可以对同一类型参数应用多个约束，并且约束自身可以是泛型类型。可以对多个参数应用多个约束。

``` csharp
class Base { }
class Test<T, U>
    where U : struct
    where T : Base, new()
{ }
```
没有使用类型约束的类型参数称为**未绑定的类型参数**。未绑定的类型参数具有以下限制：

- 不能使用`!=`和`==`运算符，因为无法保证具体的类型参数能支持这些运算符。
-  可以与`System.Object`或任何接口类型进行转换。
-  可以与`null`进行比较。如果类型参数为值类型，则该比较将始终返回`false`。

## 泛型类

泛型类封装不特定于特定数据类型的操作。泛型类最常见用法是用于链接列表、哈希表、堆栈、队列和树等集合。无论存储数据的类型如何，添加项和从集合删除项等操作的执行方式基本相同。

通常，创建泛型类是从现有具体类开始，然后每次逐个将类型更改为类型参数，直到泛化和可用性达到最佳平衡。创建自己的泛型类时，需要考虑：

- 要将哪些类型泛化为类型参数。通常，可参数化的类型越多，代码就越灵活、其可重用性就越高。但过度泛化会造成其他开发人员难以阅读或理解代码。
- 要将何种约束（如有）应用到类型参数。其中一个有用的规则是，应用最大程度的约束，同时仍可处理必须处理的类型。
- 是否将泛型行为分解为基类和子类。因为泛型类可用作基类，所以非泛型类的相同设计注意事项在此也适用。
- 实现一个泛型接口还是多个泛型接口。

类型参数和约束规则对于泛型类行为具有多种含义，尤其是在继承性和成员可访问性方面。对于泛型类`Node<T>`，可通过指定类型参数来引用类，创建封闭式构造类型`Node<int>`；或者，可以不指定类型参数（如指定泛型基类时），创建开放式构造类型`Node<T>`。开放式构造和封闭式构造类型可用作方法参数。泛型类可继承自具体的封闭式构造或开放式构造基类。非泛型类（即具体类）可继承自封闭式构造基类，但不可继承自开放式构造类或类型参数，因为运行时无法提供实例化基类所需的类型参数。继承自开放式构造类型的泛型类必须对非此继承类共享的任何基类类型参数提供类型参数。继承自开放式构造类型的泛型类必须指定作为基类型上约束超集或表示这些约束的约束。

``` csharp
class BaseNode { }
class BaseNodeGeneric<T> { }
// concrete type
class NodeConcrete<T> : BaseNode { }
//closed constructed type
class NodeClosed<T> : BaseNodeGeneric<int> { }
//open constructed type
class NodeOpen<T> : BaseNodeGeneric<T> { }
```

如果一个泛型类实现一个接口，则该类的所有实例均可强制转换为该接口。

## 泛型方法

通过类型参数声明泛型方法。调用时可省略类型参数，编译器将推断类型参数。类型推理的相同规则适用于静态方法和实例方法。编译器可基于传入的方法参数推断类型参数；而无法仅根据约束或返回值推断类型参数。因此，类型推理不适用于不具有参数的方法。类型推理发生在编译时，之后编译器尝试解析重载的方法签名。编译器将类型推理逻辑应用于共用同一名称的所有泛型方法。在重载解决方案步骤中，编译器仅包含在其上类型推理成功的泛型方法。

``` csharp
static void Swap<T>(ref T lhs, ref T rhs)
{
    T temp;
    temp = lhs;
    lhs = rhs;
    rhs = temp;
}

Swap<int>(ref a, ref b);
// 等同于
Swap(ref a, ref b);
```

在泛型类中，非泛型方法可访问类级别类型参数。

``` csharp
class SampleClass<T>
{
    void Swap(ref T lhs, ref T rhs) { }
}
```

如果定义一个具有与包含类相同的类型参数的泛型方法，则编译器会生成警告CS0693，因为在该方法范围内，向内`T`提供的参数会隐藏向外`T`提供的参数。如果需要使用类型参数（而不是类实例化时提供的参数）调用泛型类方法所具备的灵活性，请考虑为此方法的类型参数提供另一标识符，如`U`所示。

``` csharp
class GenericList<T>
{
    void SampleMethod<T>() { } // CS0693
}

class GenericList2<T>
{
    void SampleMethod<U>() { } //No warning
}
```

使用约束在方法中的类型参数上实现更多专用操作。

泛型方法可在泛型参数上重载。

``` csharp
void DoWork() { }
void DoWork<T>() { }
void DoWork<T, U>() { }
```

# 协变与逆变

## 泛型类型转换

通常情况下，父类引用可以指向子类对象，子类引用不可以指向父类对象，如：

``` csharp
class Base { }
class Derived : Base { }

// 父类引用可以指向子类对象
Base base = new Derived();
// 子类引用不可以指向父类对象：编译不通过
Derived derived = new Base();
```

**对于泛型，父类引用不可指向子类对象**，如：

``` csharp
// 编译通过
GenericList<Base> list1 = new GenericList<Base>();
// 父类泛型不能指向子类泛型对象：编译不通过
GenericList<Base> list2 = new GenericList<Derived>();
// 子类泛型不能指向父类泛型对象：编译不通过
GenericList<Derived> list3 = new GenericList<Base>(); 
```

原因：

``` csharp
class GenericList<T>
{
    public T Function() { }
    public void Action(T t) { }
}
class Base { }
class Derived : Base { }

// 父类泛型不能指向子类泛型对象
GenericList<Base> list1 = new GenericList<Derived>();
list1.Function(); // 实际调用GenericList<Derived>.Function，会返回Derived，而list1将返回Base，Derived可以转换为Base，类型安全
list1.Action(param); // 实际调用GenericList<Derived>.Action，需要传入Derived，而list1只能传入Base，Base无法转换为Derived，类型不安全

/* 形象表示：
 * 返回：Base <--- Derived（安全）
 * 传参：Base ---> Derived（不安全）
*/

// 子类泛型不能指向父类泛型对象
GenericList<Derived> list2 = new GenericList<Base>();
list2.Function(); // 实际调用GenericList<Base>.Function，会返回Base，而list1将返回Derived，Base无法转换为Derived，类型不安全
list2.Action(param); // 实际调用GenericList<Base>.Action，需要传入Base，而list1只能传入Derived，Derived可以转换为Base，类型安全

/* 形象表示：
 * 返回：Derived <--- Base（不安全）
 * 传参：Derived ---> Base（安全）
*/
```

## 协变和逆变

协变（Covariance）指能够使用比原始指定的派生类型的派生程度更大（更具体）的类型，使用`out`关键字指定。**使用`out`关键字修饰的类型参数只能作为属性或方法的返回值使用，可以让子类泛型类型参数安全地转换为父类泛型类型参数，即父类泛型可以指向子类泛型对象。** 协变指和谐的、自然的变化。因为里氏替换原则，父类泛型委托装子类泛型委托是和谐的。

逆变（Contravariance）指能够使用比原始指定的派生类型的派生程度更轻（更抽象）的类型，使用`in`关键字指定。**使用`in`关键字修饰的类型参数只能作为属性或方法的参数使用，可以让父类泛型类型参数安全地转换为子类泛型类型参数，即子类泛型可以指向父类泛型对象。** 逆变指非常规的、不正常的变化。因为里氏替换原则，子类泛型委托装父类泛型委托是不和谐的。

不变（Invariance）指只能使用最初指定的类型。泛型类型参数既不是协变，也不是逆变。

**协变和逆变只能用于泛型接口和泛型委托。不能对同一泛型类型参数同时使用协变和逆变。**

协变：

``` csharp
// 协变
interface IInterface<out T>
{
    T Function();
    // void Action(T t);
}
class GenericList<T> : IInterface<T>
{
    public T Function() { }
    public void Action(T t) { } // 属于类
}
IInterface<Base> list1 = new GenericList<Derived>();
list1.Function(); // 实际生成的Derived可以转换为Base返回，类型安全
// list1.Action(param); // 实际传入的Base无法转换为Derived传入，类型不安全
```

逆变：

``` csharp
interface IInterface<in T>
{
    // T Function();
    void Action(T t);
}
class GenericList<T> : IInterface<T>
{
    public T Function() { } // 属于类
    public void Action(T t) { }
}
// 子类泛型不能指向父类泛型对象
IInterface<Derived> list2 = new GenericList<Base>();
// list2.Function(); // 实际生成的Base无法转换为Derived返回，类型不安全
list2.Action(param); // 实际传入的Derived可以转换为Base传入，类型安全
```

# 泛型运行原理

**泛型是延迟声明的，即定义时没有指定具体的参数类型，把参数类型的声明推迟到调用时指定。**

普通C#程序被编译成中间语言（IL），运行时IL经过实时编译（JIT）生成机器码。

对于泛型，编辑器在编译时遇到泛型，会将其编译成包含**具有类型参数标识的元数据**，即生成占位符；在JIT编译时，会将占位符替换成具体的数据类型。

使用值类型构造泛型类实例时，JIT创建专用的泛型类型，并在此后每次使用该指定值类型的泛型类时使用此专用的泛型类型。然而，当使用另一值类型创建同一个泛型的泛型类实例时，JIT会生成另一个专用泛型类型。对于引用类型构造的泛型类实例，使用不同类型不会额外创建新的专用泛型类型。如：

- 声明了一个整数堆栈`Stack<int> stack`，此时JIT生成此专用类型`Stack<int>`；之后，每次创建一个新的`Stack<int> newStack`时都使用此专用类型`Stack<int>`。但当声明了一个长整数堆栈`Stack<long> longStack`时，JIT生成另一个专用类型`Stack<long>`，而不继续使用专用类型`Stack<int>`。
- 对于引用类型`Teacher`和`Student`，声明栈`Stack<Teacher>`和`Stack<Student>`时使用同一专用泛型类型。

出现上述现象的原因时引用类型的引用大小是相同的，不需要担心内存不够的问题；而对于值类型，不同值类型的大小不同，需要重新分配内存。

# 为什么要使用泛型？

在开发过程中，经常遇到功能相似的模块，但处理的数据类型不同。为了适配不同的数据类型，在没有泛型时，只能针对特定类型编写重复方法或者使用万物之父`object`类。

- 针对每个类型写重复的方法：**大量重复的代码，每次增加新类型都需要增加对应的处理方法**。
- 使用`object`类：需要进行类型转换，会出现**装/拆箱的性能消耗和类型安全**的问题。

使用泛型，可以指定特定类型占位符，即**类型参数**，使得在编写代码时不需要关心具体的类型而只专注于操作。泛型无法按原样使用，因为泛型不是真正的类型；泛型更像蓝图，定义了一组相同的操作。