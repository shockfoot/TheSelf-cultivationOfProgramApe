# 数据结构

数据结构（Data Structure）是指相互间存在一种或多种特定关系的数据元素的集合，是组织并存储数据以便能够有效使用的一种专门格式，用来反映一个数据的内部构成，即一个数据由那些成分数据构成、以什么方式构成、呈什么结构。

**数据结构分为逻辑结构和物理（存储）结构。**

**数据的逻辑结构指数据元素之间的逻辑关系（与实现无关）。** 逻辑结构可分为集合结构、线性结构、树形结构、图形结构。其中，集合结构中的数据元素除了同属于一个集合外没有其他任何关系。

线性结构有且仅有一个开始元素和末尾元素。除了开始元素，其他数据元素都只有一个直接前驱；除了末尾元素，其他数据元素都只有一个直接后继。线性结构中的数据元素之间是一对一的线性关系。

树形结构中除了开始元素以外每个数据元素都只有一个直接前驱，所有数据元素都可以有任意数量的直接后继。树形结构中的数据元素是一对多的关系。

图形结构中每个数据元素都可以有任意数量的直接前驱和直接后继。图形结构中的数据元素是多对多的关系。

**物理结构指数据的逻辑结构在计算机中的存储形式。** 物理结构包括顺序存储、链式存储、索引存储，以及散列存储。

顺序存储结构把逻辑上相邻的数据元素存储在物理位置上相邻的存储单元中，数据元素之间的逻辑关系由存储单元的邻接关系来体现，其数据元素的逻辑关系和物理关系是一致的。通常顺序存储结构是借助于计算机程序设计语言的数组来描述的。

链式存储结构把数据元素存放在任意的存储单元里，每个存储单元对应一个需要存储的数据元素。。每个数据元素都是由**数据域**和**指针域**组成，指针域链接数据元素的直接前驱和/或直接后继。数据元素之间的逻辑关系是通过存储单元之间的链接关系反映的，物理上这组存储单元可以是相邻的，也可以是不相邻的。

索引存储结构除了建立存储单元信息外，还建立附加的索引表来标识存储单元的地址，如字典的目录。

散列存储结构根据数据元素的关键字直接计算出其存储地址。

> **注意**：同一逻辑结构可以对应多种存储结构。同样的运算，在不同的存储结构中，其实现过程是不同的。

**数据类型指一组性质相同的值的集合及定义在此集合上的一些操作的总称。** 类型用来说明变量或表达式的取值范围和所能进行的操作。按照取值的不同，数据类型可以分为两类：原子类型和结构类型。原子类型是不可以再分解的基本类型，包括整型、实型、字符型等。结构类型：由若干个类型组合而成，是可以再分解的。

**抽象指抽取出事物具有的普遍性的本质。** 抽象是一种思考问题的方式，它隐藏了繁杂的细节，只保留实现目标所必需的信息。

**抽象数据类型（Abstract Data Type，ADT）指一个数学模型及定义在该模型上的一组操作。** 一个抽象数据类型定义了：一个数据对象、数据对象中各数据元素之间的关系及对数据元素的操作。抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。“抽象”的意义在于数据类型的**数学抽象特性**。

抽象数据类型体现了程序设计中问题分解、抽象和信息隐藏的特性。抽象数据类型把实际生活中的问题分解为多个规模小且容易处理的问题，然后建立一个计算机能处理的数据模型，并把每个功能模块的实现细节作为一个独立的单元，从而使具体实现过程隐藏起来。

# 算法

**算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。** 算法是明确定义的可计算过程，以一个数据集合作为输入，并产生一个数据集合作为输出。一个算法通常具有以下五个特性：**输入、输出、有穷性、确定性和可行性**。

- 算法具有零个或多个输入。
- 算法至少有一个或多个输出。
- 算法执行的指令个数是有限的，每个指令又是在有限时间内完成的，因此整个算法也是在有限时间内可以结束的。
- 算法对于特定的合法输入，其对应的输出是唯一的。
- 算法是可行的，即算法中的每一条指令都是可以实现的，均能在有限的时间内完成。

算法设计应具有**正确性**，即算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案。算法正确性可分为四个层次：

1. 算法程序没有语法错误。
2. 算法程序对于合法的输入数据能够产生满足要求的输出结果。
3. 算法程序对于非法的输入数据能够得出满足规格说明的结果。
4. 算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果。

算法设计还需有**可读性**，便于理解、交流。算法设计同时应该具有**健壮性**，即当输入不合法时，也能做出相关处理而不产生异常或莫名其妙的结果。最后，好的算法应该具备**时间效率高和存储量低**的特点。

算法的优劣体现在运行算法时的计算机所需资源的多少上。计算机资源最重要的是时间和空间，因此使用时间复杂度和空间复杂度来衡量算法的优劣。时间复杂度是指执行算法所需要的计算工作量，空间复杂度是指执行算法所需要的内存空间。

## 算法时间效率度量

事后统计方法主要通过设计好的测试程序和数据用例，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。此法具有明显限制：

- 需要依据算法事先编制好程序，通过花费时间和精力，并且编制好的程序可能很糟糕。
- 计算机运行算法程序的效果会受到机器状态（CPU使用率、内存占用等）的影响。
- 算法测试用例设计困难，并且程序运行时间往往与测试用例的规模有很大关联。

事前分析估算方法是在编制算法程序前，依据统计方法对算法进行估算。

算法程序在计算机上运行所耗时间取决于下列因素，其中**算法的好坏和处理数据的规模决定了算法程序的运行时间**。

- 算法采用策略、方法。
- 编译产生的代码质量。
- 处理数据的规模：算法花费的时间与算法中语句执行的次数成正比。
- 机器执行指令的速度。

> 常数操作：和样本的数据量没有关系、每次都是固定时间内完成的操作。
> 时间频度：算法完成时，常数操作的次数。

***函数的渐近增长***：给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有n>N，f(n)总是大于g(n)，则f(n)的渐近增长快于g(n)。

> 如f(n) = 3n和g(n) = 2n，当n>2时，f(n)总是大于g(n)，因此f(n)的渐近增长快于g(n)。

在判断函数的渐近增长时，函数的主项（高阶项）常数、低阶项并不影响判断，因而往往可以忽略这些因素，而更关注主项的阶数。当然，在主项阶数相同时，主项常数、低阶项将称为影响函数渐近增长速度的主要因素。

| 次数 | 算法A: n | 算法B: n+2 | 算法C: 2n | 算法D: 2n^2^ | 算法E: 2n^2^+n+2 |
| ---- | ---- | ---- | ---- | ---- | ---- |
| n = 1 | 1 | 3 | 2 | 2 | 5 |
| n = 2 | 2 | 4 | 4 | 8 | 12 |
| n = 3 | 3 | 5 | 6 | 18 | 23 |
| n = 10 | 10 | 12 | 20 | 200 | 212 |
| n = 100 | 100 | 102 | 200 | 20000 | 20102 |
| n = 1000 | 1000 | 1002 | 2000 | 2000000 | 2001002 |

根据以上**在进行算法分析时，时间频度T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。** 算法的时间复杂度（Time Complexity），即算法的时间量度，记作：T(n) = O(f(n))（即**大O记法**，读作Big O）。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作**算法的渐近时间复杂度**。其中f(n)是问题规模n的某个函数。

> **注意**：渐近时间复杂度通常也被简称为时间复杂度，但实际上f(n)才是狭义上的时间复杂度。
> 大O记法也叫指渐近上界，表示该时间复杂度为上界（upper bound），可以理解为“最坏情况”的时间复杂度。近似复杂度。
> 此外，时间复杂度还有：
> - 紧界（大θ记法）：表示该时间复杂度既是上界（upper bound）也是下界（lower bound）。准确的复杂度。
> - 上确界（小o记法）：表示该时间复杂度为上确界（upper tight bound），可以理解为最坏情况的渐进时间复杂度，既最坏情况的时间复杂度也小于这个值。准确的复杂度。
> - 渐近下界（大Ω记法）：表示该时间复杂度为下界（lower bound），可以理解为“最好情况”的时间复杂度。近似复杂度。
> - 下确界（小w记法）：表示该时间复杂度为下确界（lower tight bound），可以理解为最好情况的渐进时间复杂度，既最好情况的时间复杂度也大于这个值。准确的复杂度。

在推导大O时间复杂度时，先计算算法程序中发生了多少常数操作并总结出常数操作数量的表达式，只取高阶项（不包含系数），不要低阶项；如果没有高阶项（即最高阶为0次），则为1。

评价一个算法程序的好坏，先看时间复杂度，然后再分析不同数据样本下实际的运行时间即常数项时间。**一般情况下，随着n的增大，T(n)增长最慢的算法为最优算法。**

常见的时间复杂度按效率从高到低有：

- O(1)：常数阶。
- O(logn)：对数阶。
> **注意**：在计算机相关中，对数函数在没有底数时默认底数为2，如lgn = logn = log~2~n。
- O(n)：线性阶。
- O(nlogn)：nlogn阶。
- O(n^2^)：平方阶。
- O(n^3^)：立方阶。
- O(2^n^)：指数阶。
- O(n!)：阶乘阶。

最好情况时间复杂度是指算法程序在最好情况下的运行时间复杂度。最坏情况时间复杂度是指算法程序在最坏情况下的运行时间复杂度。平均时间复杂度是指算法程序在所有情况下的平均运行时间复杂度。其中，**平均时间复杂度是最有意义的，因为它是期望的运行时间；最坏情况时间复杂度是算法程序运行时间的保证。**

## 算法空间占用度量

一般情况下，算法程序在机器上运行时，除了需要存储程序本身的指令、常数变量和输入数据，还需要存储对数据操作的存储单元。若输入数据所占空间只取决于问题本身，和算法无关，这样只需要分析该算法在实现时所需的辅助存储单元即可。

空间复杂度（Space Complexity）是算法在运行过程中临时占用空间大小的度量，一般也作问题规模n的函数，以数量级形式给出，记作S(n) = O(g(n))。

另外，在计算机科学中，一个**原地算法**（in-place algorithm）是一种使用小的、固定数量的额外空间来转换资料的算法，空间复杂度为O(1)。当算法执行时，输入的资料通常会被要输出的部分覆盖掉。不是原地算法有时候称为非原地（not-in-place）或不得其所（out-of-place）。