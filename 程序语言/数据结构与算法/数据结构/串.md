# 串

**串（String），又名字符串，是由零个或多个字符组成的有限序列。** 串一般记为s = "a~1~a~2~...a~n~" (n &gt;= 0)，其中s是串的名称，用双引号（或单引号）括起来的字符序列是串的值，引号不属于串的内容，ai (1 &lt;= i &lt;= n)可以是字母、数字或其他字符，i是该字符在串中的位置。串的字符数目n为串的长度，长度为零的串成为空串，用""或希腊字符Φ表示。

串中任意个数的连续字符组成的子序列成为该串的**子串**，相应地，包含字串的串成为**主串**。字串在主串中的位置就是字串的第一个字符在主串中的位置。

串的比较是通过组成串的字符之间的编码来进行的，而字符的编码即字符在对应字符集中的序号。

ASCII和Unicode是计算机中常用的字符编码。ASCII码由8位2进制数表示一个字符，总共可以表示256个字符。Unicode是国际标准字符集，满足跨语言、跨平台要求。

两个串的长度及各个位置对应的字符都相等时这两个串才相等，即s = "a~1~a~2~...a~n~"，t = "b~1~b~2~...b~n~"，当且仅当n = m，a~1~ = b~1~，a~2~ = b~2~，...，a~n~ = b~n~时，才有s = t。

两个串s = "a~1~a~2~...a~n~"，t = "b~1~b~2~...b~n~"比大小时，当满足下列条件之一时，s &lt; t：

- n &lt; m，且a~i~ = b~i~（1 &lt;= i &lt;= n）。
- 存在某个k &lt;= min(m, n)，使得a~i~ = b~i~（1 &lt;= i &lt;= k-1），a~k~ &lt; b~k~。

串更注重查找子串位置、得到指定字串、替换字串等操作。串的抽象数据类型定义：

``` csharp
ADT 串（Strint）
Data
    串元素都是字符，相邻元素具有前驱和后继关系。
Operation
    bool IsEmpty; // 若串为空则返回true，否则返回false。
    int Length; // 获取串的长度即元素个数。
    int Compare(string str); // 判断当前串与传入串的大小。
    string Concat(string s1, string s2); // 拼接两个串。
    string Substring(int pos, int len); // 获取指定位置指定长度的子串。
    int Index(string substring); // 获取子串位置。
    string Replace(string old, string new); // 将旧的字串替换为新的字串。
    string Insert(string str int pos); // 在指定位置插入串。
    string Delete(int pos, int len); // 删除指定位置指定长度的子串。
    string ToLower(); // 转小写。
    string ToUpper(); // 转大写。
endADT
```

# 模式匹配

子串的定位操作通过称为串的模式匹配，是串中最重要的操作之一。

对于主串S = "goodgoogle"，找到子串T = "google"在S中的位置。

## 朴素的模式匹配算法

对字串S依次遍历每个字符，在每次遍历时，从该字符往后检查是否与子串匹配。

``` csharp
// 不存在返回-1
public static int Indexof(string s, string t)
{
    if (s == null || t == null || t.Length > s.Length)
        return -1;

    int n = s.Length, m = t.Length;
    for (int i = 0; i <= n - m; i++)
    {
        int j = 0;
        for (; j < m; j++)
        {
            if (s[j + i] != t[j])
                break;
        }
        if (j == m)
            return i;
    }
    return -1;
}
```

最好情况下，子串在主串开头，即一次匹配便成功，此时时间复杂度为O(m)。最差情况下，主串中每遍历一个字符都要全部遍历子串且在子串最后一个字符匹配失败，如S = "0000000001"，T = "00002"，此时时间复杂度为O((n-m+1)*m)。

## KMP模式匹配算法

为了避免重复遍历，D.E.Knuth、J.H.Morris和V.R.Pratt（其中Knuth和Pratt共同研究，Morris独立研究）研究出了克努特-莫里斯-普拉特算法，简称KMP算法。

对于主串S = "abcdefgab"（在KMP算法中也叫文本串），子串T = "abcdx"（在KMP算法中也叫模式串），按朴素匹配有：

1. S[0] = T[0]，S[1] = T[1]，S[2] = T[2]，S[3] = T[3]，S[4] != T[4]，匹配失败。
2. S[1] != T[0]，匹配失败。
3. S[2] != T[0]，匹配失败。
4. S[3] != T[0]，匹配失败。
5. S[4] != T[0]，匹配失败。

观察子串T，T[0]与其后任一字符都不相等，根据第1步有S[1] = T[1]，S[2] = T[2]，S[3] = T[3]，所以2、3、4步S[1]、S[2]、S[3]与T[0]的比较都是多余的。

对于主串S = "abcababc"，子串T = "abcabx"，按朴素匹配有：

1. S[0] = T[0]，S[1] = T[1]，S[2] = T[2]，S[3] = T[3]，S[4] = T[4]，S[5] != T[5]，匹配失败。
2. S[1] != T[0]，匹配失败。
3. S[2] != T[0]，匹配失败。
4. 1. S[3] = T[0]
   1. S[4] = T[1]
   2. S[5] != T[2]，匹配失败。

根据前述分析，2、3步是多余的。观察子串T，T[0] = T[3]，T[1] = T[4]，根据第1步中S[3] = T[3]，S[4] = T[4]，所以4.1、4.2步S[3]与T[0]、S[4]与T[1]的比较都是多余的。

以上，可以发现主串当前位置的索引在朴素模式匹配中是通过不断回溯来完成的，而这种回溯是不必要的；子串索引的变化则与主串无关，取决于子串的重复，因此将子串各个位置的索引变化定义为一个数组next，则next的长度等于子串的长度，有：next[j] =

1. 0，当j = 0时；
2. Max{k + 1 | 0&lt;k&lt;j，且"P~0~...P~k-1~" = "P~j-k~...P~j-1~"}当此集合不为空时；
3. 1，其他情况。

例1：T = "abcdex"。

|    j    | 012345 |
|   ---   |  ---   |
|    T    | abcdex |
| next[j] | 011111 |

1. 当j = 0时，next[0]为0；
2. 当j = 1时，j由0到j-1只有字符"a"，属于其他情况，next[1]为1；
3. 当j = 2时，j由0到j-1的子串为"ab"，不重复，属于其他情况，next[2]为1；
4. 当j = 3时，j由0到j-1的子串为"abc"，不重复，属于其他情况，next[3]为1；
5. 当j = 4时，j由0到j-1的子串为"abcd"，不重复，属于其他情况，next[4]为1；
6. 当j = 5时，j由0到j-1的子串为"abcde"，不重复，属于其他情况，next[5]为1。

例2：T = "ababaaaba"。

|    j    | 012345678 |
|   ---   |    ---    |
|    T    | ababaaaba |
| next[j] | 011234223 |

1. 当j = 0时，next[0]为0；
2. 当j = 1时，j由0到j-1只有字符"a"，属于其他情况，next[1]为1；
3. 当j = 2时，j由0到j-1的子串为"ab"，不重复，属于其他情况，next[2]为1；
4. 当j = 3时，j由0到j-1的子串为"aba"，前缀"a"与后缀"a"重复，此时k = 1，next[3]为2；
5. 当j = 4时，j由0到j-1的子串为"abab"，前缀"ab"与后缀"ab"重复，此时k = 2，next[4]为3；
6. 当j = 5时，j由0到j-1的子串为"ababa"，前缀"aba"与后缀"aba"重复，此时k = 3，next[5]为4；
7. 当j = 6时，j由0到j-1的子串为"ababaa"，前缀"a"与后缀"a"重复，此时k = 1，next[6]为2；
8. 当j = 7时，j由0到j-1的子串为"ababaaa"，前缀"a"与后缀"a"重复，此时k = 1，next[7]为2；
9. 当j = 8时，j由0到j-1的子串为"ababaaab"，前缀"ab"与后缀"ab"重复，此时k = 2，next[8]为3。

例3：T = "aaaaaab"。

|    j    | 0123456 |
|   ---   |   ---   |
|    T    | aaaaaab |
| next[j] | 0123456 |

1. 当j = 0时，next[0]为0；
2. 当j = 1时，j由0到j-1只有字符"a"，属于其他情况，next[1]为1；
3. 当j = 2时，j由0到j-1的子串为"aa"，前缀"a"与后缀"a"重复，此时k = 1，next[2]为2；
4. 当j = 3时，j由0到j-1的子串为"aaa"，前缀"aa"与后缀"aa"重复，此时k = 2，next[3]为3；
5. 当j = 4时，j由0到j-1的子串为"aaaa"，前缀"aaa"与后缀"aaa"重复，此时k = 3，next[4]为4；
6. 当j = 5时，j由0到j-1的子串为"aaaaa"，前缀"aaaa"与后缀"aaaa"重复，此时k = 4，next[5]为5；
7. 当j = 6时，j由0到j-1的子串为"aaaaaa"，前缀"aaaaa"与后缀"aaaaa"重复，此时k = 5，next[6]为6。