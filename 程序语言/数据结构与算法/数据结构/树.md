# 定义

树（Tree）是n（n &gt;= 0）个结点的有限集。n = 0时称空树。**在任一非空树中，有且仅有一个特定结点称为根结点（Root）。** 当n &gt; 1时，其余结点可分为m（m &gt; 0）个互不相交的有限集T~1~、T~2~、...、T~m~，其中每一个集合本身又是一棵树，并且称为根的子树（Subtree）。树的定义中也使用了树的概念。

树的结点包含一个数据元素及若干指向其子树的分支。**结点拥有的子树数称为结点的度（Degree）。度为0的结点称为叶结点（Leaf）或终端结点；度不为0的结点称为分支结点或非终端结点。除根结点外，分支结点也称内部结点。树的度是树内各结点的度的最大值。**

**结点的子树的根称为该结点的孩子（Child），相应地，该结点称为孩子的双亲（Parent）。同一个双亲的孩子之间互为兄弟（Sibling）。结点的祖先是从根到该结点所经分支上的所有结点。以某结点为根的子树中的任一结点都称为该结点的子孙。**

结点的**层次**（Level）是从根开始定义，根为第一层，根的孩子为第二层，依次类推。**双亲在同一层的结点互为堂兄弟。树中结点的最大层次称为树的深度（Depth）或高度。**

**如果将树中结点的各子树看成从左至右是有次序的、不能互换的，则称该树为有序树，否则称为无序树。**

森林（Forest）是m（m &gt; 0）课互补相交的树的集合。对树中的结点而言，其子树的集合即为森林。

栈的抽象数据类型定义：

``` csharp
ADT 树（Tree）
Data
    树由一个根结点和若干子树构成。树中结点具有相同的类型。
Operation
    bool IsEmpty; // 若树为空树则返回true，否则返回false。
    int Depth; // 获取树的深度。
    U Root; // 树的根节点。
    void Init(); // 初始化操作，建立一个空树。
    void Destroy(); // 若树存在则销毁之。
    void Clear(); // 将树置空。
    T GetNodeValue(U node); // 获取结点的值。
    void SetNodeValue(U node, T value); // 给结点赋值。
    U GetNodeParent(U child); // 获取结点的双亲。
    U GetNodeLeftChild(U node); // 获取结点的左孩子。
    U GetNodeRightChild(U node); // 获取结点的右孩子。
    void InsertChild(U parent, U child); // 在结点上插入孩子。
    void DeleteChild(U parent, U child); // 删除结点上的孩子。
endADT
```

# 树的存储结构

双亲表示法：以一组连续空间存储树的结点，则每个结点中都需要附设一个指针域指示其双亲结点的位置。根结点的指针域设为-1。为了方便查找结点的孩子，可以增设一个指示结点最左边孩子的指针域，即长子域。为了方便查找兄弟关系，可以增设一个右兄弟域。

多重链表表示法：每个结点是一个链表，有多个指针域，其中每个指针指向一棵子树的根结点。由于每个结点的度不同，如果让每个链表长度都为树的度（所有结点度的最大值）则会导致许多指针域浪费（尤其是结点度相差较大时），因此链表应设数据域、度域（存储当前结点的度）、指针域（指向当前结点的各孩子）。

孩子表示法：使用数组存储每个结点链表，结点链表中存储当前结点数据和孩子链表。可以快速查找某个结点的孩子和兄弟，但不方便查找结点的双亲。

双亲孩子表示法：在孩子表示法中的结点链表中增设一个指针域指示其双亲结点的位置即可。

孩子兄弟表示法：**对任意一棵树，其结点的第一个孩子若存在则唯一，其右兄弟若存在也唯一。** 因此，可以设置一个链表，有数据域和两个指针域，分别指向该结点的第一个孩子和右兄弟。**此表示法可以将一棵复杂的树转变为二叉树。**

# 二叉树

二叉树（Binary Tree）是n（n &gt;= 0）个结点的有限集。该集合或为空集（称空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。

二叉树的特点：

- 每个结点最多有两棵子树，所有二叉树中不存在度大于2的结点。
- 左子树和右子树是有顺序的，即使某结点只有一棵子树，也要区分其是左子树还是右子树。

二叉树具有五种基本形态：

- 空二叉树。
- 只有一个根结点。
- 根结点只有左子树。
- 根结点只有右子树。
- 根结点既有左子树也有右子树。

特殊二叉树：

- **斜树**：**所有结点都只有左/右子树的二叉树叫左/右斜树。斜树每层只有一个结点。结点个数与斜树深度相同。**
- **满二叉树**：所有分支结点都有左子树和右子树，并且所有叶子结点都在同一层的二叉树叫满二叉树。分支结点的度一定是2。同样深度的二叉树，满二叉树的结点最多，叶子结点最多。
- **完全二叉树**：对于一棵具有n个结点的二叉树按层序编号，如果编号i（1 &lg;= i &lg;=n）的结点与同样深度的满二叉树中编号为i的结点的位置完全相同，则此二叉树称为完全二叉树。**满二叉树是完全二叉树，完全二叉树不一定是满二叉树。叶子结点只能出现在最下两层。最下层的叶子一定集中在左部连续位置，倒数二层的叶子（若有）一定都在右部连续位置。对任一结点，若其右子树深度为j，则左子树深度必为j或j+1；若其右子树下的子孙最大层为l，在其左子树下的最大层必为l或l+1。**

二叉树的性质：

- **二叉树的第i层最多有2^i-1^个结点。**
- **共i层的二叉树最多有2^i^-1个结点。**
- 若二叉树的叶子结点数为n，度为2的结点数为m，则n = m+1。
- 具有n个结点的完全二叉树的深度为`Mathf.FloorToInt(logn) + 1`。
- 对一个有n个结点的完全二叉树的结点按层编号，对任一结点i（1 &lg;= i &lg;=n），都有：
- 1. 如果i = 1，则结点i是完全二叉树的根；如果i &gt; 1，则其双亲是结点`Mathf.FloorToInt(i/2)`。
- 2. 如果2i &gt; n，则结点i无左孩子（为叶子结点），否则左孩子是结点2i。
- 3. 如果2i+1 &gt; n，则结点i无右孩子，否则右孩子是结点2i+1。

二叉树的遍历（Traversing Binary Tree）是指从根结点出发，按照某种次序依次访问二叉树中所有结点，使每个结点被访问一次且仅被访问一次。

- **前序遍历：若二叉树为空，则返回，否则先访问根节点，然后前序遍历左子树，在前序遍历右子树。**
- **中序遍历：若二叉树为空，则返回，否则从根节点开始，中序遍历左子树，然后访问根结点，最后中序遍历右子树。**
- **后序遍历：若二叉树为空，则返回，否则从根节点开始，后序遍历左子树，然后后序遍历右子树，最后访问根结点。**
- **层序遍历：若二叉树为空，则返回，否则从根节点开始访问，从上而下逐层遍历，在同一层中自左向右逐个访问结点。**

**已知前序遍历序列和中序遍历序列或者后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。**

二叉树由于其特殊性，可以使用一维数组来存储，其中数组索引可以表示结点逻辑关系，不存在结点处可以置空。由于二叉树（尤其是斜树）的结点可能不存在，回导致存储空间浪费，通常顺序存储只用于完全二叉树。

使用链表存储二叉树时，由于二叉树最多只有两个孩子，所以设计为一个数据域和两个指针域，这样的链表叫二叉链表。如果有必要可以增设一个指向双亲的指针域，这样的链表可称作三叉链表。

## 线索二叉树

在使用二叉链表存储具有n个结点的二叉树时，共有2n个指针域，而n个结点的二叉树共有n-1个分支线数，即存在n+1个空指针域，严重浪费存储空间。另一方面，在对二叉树进行遍历后得到了遍历序列，可以得到任一结点的前驱和后继，因此，可以使用这些空指针域存储对应结点的某种遍历次序下的前驱后后继。这种指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树便称为线索二叉树（Threaded Binary Tree）。对二叉树以某种次序遍历使其变为线索二叉树的过程称作线索化。

为了确定二叉链表的指针域指向的是左/右孩子还是前驱/后继，需要增设两个标志位，如果标志位为`false`则指向孩子，如果标志位为`true`则指向前驱/后继。

遍历线索二叉树就等同于操作双向链表结构。为了更好的操作，可以在二叉树线索链表上添加一个头结点，并令其左孩子指针域指向二叉树的根结点，右孩子指针域指向遍历后的最后一个结点。此时，可以人遍历序列的第一个结点的左孩子指针和最后一个结点的右孩子指针指向头结点。此时，既可以从第一个结点起顺后继进行遍历，也可以从最后一个结点起顺前驱进行遍历。

# 树、森林与二叉树的转换

## 树转换为二叉树

将树转换为二叉树的步骤：

1. 加线：在所有兄弟结点之间加一条连线。
2. 去线：对树中每个结点，仅保留其与第一个孩子结点的连线，删除该结点与其他孩子结点之间的连线。
3. 调整层次。

这样转换的到的二叉树中，所有节点的左子树都是该节点的子孙，右子树的根结点是该节点的兄弟。

## 二叉树转换为树

将二叉树转换为树是树转换为二叉树的逆过程，步骤如下：

1. 加线：若某结点的左孩子存在，则将该左孩子的右孩子、该右孩子的右孩子、...都与该结点相连。
2. 去线：删除二叉树中所有结点与其右孩子之间的连线。
3. 调整层次。

## 二叉树转换为森林

如果一棵二叉树的根结点只有左孩子，则该二叉树不能转换为森林。如果有右孩子，则转换为森林的步骤如下：

1. 从根结点开始，若右孩子存在，则删除与后孩子的连续，再查看分离后的二叉树……直到所有二叉树根结点的右孩子连线都被删除为止。
2. 将每棵分离的二叉树转换为树即可。

## 树与森林的遍历

树的遍历：

- 先根遍历：先访问树的根结点，然后依次先根遍历每棵子树。
- 后根遍历：先依次后根遍历每棵子树，再访问根结点。

森林的遍历：

- 前序遍历：先访问第一棵树的根结点，然后再依次先根遍历每棵子树，再依次用同样的方式遍历剩余树构成的森林。
- 后序遍历：先访问第一棵树，后根遍历每棵子树，然后再访问根结点，再依次用同样的方式遍历剩余树构成的森林。

当使用二叉链表作为树的存储结构时，树的先根遍历和后根遍历完全可以用二叉树的前序遍历和中序遍历实现。

# 赫夫曼树

从树中一个结点到另一个结点之间的分支构成两个结点之间的路径。路径上的**分支（连线）数目**称作路径长度。树的路径长度就是从树根到每一结点的路径长度之和。

如果考虑到带权的结点，结点的带权路径长度为从该结点到树根之间的路径长度与结点上权的乘积。树的带权路径长度为树中所有叶子结点的带权路径长度之和。

假设有n个权值{w~1~，...，w~n~}，构造一棵有n个叶子结点的二叉树，则其中**带权路径长度WPL最小的二叉树则称作赫夫曼树**，也叫最优二叉树。

构造赫夫曼树的步骤为：

1. 根据给定的n个权值{w~1~，...，w~n~}构成n棵二叉树的集合F = {T~1~、...、T~n~}，其中每棵二叉树T~i~中只有一个带权为w~i~的根结点，其左右子树均为空。
2. 在F中选取两棵根结点的权值最小的树作为左右子树（权值较小的为左子树）构成一棵新的二叉树，且置新的二叉树根结点的权值为其左右子树上根结点的权值之和。
3. 在F中删除这两棵树，同时将新树加入F中。
4. 重复2、3步骤，直到F为空，得到的树便是赫夫曼树。

一般地，设需要编码的字符集为{d~1~，...，d~n~}，各字符在电文中出现的次数或频率集合为{w~1~，...，w~n~}，以{d~1~，...，d~n~}作为叶子结点，以{w~1~，...，w~n~}作为相应叶子结点权值构成一棵赫夫曼树。规定赫夫曼树的做分支代表0，右分支代表1，则从根结点到叶子结点所经过的路径分支组成的0和1序列便为该结点对应字符的编码，即赫夫曼编码。