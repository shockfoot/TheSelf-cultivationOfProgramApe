# 定义

图（Graph）是由顶点（Vertex）的有穷非空集合和顶点之间边的集合组成，通常表示为：G (V, E)，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。

> 注意：
> - 线性表中数据元素叫元素，树中数据元素叫结点，图中数据元素叫顶点。
> - 线性表和树可以为空，但图不允许没有顶点。
> - 图中任意两个顶点都可能有关系，顶点之间的逻辑关系用边表示。边集可空。

若顶点v~i~到v~j~之间的边没有方向，则称为无向边（Edge），用无序偶对(v~i~,v~j~)或(v~j~,v~i~)表示。如果图中任意两顶点之间的边都是无向边，则该图称为无向图（Undirected Graph）。

若顶点v~i~到v~j~之间的边有方向，则称为有向边，也称为弧（Arc），用有序偶对&lt;v~i~,v~j~&gt;表示，其中，v~i~称为弧尾（Tail），v~j~称为弧头（Head）。如果图中任意两顶点之间的边都是有向边，则该图称为有向图（Directed Graph）。

图中若不存在顶点到其自身的边，，且同一条边不重复出现，则称这样的图为简单图。

在无向图中，若任意两个顶点都存在边，则称该图为无向完全图。含有n个顶点的无向完全图有n(n-1)/2条边。在有向图中，若任意两个顶点都存在边，则称该图为有向完全图。含有n个顶点的有向完全图有n(n-1)条边。

有很少条边或弧的图称为稀疏图，反之称为稠密图。

有些图的边或弧具有权（Weight）。这些权可以表示从一个顶点到另一个顶点的距离或耗费。这种带权的图通常称为网（Network）。

假设有两个图G = (V, E)和G^'^ = (V^'^, E^'^)，如果V^'^被包含于V，E^'^被包含于E，则常G^'^为G的子图（Subgraph）。

## 图的顶点和边的关系

对于无向图G = (V, E)，如果边(v,v^'^)属于E，则称顶点v和v^'^互为邻接点（Adjacent），即v和v^'^相邻接。边(v,v^'^)依附（Incident）于顶点v和v^'^，或者说与v和v^'^相关联。顶点v的度（Degree）是和v相关联的边的数目，记作TD(v)。边数是各顶点度数和的一半。

对于有向图G = (V, E)，如果弧&lt;v,v^'^&gt;属于E，则称顶点v邻接到v^'^，顶点v^'^邻接自v。弧&lt;v,v^'^&gt;与顶点v和v^'^相关联。以顶点v为头的弧的数量称为v的入度（In Degree），记作ID(v)。以顶点v为尾的弧的数量称为v的出度（Out Degree），记作OD(v)。顶点v的度TD(v) = ID(v) + OD(v)。边数等于各顶点入度和，也等于各顶点的出度和。

无向图G = (V, E)中从顶点v到顶点v^'^的路径（Path）是一个顶点序列(v=v~i,0~,...,v~i,m~=v^'^)，其中(v~i,j-1~,v~i,j~)属于E，1 &lt;= j &lt;= m。

如果G是有向图，则路径也是有向的。顶点序列应满足&lt;v~i,j-1~,v~i,j~&gt;属于E，1 &lt;= j &lt;= m。

树中根结点到任意结点的路径是唯一的，但图中顶点与顶点之间的路径却不唯一。

路径的长度是路径上边或弧的数目。

序列中顶点不重复出现的路径称为简单路径。第一个顶点到最后一个顶点相同的路径称为回路或环（Cycle）。除第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路称为简单回路或简单环。

在无向图G中，如果从顶点v到v^'^有路径，则称v和v^'^是连通的。如果对于任意两个顶点都是连通的则称为连通图（Connected Graph）。无向图中的极大连通子图称为连通分量。

在有向图G中，如果每一对顶点v到v^'^，从v到v^'^和从v^'^到v有路径，则称G是强连通图。有向图中的极大强连通子图称为强连通分量。

连通图的生成树是一个极小的连通子图，它含有图中全部的n个顶点，但只有足以构成一个树的n-1条边。因此，一个图有n个顶点，如果该图有小于n-1条边，则它是非连通图；如果多余n-1条边，必定存在环；如果有n-1条边则不一定是生成树。

如果一个有向图恰有一个顶点的入度为0，其余顶点的入读为1，则是一棵有向树。一个有向图的生成森林由若干有向树组成，含图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。

``` csharp
ADT 图（Graph）
Data
    顶点的有穷非空集合和边的集合。
Operation
    bool IsEmpty; // 若栈为空则返回true，否则返回false。
    int Count; // 获取栈的长度即元素个数。
    void Init(); // 初始化操作，构造图。
    void Destroy(); // 销毁图。
    int LacateVertex(U vertex); // 获取顶点在图中的位置。
    T GetVertexValue(U vertex); // 获取顶点的值。
    void SetVertexValue(U vertex); // 设置顶点的值。
    U FirstAdjacentVertex(U vertex); // 获取顶点的邻接顶点。
    U NextAdjacentVertex(U vertex, U adjVertex); // 获取顶点vertex相对于adjVertex的下一个邻接顶点。
    void InsetVertex(U new); // 添加新顶点。
    void DeleteVertex(U old); // 删除顶点。
    void InsetArc(U out, U in); // 添加新弧，如果是无向图，需要添加对称弧。
    void DeleteArc(U out, U in); // 删除弧。如果是无向图，需要删除对称弧。
endADT
```

# 图的存储结构

由于图的结构比较复杂，任意两顶点之间都可能存在联系，因此无法以数据元素在内存中的物理位置来表示元素之间的关系，即不可能用简单的顺序存储结构来表示。而使用多重链表，如果各顶点度数相差较大，按度数最大的顶点设计结点结构会造成存储单元浪费，而若按每个顶点自己的度数设计不同的顶点结构，又会带来操作的不变。

## 邻接矩阵

考虑到图是有顶点和边或弧两部分组成，其中顶点不分大小、主次，可以使用一维数组存储，而边或弧由于是顶点与顶点之间的关系，可以使用二维数组（邻接矩阵，Adjacency Matrix）存储。

设G有n个顶点，则邻接矩阵是一个nXn的方阵，定义为arc[i][j] = 1（当(v~i~,v~j~)或&lt;v~i~,v~j~&gt;属于E时）或0（反之）。无向图的邻接矩阵是对称矩阵。无向图中顶点的度等于邻接矩阵中顶点所在列或行中值的和。有向图中顶点的入度等于邻接矩阵中顶点所在列中值的和，出度等于邻接矩阵中顶点所在行中值的和。

对于网，邻接矩阵中每个值可以存边或弧的权值，不存在的边或弧的权值需要用一个不可能的值代表。

邻接矩阵适合存储稠密图，对于稀疏图，大部分边或弧不存在，则浪费存储空间。

## 邻接表

为了避免邻接矩阵中存储空间的浪费，使用数组加链表的方式存储图，即邻接表（Adjacency List）。其中，一维数组存储顶点，每个元素还要额外存储指向第一个邻接点的指针域以便查找该顶点的边信息。图中每个顶点的邻接点使用链表存储。对于无向图，该链表称为顶点的边表；对于有向图，该链表称为顶点作为弧尾的出边表。

有时为了方便确定有向图中顶点的入度或以顶点为弧头的弧，可以建立有向图的逆邻接表，即对每个顶点都建立一个以该顶点为弧头的表。

对于网，可以在边表结点中增设一个权值的数据域即可。

## 十字链表

对于有向图来说，邻接表无法将入度和出度整合起来。因此重新定义邻接表中顶点表结点结构为数据域、入边表头指针（指向该顶点入边表中第一个结点）、出边表头指针（指向该顶点出边表中第一个结点）。

重新定义邻接表中边表结点结构为弧起点在顶点表中的下标、弧终点在顶点表中的下标、入边表指针域（指向终点相同的下一条边）、出边表指针域（指向起点相同的下一条边）。如果是网，可以在增设一个权值数据域。

十字链表将邻接表和逆邻接表整合，即方法查找以指定顶点为头的弧，也方便查找以指定顶点为尾的弧，因为易求得顶点的入度和出度。

## 邻接多重表

对于无向图的邻接表，如果更关注边的操作，如对删除边等，需要找到这条边的两个顶点的边表进行操作。因此重新定义边表结点结构为某条边依附的两个顶点在顶点表中的下标ivex和jvex、ilink指向依附顶点ivex的下一条边、jlin指向依附顶点jvex的下一条边。需要注意的是，顶点表中要连接ivex相同的边，ilink连接的下一条边的jvex要和它本身的ivex相同，jlink连接的下一条边的ivex要和它本身的jvex相同。

可以发现，邻接表中一条边有两个结点，而邻接多重表中一条边只有一个结点，操作边就方便多了。

## 边集数组

边集数组由两个数组组成，一个存储顶点的信息，一个存储边的信息。边数组每个数据元素包含一条边的起点下标（Begin）、终点下标（End）和权。

显然，在边集数组中查找一个顶点的度需要遍历整个边数组，因此边集数组关注的是边的集合，更适合对边依次进行处理操作。