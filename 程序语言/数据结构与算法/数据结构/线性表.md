# 定义

**线性表（List）指零个或多个数据元素的有限序列。**，数据元素是**有序**的。如果有多个数据元素，则第一个元素无先驱，最后一个元素无后继，其他每个元素都有且只有一个前驱和后继。另外，线性表强调是**有限**的。

用数学语言描述即：若将线性表记为（a~1~, ..., a~i-1~, a~i~, a~i+1~, ..., a~n~），则表中a~i-1~领先于a~i~，a~i~领先于a~i+1~，称a~i-1~是a~i~的直接前驱元素，a~i+1~是a~i~的直接后继元素。当i = 1, 2, ..., n-1时，a~i~有且仅有一个直接后继；当i = 2, 3, ..., n时，a~i~有且仅有一个直接前驱。

**线性表元素的个数n（n ≥ 0）定义为线性表的长度。** 当n = 0时，称为空表。

线性表的抽象数据类型定义：

``` csharp
ADT 线性表（List）
Data
    线性表的数据集合为（a1, a2, ..., an），每个元素的类型均为DataType。其中，除第一个元素ai外，每个元素有且仅有一个直接前驱元素；除最后一个元素an外，每个元素有且仅有一个直接后继元素。数据元素之间的关系是一对一的。
Operation
    bool IsEmpty; // 若线性表为空则返回true，否则返回false。
    int Count; // 获取线性表的长度即元素个数。
    void Init(); // 初始化操作，建立一个空的线性表。
    void Clear(); // 将线性表置空。
    T Get(int i); // 获取线性表第i个位置的元素。
    bool Contains(T element); // 判断线性表中是否存在给定元素。
    void InsertAt(int i, T element); // 在线性表的指定位置插入指定元素。
    void DeleteAt(int i); // 删除线性表中指定位置的元素。
endADT
```

# 线性表的顺序存储结构

线性表的顺序存储结构指用一段地址连续的存储单元依次存储线性表的数据元素，通常使用一维数组实现。

顺序存储的线性表需要三个重要属性：

- 存储空间的起始位置：数组地址。
- 最大存储容量：数组长度。
- 当前长度：实际已存储的元素数量。

在任意时刻，线性表的长度小于等于最大存储容量。

在访问数据元素时， 由于数组存储了第一个元素的地址，即首地址。因此，每个元素的地址为（LOC表示获取存储位置的函数）：`LOC(ai) = LOC(a0) + i * c`，其中c为其元素类型所占用内存大小。该访问操作所需时间复杂度为O(1)。

> 计算机中元素索引总是从0开始的，这样为了方便数组的地址计算，否则就是`LOC(ai) = LOC(a1) + (i - 1) * c`了。

> 通常把具有时间复杂度为O(1)的查找元素操作的存储结构称为**随机存取结构**。

插入元素操作：

1. 插入位置不合理则抛出异常；
2. 线性表长度达到最大容量则抛出异常或动态增加容量；
3. 从最后一个元素开始向前遍历到第i个位置，并将每个元素往后移动一个位置；
4. 在i处插入指定的元素；
5. 表长加1。

删除元素操作：

1. 删除位置不合理则抛出异常；
2. 在i处删除指定的元素；
3. 从i处开始向后遍历到最后一个元素，并将每个元素往前移动一个位置；
4. 表长减1。

最好情况下，在最后一个位置插入和删除元素时不需要移动其余元素，时间复杂度为O(1)。最坏情况下，在第一个位置插入和删除元素时需要移动所有元素，时间复杂度为O(n)。平均情况下的移动次数和最中间元素的移动次数相同，即(n-1)/2，所以平均时间复杂度为O(n)。

顺序存储结构的线性表无须为表示元素之间的逻辑关系而额外增加存储空间，可以快速的存取任一位置的元素；但插入和删除需要移动大量元素，当其长度不定时难以确定存储容量，容易造成存储空间碎片。以上说明顺序存储结构的线性表更适合于元素不太变化、经常进行读取的操作。

# 线性表的链式存储结构

线性表的链式存储结构是用一组任意存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。

在链式结构中，除了要存储数据元素的数据项之外，还需要存储直接后继元素的地址。

> 通常把存储数据元素数据项的域称为**数据域**，把存储直接前驱/后继元素位置的域称为**指针域**。这两部分信息组成数据元素的存储映像，称为**结点**（Node）。

n个结点链接而成的线性表也叫**链表**。如果每个结点中只包含一个指针域（后继元素的位置），则称为**单链表**；如果同时包含前驱和后继元素位置则称为**双链表**。

对于线性表来说，**第一个结点的位置被称为头指针**；**最后一个结点的指针域为空**。有时为了方便对链表进行操作，会在单链表的第一个结点前附设一个**头结点**，其指向第一结点。头结点可以不存储任何信息，也可以存储线性表的附加信息（如长度等）。

头指针和头结点：

- 头指针是指向链表第一个结点的指针，若链表有头结点，则指向头结点。
- 头指针具有标识作用，常用头指针冠以链表的名字。
- 无论链表是否为空，头指针都不为空。头指针是链表的必要元素。
- 头结点是为了操作的统一和方便（增加和删除第一结点）而设立的，其数据域一般无意义。
- 头结点不是链表的必须要素。

访问链式存储结构的线性表时，因为每个元素的地址没有规律，所以只能从头依次遍历每个元素才能获取指定元素。因此，最坏时间复杂度为O(n)，最好时间复杂度为O(1)，平均时间复杂度为O(n)。

插入和删除操作时：

1. 先遍历，获取指定位置的元素；
2. 进行修改指针域。

最坏时间复杂度为O(n)，最好时间复杂度为O(1)，平均时间复杂度为O(n)。

与顺序存储结构的线性表相比，在增加/删除多个数据时，链表只需O(n)时间查找，而核心的增/删操作时间复杂度都是O(1)。因此，频繁进行增删操作尤其是增删大批量数据元素时宜采用链式存储结构。

创建链表时可以采用**头插法**和**尾插法**。

删除链表时要**释放每个结点**。

# 静态链表

对于没有指针或引用机制的语言，如Basic、Fortran等，可以使用数组实现单链表，即**静态链**。

让数组的元素都是由两个数据域组成的，即每个下标都对应一个data数据域和cur数据域，其中data数据域用来存放数据元素，游标cur数据域即单链表的next指针，存放后继元素在数组中的下标，所以这种方法也叫**游标实现法**。

通常，上述数组的第一个和最后一个元素作为特殊元素，不存放数据。为了模拟动态链表的存储空间的分配，即辨明数组中哪些位置未被使用，需要将未被使用及已被清除的位置链接成**备用链表**，在分配或释放操作时，从备用链表获取需要的信息即可。数组第一个元素用于存放备用链表的第一个结点的下标；最后一个元素则存放第一个有值元素的下标，相当于头结点的作用。

初始化时，数组中每个元素的cur指向后一个元素的下标，最后一个元素的cur为0，即指向备用链表，表面未存储任何元素。

添加/插入元素时，获取备用链表的头结点（即第一个元素的cur），并将该下标位置的cur存储到第一个元素的cur。在该位置存储该元素后，找到cur为指定添加/插入下标的元素，将其cur修改为实际存储的位置，并将其原来指向的下一位置交给新的元素。

删除时，将空出来的位置作为备用链表的头结点，即将该位置的下标记录在第一个元素的cur，将第一个元素原来的cur交给该位置。修改被删除元素的前驱的cur（如果是头则修改最后一个元素的cur即可）。

``` csharp
/// <summary>
/// 固定容量的泛型静态链表
/// </summary>
public class StaticLinkedList<T>
{
    /// <summary>
    /// 泛型静态链表结点
    /// </summary>
    public class StaticLinkedListNode<U>
    {
        /// <summary>
        /// 数据域
        /// </summary>
        public U Data;
        /// <summary>
        /// 后继
        /// </summary>
        internal int Cursor;

        /// <summary>
        /// 构造结点
        /// </summary>
        public StaticLinkedListNode()
        {
            Set(default, 0);
        }

        /// <summary>
        /// 构造结点
        /// </summary>
        /// <param name="data">数据</param>
        /// <param name="cursor">后继</param>
        public StaticLinkedListNode(U data, int cursor)
        {
            Set(data, cursor);
        }

        /// <summary>
        /// 设置结点
        /// </summary>
        /// <param name="data">数据</param>
        /// <param name="cursor">后继</param>
        public void Set(U data, int cursor)
        {
            SetData(data);
            SetCursor(cursor);
        }

        /// <summary>
        /// 设置结点数据
        /// </summary>
        /// <param name="data">数据</param>
        public void SetData(U data)
        {
            Data = data;
        }

        /// <summary>
        /// 设置结点后继
        /// </summary>
        /// <param name="cursor">后继</param>
        public void SetCursor(int cursor)
        {
            Cursor = cursor;
        }

        /// <summary>
        /// 重置结点
        /// </summary>
        /// <param name="cursor">后继</param>
        public void Reset(int cursor)
        {
            Set(default, cursor);
        }
    }

    #region 字段

    /// <summary>
    /// 默认容量
    /// </summary>
    private int defaultCapacty = 32;

    private int capacity;
    private int count;
    // 第一个元素是备用链表的头结点，最后一个元素是已用链表的头结点（空时为0）
    private StaticLinkedListNode<T>[] array;

    #endregion

    #region 属性

    /// <summary>
    /// 容量
    /// </summary>
    public int Capacity { get { return capacity; } }

    /// <summary>
    /// 元素个数
    /// </summary>
    public int Count { get { return count; } }

    /// <summary>
    /// 是否为空
    /// </summary>
    public bool IsEmpty { get { return count == 0; } }

    #endregion

    #region 构造

    /// <summary>
    /// 构造默认容量的静态链表
    /// </summary>
    public StaticLinkedList()
    {
        Init(defaultCapacty);
    }

    /// <summary>
    /// 构造指定容量的静态链表
    /// </summary>
    /// <param name="capacity">容量</param>
    public StaticLinkedList(int capacity)
    {
        if (capacity <= 0)
        {
            throw new ArgumentException($"不合法的容量：{capacity}！");
        }
        Init(capacity);
    }

    #endregion

    #region 私有

    /// <summary>
    /// 初始化
    /// </summary>
    /// <param name="capacity">容量</param>
    private void Init(int capacity)
    {
        this.capacity = capacity;
        count = 0;
        array = new StaticLinkedListNode<T>[capacity];
        array[0] = new StaticLinkedListNode<T>(default, 1);
        int num = capacity - 2;
        for (int i = 1; i < num; i++)
        {
            array[i] = new StaticLinkedListNode<T>(default, i + 1);
        }
        array[num] = new StaticLinkedListNode<T>(default, 0);
        array[capacity - 1] = new StaticLinkedListNode<T>(default, 0);
    }

    /// <summary>
    /// 从备用链表中获取一个可用结点
    /// </summary>
    private int Malloc()
    {
        int i = array[0].Cursor;
        if (i == 0)
        {
            throw new Exception("无剩余空间可供分配！");
        }
        count++;
        if (count == capacity - 2)
        {
            array[0].Cursor = 0;
        }
        else
        {
            array[0].Cursor = array[i].Cursor;
            if (count == 1)
            {
                array[capacity - 1].Cursor = i;
            }
        }
        return i;
    }

    /// <summary>
    /// 释放一个已用结点到备用链表
    /// </summary>
    private void Free(int index)
    {
        array[index].Data = default;
        array[index].Cursor = array[0].Cursor;
        array[0].Cursor = index;
        count--;
    }

    #endregion

    #region API

    /// <summary>
    /// 添加一个结点
    /// </summary>
    public void Add(T value)
    {
        int addIndex = Malloc();
        array[addIndex].Data = value;
        array[addIndex].Cursor = 0;
        if (count == 1)
        {
            return;
        }
        int behandAddIndex = capacity - 1;
        while (array[behandAddIndex].Cursor != 0)
        {
            behandAddIndex = array[behandAddIndex].Cursor;
        }
        array[behandAddIndex].Cursor = addIndex;
    }

    /// <summary>
    /// 插入一个结点
    /// </summary>
    public void Insert(T value, int index)
    {
        if (index < 1 || index > capacity - 2)
        {
            throw new ArgumentOutOfRangeException();
        }
        int insertIndex = Malloc();
        array[insertIndex].Data = value;
        int behandInsetIndex = capacity - 1;
        for (int i = 1; i < insertIndex - 1; i++)
        {
            behandInsetIndex = array[behandInsetIndex].Cursor;
        }
        array[insertIndex].Cursor = array[behandInsetIndex].Cursor;
        array[behandInsetIndex].Cursor = insertIndex;
    }

    /// <summary>
    /// 移除一个结点
    /// </summary>
    /// <param name="index">索引</param>
    public void Remove(int index)
    {
        if (index < 1 || index > capacity - 2)
        {
            throw new ArgumentOutOfRangeException();
        }
        int behandRemoveIndex = capacity - 1;
        for (int i = 1; i < index - 1; i++)
        {
            behandRemoveIndex = array[behandRemoveIndex].Cursor;
        }
        array[behandRemoveIndex].Cursor = array[index].Cursor;
        Free(index);
    }

    /// <summary>
    /// 清空
    /// </summary>
    public void Clear()
    {
        array[0].Reset(1);
        int num = capacity - 2;
        for (int i = 1; i < num; i++)
        {
            array[i].Reset(i + 1);
        }
        array[num].Reset(0);
        array[capacity - 1].Reset(0);
        count = 0;
    }

    #endregion
}
```

# 其他链表

末尾结点的next指向头结点的单链表即单**循环链表**。**循环链表可以从任一结点访问到链表的全部结点。**

结点可以同时指向前驱和后驱的链表即为**双向链表**。双向链表也可以是循环链表。双向链表可以反向查询结点，但在插入和删除时需要更改两个指针变量。