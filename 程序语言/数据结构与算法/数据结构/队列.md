# 定义

**队列（Queue）是限定仅在一端进行插入，而在另一端进行删除操作的的数据结构。** 允许插入的一端称为队尾（Tail），允许删除的一端称为队头（Head）。**队列是先进先出（First In First Out）的线性表，简称FIFO结构。** 队列元素也具有线性关系。

队列的抽象数据类型定义：

``` csharp
ADT 队列（Queue）
Data
    同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。
Operation
    bool IsEmpty; // 若队列为空则返回true，否则返回false。
    int Count; // 获取队列的长度即元素个数。
    void Init(); // 初始化操作，建立一个空队列。
    void Destroy(); // 若队列存在则销毁之。
    void Clear(); // 将队列置空。
    T GetHead(); // 获取队头元素。
    T Dequeue(); // 获取并从队列中删除队头元素。
    void Enqueue(T element); // 将新元素添加到队尾。
endADT
```

# 队列的顺序存储结构

顺序存储结构的队列可以使用数组实现。下标为0的一端为队头。入队操作之间在队尾追加元素，不需要移动任何元素，时间复杂度为O(1)；出队操作是在下标为0的位置，因此所有元素需要向前移动，时间复杂度为O(n)。

为了避免出队时移动所有元素，可以使用一个头指针记录队头。然而，随着出队和入队的操作，头指针和尾指针不断后移，会导致添加新元素时数组已满的问题，尽管数据头部可能还有空闲（**假溢出**）。

为了充分使用数组头部的空闲位置，队列的尾指针可以超过数组长度，指向数组的头部，即**循环队列**。循环队列需要注意满和空两种状态的判断。

# 队列的链式存储结构

链队列可以通过单链表实现。队头指针指向链队列头结点，队尾指针指向尾结点；空队列时都指向头结点。

对比循环队列和链队列，入队和出队操作的时间复杂度都是O(1)，但循环队列不需要申请和释放内存，但可能造成空间浪费；链队列需要额外空间存储指针域，并在申请和删除时花费额外开销。因此，对于固定数量、频繁增删的队列可以使用循环队列。

# 数组实现循环队列

``` csharp
/// <summary>
/// 固定容量的循环队列
/// </summary>
public class RoundRobinQueue<T>
{
    #region 字段

    /// <summary>
    /// 默认容量
    /// </summary>
    private int defaultCapacity = 32;
    private int capacity;

    private T[] array;

    private int headIndex;
    private int tailIndex;

    #endregion

    #region 属性

    /// <summary>
    /// 容量
    /// </summary>
    public int Capacity { get { return capacity; } }

    /// <summary>
    /// 元素个数
    /// </summary>
    public int Count { get { return (tailIndex - headIndex + capacity) % capacity; } }

    /// <summary>
    /// 是否为满队列
    /// </summary>
    public bool IsFull { get { return (tailIndex + 1) % capacity == headIndex; } }

    /// <summary>
    /// 是否为空队列
    /// </summary>
    public bool IsEmpty { get { return Count == 0; } }

    #endregion

    #region 构造

    /// <summary>
    /// 构造默认容量的循环队列
    /// </summary>
    public RoundRobinQueue()
    {
        Init(defaultCapacity);
    }

    /// <summary>
    /// 构造指定容量的循环队列
    /// </summary>
    /// <param name="capacity">容量</param>
    public RoundRobinQueue(int capacity)
    {
        if (capacity <= 0)
        {
            throw new ArgumentException($"不合法的容量：{capacity}！");
        }
        Init(capacity);
    }

    #endregion

    #region 私有

    /// <summary>
    /// 初始化
    /// </summary>
    /// <param name="capacity">容量</param>
    private void Init(int capacity)
    {
        this.capacity = capacity;
        array = new T[capacity];
        headIndex = 0;
        tailIndex = 0;
    }

    #endregion

    #region API

    /// <summary>
    /// 入队
    /// </summary>
    /// <param name="element">入队元素</param>
    public void Enqueue(T element)
    {
        if (IsFull)
        {
            throw new Exception("无剩余空间可供分配！");
        }
        array[tailIndex] = element;
        tailIndex = (tailIndex + 1) % capacity;
    }

    /// <summary>
    /// 出队
    /// </summary>
    public T Dequeue()
    {
        if (IsEmpty)
        {
            throw new Exception("空！");
        }
        T element = array[headIndex];
        array[headIndex] = default(T);
        headIndex = (headIndex + 1) % capacity;
        return element;
    }

    /// <summary>
    /// 清空
    /// </summary>
    public void Clear()
    {
        while (!IsEmpty)
        {
            Dequeue();
        }
        headIndex = 0;
        tailIndex = 0;
    }

    #endregion
}
```