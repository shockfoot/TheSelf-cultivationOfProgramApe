# 定义

**栈（Stack）是限定仅在表尾进行插入和删除操作的的数据结构。** 允许插入和删除的一端称为栈顶（Top），另一端称为栈底（Bottom）。不含任何数据元素的栈称为**空栈**。**栈又称为后进先出（Last In First Out）线性表，简称LIFO结构。** 栈元素具有线性关系，即前驱后继关系。

栈的插入操作叫做进栈，也称压栈、入栈。栈的删除操作叫出栈，也称弹栈。

栈的抽象数据类型定义：

``` csharp
ADT 栈（Stack）
Data
    同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。
Operation
    bool IsEmpty; // 若栈为空则返回true，否则返回false。
    int Count; // 获取栈的长度即元素个数。
    void Init(); // 初始化操作，建立一个空栈。
    void Destroy(); // 若栈存在则销毁之。
    void Clear(); // 将栈置空。
    T Peek(); // 获取栈顶元素。
    T Pop(); // 获取并从栈中删除栈顶元素。
    void Push(T element); // 将新元素压入栈顶。
endADT
```

栈的入栈和出栈操作的时间复杂度都是O(1)。

# 栈的顺序存储结构

顺序存储结构的栈，即**顺序栈**，可以使用数组实现。此时，因为操作首元素的代价最大，通常使用下标为0的一端作为栈底，并定义一个top游标指示栈顶位置。空栈时，top游标指在-1处。

对于两个相同类型的栈，可以使用一个数组实现两个栈，此时两栈共享一个数组空间。此时，数组的头部和尾部分别作为两个栈的栈底，使用两个游标分别指示两个栈的栈顶位置。事实上，在使用此数据结构时，通常是两个栈的空间需求有相反的关系，即一个栈增长时另一个栈在缩短，否则容易由于两个栈都在增长而溢出。

# 栈的链式存储结构

链式存储结构的栈被称为**链栈**。链栈的栈顶通常是链表的头部，且不需要头结点。

顺序栈由于提前申请了固定大小的内存，可能导致内存空间浪费或者不够的问题，但顺序栈存取定位很方便。链栈的每个结点都有指针域，也增加了内存开销，但其尺寸可以动态扩展。

# 栈的应用

## 递归

实现递归的重要技术即是**函数的调用堆栈**。在前行阶段，将每一层递归的数据都压入栈中；在回退阶段，弹出栈顶的最近一次递归数据，恢复调用。

## 四则运算表达式求值

使用栈可以求取**后缀表达法（逆波兰）**表示的四则运算表达式的值。

对于表达式`9 + (3 - 1) * 3 + 10 / 2`（也叫**中缀表达式**，即运算符在两运算数字之间），可以使用`9 3 1 - 3 * + 10 2 / + `的后缀表达式（符号出现在运算数字之后）表示。此时，使用栈对后缀表达式求值：**遇到数字即入栈，遇到运算符即取出栈顶两个数字运算。**

**将中缀表达式转化为后缀表达式也要使用栈**，转换规则为：从左到右遍历中缀表达式，遇到数字则输出，遇到运算符则判断其与栈顶运算符的优先级，如果是右括号或优先级低于栈顶运算符的则栈顶元素依次出栈并输出，当前符号入栈，一直到遍历结束。

# 数组实现栈

数组实现固定容量的泛型栈：

``` csharp
/// <summary>
/// 固定容量的泛型栈
/// </summary>
public class Stack<T>
{
    #region 字段

    /// <summary>
    /// 默认容量
    /// </summary>
    private int defaultCapacity = 32;
    private int capacity;

    private T[] array;
    private int topIndex;

    #endregion

    #region 属性

    /// <summary>
    /// 容量
    /// </summary>
    public int Capacity { get { return capacity; } }

    /// <summary>
    /// 元素个数
    /// </summary>
    public int Count { get { return topIndex + 1; } }

    /// <summary>
    /// 是否为空栈
    /// </summary>
    public bool IsEmpty { get { return topIndex == -1; } }

    #endregion

    #region 构造

    /// <summary>
    /// 构造默认容量的栈
    /// </summary>
    public Stack()
    {
        Init(defaultCapacity);
    }

    /// <summary>
    /// 构造指定容量的栈
    /// </summary>
    /// <param name="capacity">容量</param>
    public Stack(int capacity)
    {
        if (capacity <= 0)
        {
            throw new ArgumentException($"不合法的容量：{capacity}！");
        }
        Init(capacity);
    }

    #endregion

    #region 私有

    /// <summary>
    /// 初始化
    /// </summary>
    /// <param name="capacity">容量</param>
    private void Init(int capacity)
    {
        array = new T[capacity];
        this.capacity = capacity;
        topIndex = -1;
    }

    #endregion

    #region API

    /// <summary>
    /// 压栈
    /// </summary>
    public void Push(T element)
    {
        if (count == capacity)
        {
            throw new Exception("无剩余空间可供分配！");
        }
        topIndex++;
        array[topIndex] = element;
    }

    /// <summary>
    /// 弹栈
    /// </summary>
    public T Pop()
    {
        if (topIndex == -1)
        {
            throw new Exception("空栈！");
        }
        T element = array[topIndex];
        array[topIndex] = default(T);
        topIndex--;
        return element;
    }

    /// <summary>
    /// 获取栈顶元素
    /// </summary>
    public T Peek()
    {
        if (topIndex == -1)
        {
            throw new Exception("空栈！");
        }
        return array[topIndex];
    }

    /// <summary>
    /// 清空
    /// </summary>
    public void Clear()
    {
        while (topIndex != -1)
        {
            Pop();
        }
    }

    #endregion
}
```

数组实现固定容量的双端泛型栈：

``` csharp
/// <summary>
/// 固定容量的双端泛型栈
/// </summary>
public class DoubleStack<T>
{
    /// <summary>
    /// 左右栈枚举标记
    /// </summary>
    public enum EStack
    {
        /// <summary>
        /// 左栈
        /// </summary>
        LeftStack,
        /// <summary>
        /// 右栈
        /// </summary>
        RightStack
    }

    #region 字段

    /// <summary>
    /// 默认容量
    /// </summary>
    private int defaultCapacity = 32;
    private int capacity;

    private T[] array;
    private int leftIndex;
    private int rightIndex;

    #endregion

    #region 属性

    /// <summary>
    /// 容量
    /// </summary>
    public int Capacity { get { return capacity; } }

    /// <summary>
    /// 元素个数
    /// </summary>
    public int Count { get { return LeftCount + RightCount; } }

    /// <summary>
    /// 左栈元素个数
    /// </summary>
    public int LeftCount { get { return leftIndex + 1; } }

    /// <summary>
    /// 右栈元素个数
    /// </summary>
    public int RightCount { get { return capacity - rightIndex; } }

    /// <summary>
    /// 是否为空栈
    /// </summary>
    public bool IsEmpty { get { return Count == 0; } }

    /// <summary>
    /// 左栈是否为空栈
    /// </summary>
    public bool IsLeftEmpty { get { return leftIndex == -1; } }

    /// <summary>
    /// 右栈是否为空栈
    /// </summary>
    public bool IsRightEmpty { get { return rightIndex == capacity; } }

    #endregion

    #region 构造

    /// <summary>
    /// 构造默认容量的双端栈
    /// </summary>
    public DoubleStack()
    {
        Init(defaultCapacity);
    }

    /// <summary>
    /// 构造指定容量的双端栈
    /// </summary>
    /// <param name="capacity">容量</param>
    public DoubleStack(int capacity)
    {
        if (capacity <= 0)
        {
            throw new ArgumentException($"不合法的容量：{capacity}！");
        }
        Init(capacity);
    }

    #endregion

    #region 私有

    /// <summary>
    /// 初始化
    /// </summary>
    /// <param name="capacity">容量</param>
    private void Init(int capacity)
    {
        array = new T[capacity];
        this.capacity = capacity;
        leftIndex = -1;
        rightIndex = capacity;
    }

    #endregion

    #region API

    /// <summary>
    /// 压栈
    /// </summary>
    /// <param name="element">元素</param>
    /// <param name="stack">指示操作的栈</param>
    public void Push(T element, EStack stack)
    {
        if (leftIndex + 1 == rightIndex)
        {
            throw new Exception("无剩余空间可供分配！");
        }
        if (stack == EStack.LeftStack)
        {
            leftIndex++;
            array[leftIndex] = element;
        }
        else if (stack == EStack.RightStack)
        {
            rightIndex--;
            array[rightIndex] = element;
        }
    }

    /// <summary>
    /// 弹栈
    /// </summary>
    /// <param name="stack">指示操作的栈</param>
    public T Pop(EStack stack)
    {
        T element = default(T);
        if (stack == EStack.LeftStack)
        {
            if (leftIndex == -1)
            {
                throw new Exception("空栈！");
            }
            element = array[leftIndex];
            array[leftIndex] = default(T);
            leftIndex--;
        }
        else if (stack == EStack.RightStack)
        {
            if (rightIndex == capacity)
            {
                throw new Exception("空栈！");
            }
            element = array[rightIndex];
            array[rightIndex] = default(T);
            rightIndex++;
        }
        return element;
    }

    /// <summary>
    /// 获取栈顶元素
    /// </summary>
    /// <param name="stack">指示操作的栈</param>
    public T Peek(EStack stack)
    {
        if (stack == EStack.LeftStack)
        {
            if (leftIndex == -1)
            {
                throw new Exception("空栈！");
            }
            return array[leftIndex];
        }
        else if (stack == EStack.RightStack)
        {
            if (rightIndex == capacity)
            {
                throw new Exception("空栈！");
            }
            return array[rightIndex];
        }
        return default(T);
    }

    /// <summary>
    /// 清空
    /// </summary>
    public void Clear()
    {
        while (leftIndex != -1)
        {
            Pop(EStack.LeftStack);
        }
        while (rightIndex != capacity)
        {
            Pop(EStack.RightStack);
        }
    }

    /// <summary>
    /// 清空左栈
    /// </summary>
    public void ClearLeft()
    {
        while (leftIndex != -1)
        {
            Pop(EStack.LeftStack);
        }
    }

    /// <summary>
    /// 清空右栈
    /// </summary>
    public void ClearRight()
    {
        while (rightIndex != capacity)
        {
            Pop(EStack.RightStack);
        }
    }

    #endregion
}
```