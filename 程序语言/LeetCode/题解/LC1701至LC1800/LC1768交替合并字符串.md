# LC1768交替合并字符串

难度：简单
数据结构：字符串
算法：双指针

## 题目

给定两个字符串word1和word2。从word1开始，通过**交替添加字母**来合并字符串。如果一个字符串比另一个字符串长，就将多出来的字母追加到合并后字符串的末尾。

返回合并后的字符串。

示例：

> 输入：word1 = "abc", word2 = "pqr"
> 输出："apbqcr"
> 解释：字符串合并情况如下所示：
> word1：a   b   c
> word2：  p   q   r
> 合并后：a p b q c r

> 输入：word1 = "abcd", word2 = "pq"
> 输出："apbqcd"
> 解释：注意，word1 比 word2 长，"cd" 需要追加到合并后字符串的末尾。
> word1：a   b   c   d
> word2：  p   q
> 合并后：a p b q c d

提示：

- 1 <= word1.length, word2.length <= 100
- word1和word2由小写英文字母组成

## 题解

### 双指针

使用双指针指示两字符串已合并的位置。当其中一个字符串已经合并完后，将另一字符串剩余的部分添加到末尾即可。

``` csharp
public string MergeAlternately(string word1, string word2)
{
    if (string.IsNullOrEmpty(word1))
    {
        return word2;
    }

    if (string.IsNullOrEmpty(word2))
    {
        return word1;
    }

    int indexInWord1 = 0, indexInWord2 = 0;
    int lengthOfWord1 = word1.Length, lengthOfWord2 = word2.Length,totalLength = lengthOfWord1 + lengthOfWord2;
    char[] result = new char[totalLength];
    for (int i = 0; i < totalLength; i++)
    {
        if (indexInWord1 >= lengthOfWord1 && indexInWord2 < lengthOfWord2)
        {
            result[i] = word2[indexInWord2++];
            continue;
        }

        if (indexInWord1 < lengthOfWord1 && indexInWord2 >= lengthOfWord2)
        {
            result[i] = word1[indexInWord1++];
            continue;
        }

        if (i % 2 == 0)
        {
            result[i] = word1[indexInWord1++];
        }
        else
        {
            result[i] = word2[indexInWord2++];
        }
    }

    return new string(result);
}
```

对上述循环可以优化，即在一次循环中同时把word1和word2的字符添加到结果中。

``` csharp
public string MergeAlternately(string word1, string word2)
{
    if (string.IsNullOrEmpty(word1))
    {
        return word2;
    }
    
    if (string.IsNullOrEmpty(word2))
    {
        return word1;
    }
    
    int i = 0, indexInWord = 0;
    int lengthOfWord1 = word1.Length, lengthOfWord2 = word2.Length, totalLength = lengthOfWord1 + lengthOfWord2;
    char[] result = new char[totalLength];
    while (i < totalLength)
    {
        if (indexInWord < lengthOfWord1)
        {
            result[i++] = word1[indexInWord];
        }

        if (indexInWord < lengthOfWord2)
        {
            result[i++] = word2[indexInWord];
        }

        indexInWord++;
    }
    
    return new string(result);
}
```

时间复杂度：时间复杂度为O(m + n)，其中m为字符串word1的长度，n为字符串word2的长度。

空间复杂度：使用了一个字符数组存储结果，空间复杂度为O(m + n)。