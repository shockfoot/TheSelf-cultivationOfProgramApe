# LC1534统计好三元组

难度：简单
数据结构：数组
算法：暴力枚举、前缀和

## 题目

如果三元组(arr[i], arr[j], arr[k])满足下列全部条件，则认为它是一个**好三元组**。

- 0 <= i < j < k < arr.length
- |arr[i] - arr[j]| <= a
- |arr[j] - arr[k]| <= b
- |arr[i] - arr[k]| <= c

其中|x|表示x的绝对值。

给定一个整数数组arr，以及a、b、c三个整数。请统计其中好三元组的数量。

示例：

> 输入：arr = [3,0,1,1,9,7], a = 7, b = 2, c = 3
> 输出：4
> 解释：一共有4个好三元组：[(3,0,1), (3,0,1), (3,1,1), (0,1,1)]。

提示：

- 3 <= arr.length <= 100
- 0 <= arr[i] <= 1000
- 0 <= a, b, c <= 1000

## 题解

### 暴力枚举

遍历数组，枚举所有三元组，一一判断。

``` csharp
public int CountGoodTriplets(int[] arr, int a, int b, int c)
{
    if (arr.Length <= 2)
    {
        return 0;
    }

    int count = 0, n = arr.Length;
    for (int i = 0; i < n - 2; i++)
    {
        for (int j = i + 1; j < n - 1; j++)
        {
            for (int k = j + 1; k < n; k++)
            {
                if (IsGoodTriplet(arr, i, j, k, a, b, c))
                {
                    count++;
                }
            }
        }
    }

    return count;
}

private bool IsGoodTriplet(int[] arr, int i, int j, int k, int a, int b, int c)
{
    int n = arr.Length;
    if (i >= 0 && j > i && k > j && k < n)
    {
        return IsGoodTriplet(arr[i], arr[j], arr[k], a, b, c);
    }

    return false;
}

private bool IsGoodTriplet(int x, int y, int z, int a, int b, int c)
{
    return Math.Abs(x - y) <= a && Math.Abs(y - z) <= b && Math.Abs(x - z) <= c;
}
```

时间复杂度：时间复杂度为O(n^3^)，其中n为数组长度。

空间复杂度：空间复杂度为O(1)。

### 前缀和

可以考虑只枚举满足|arr[j] - arr[k]| <= b的二元组，再统计使其满足好三元组的arr[i]的个数。

由|arr[i] - arr[j]| <= a 和|arr[i] - arr[k]| <= c可以得到arr[i]的范围，即[arr[j] − a, arr[j] + a]和[arr[k] − c, arr[k] + c]两个区间的交集，记作[l, r]。因此，在枚举二元组时，只需要统计出满足i < j且arr[i]在[l, r]区间中i的个数即可。

统计一个范围内有多少个数，很容易想到维护一个arr[i]频次数组的前缀和。对于一个二元组(j, k)，可以O(1)得到sum[r] - sum[l - 1]。为了满足i < j的限制，只需要在枚举j的时候，将arr[j]更新到sum数组中即可。

``` csharp
public int CountGoodTriplets(int[] arr, int a, int b, int c)
{
    if (arr.Length <= 2)
    {
        return 0;
    }

    int count = 0, n = arr.Length;
    int[] sum = new int[1001];
    for (int j = 0; j < n - 1; j++)
    {
        for (int k = j + 1; k < n; k++)
        {
            if (Math.Abs(arr[j] - arr[k]) <= b)
            {
                int lj = arr[j] - a, rj = arr[j] + a;
                int lk = arr[k] - c, rk = arr[k] + c;
                int l = Math.Max(0, Math.Max(lj, lk));
                int r = Math.Min(1000, Math.Min(rj, rk));
                if (l <= r)
                {
                    if (l == 0)
                    {
                        count += sum[r];
                    }
                    else
                    {
                        count += sum[r] - sum[l - 1];
                    }
                }
            }
        }
        for (int i = arr[j]; i <= 1000; i++)
        {
            sum[i]++;
        }
    }

    return count;
}
```

时间复杂度：时间复杂度为O(n^2^)，其中n为数组长度。

空间复杂度：需要维护arr[i]频次数组的前缀和，空间复杂度为O(S)，S为数组元素的最大取值。