# LC0136只出现一次的数字

难度：简单
数据结构：数组
算法：位运算

## 题目

给定一个**非空**整数数组nums，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

必须设计并实现**线性时间复杂度且只使用常量额外空间**的算法来解决此问题。

示例：

> 输入：nums = [2,2,1]
> 输出：1

提示：

- 1 <= nums.length <= 3 * 10^4^
- -3 * 10^4^ <= nums[i] <= 3 * 10^4^
- 除了某个元素只出现一次以外，其余每个元素均出现两次。

## 题解

### 位运算

由于题目限制使用线性时间复杂度且只使用常量额外空间的算法来解决此问题，否则可以有许多解法：

- 使用哈希表记录数字。在遍历数组时，如果该数字已经出现了，则从哈希表中删除，否则将其加入到哈希表中。最后留下的数字就是只出现一次的数字。
- 求和。遍历数组，使用哈希表记录所有出现过的数字，并求取数组中所有元素之和。由于哈希表中元素无重复，因此计算哈希表中所有元素之和的两倍，即为数组中每个元素出现两次情况下的和。此时，两和之差极即为数组中只出现一次的数字。

上述解法都需要额外使用O(n)的空间，其中n为数组长度，因此在此题中无法使用。

此时，可以使用异或运算来解决。异或运算有以下三个性质：

- 任何数与0做异或运算，结果仍是其本身，即a 异或 0 = a。
- 任何书与自身做异或运算，结果是0，即a 异或 a = 0。
- 异或运算满足交换律和结合律，即a 异或 b 异或 a = b 异或 a 异或 a = b 异或 (a 异或 a) = b 异或 0 = b。

``` csharp
public int SingleNumber1(int[] nums)
{
    if (nums == null || nums.Length <= 0)
    {
        return 0;
    }

    if (nums.Length == 1)
    {
        return nums[0];
    }

    int rel = 0;

    int n = nums.Length;
    for (int i = 0; i < n; i++)
    {
        rel ^= nums[i];
    }

    return rel;
}
```

时间复杂度：时间复杂度为O(n)，其中n为数组的长度。

空间复杂度：空间复杂度为O(1)。