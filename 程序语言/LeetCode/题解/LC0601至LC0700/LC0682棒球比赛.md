# LC0682棒球比赛

难度：简单
数据结构：数组
算法：暴力枚举

## 题目

棒球比赛比赛由若干回合组成，过去几回合的得分可能会影响以后几回合的得分。

比赛开始时，得分记录是空白的。给定一个记录操作的字符串列表ops，其中ops[i]是需要记录的第i项操作，ops遵循下述规则：

1. 整数x：表示本回合新获得分数x。
2. "+"：表示本回合新获得的得分是前两次得分的总和。题目数据保证记录此操作时前面总是存在两个有效的分数。
3. "D"：表示本回合新获得的得分是前一次得分的两倍。题目数据保证记录此操作时前面总是存在一个有效的分数。
4. "C"：表示前一次得分无效，将其从记录中移除。题目数据保证记录此操作时前面总是存在一个有效的分数。

返回记录中所有得分的总和。

示例：

> 输入：ops = ["5","2","C","D","+"]
> 输出：30

提示：

- 2 <= ops.length <= 1000
- ops[i]为"C"、"D"、"+"，或者一个表示整数的字符串。整数范围是[-3 * 10^4^, 3 * 10^4^]
- 对于"+"操作，题目数据保证记录此操作时前面总是存在两个有效的分数
- 对于"C"和"D"操作，题目数据保证记录此操作时前面总是存在一个有效的分数

## 题解

### 暴力枚举

根据题目，遍历操作序列，计算总得分。特别地，需要维护每次得分的数组以便删减上次得分。

``` csharp
public int CalPoints1(string[] operations)
{
    if (operations is not { Length: > 0 })
    {
        return 0;
    }

    int[] scores = new int[operations.Length];
    int currentScoreIndex = 0;

    int score = 0, n = operations.Length;
    string operation;
    bool isDelete;
    for (int i = 0; i < n; i++)
    {
        operation = operations[i];
        isDelete = false;
        if (!int.TryParse(operation, out int currentScore))
        {
            switch (operation[0])
            {
                case '+':
                    currentScore = scores[currentScoreIndex - 1] + scores[currentScoreIndex - 2];
                    break;
                case 'D':
                    currentScore = scores[currentScoreIndex - 1] * 2;
                    break;
                case 'C':
                    isDelete = true;
                    score -= scores[currentScoreIndex - 1];
                    currentScoreIndex--; 
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }
    
        if (isDelete == false)
        {
            score += currentScore;
            scores[currentScoreIndex++] = currentScore;
        }
    }

    return score;
}
```

时间复杂度：时间复杂度为O(n)，其中n为操作序列长度。

空间复杂度：需要维护每次得分，空间复杂度为O(n)。