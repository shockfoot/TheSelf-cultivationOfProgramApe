# LC2302统计得分小于K的子数组数目

难度：中等
数据结构：数组
算法：滑动窗口

## 题目

一个数组的分数定义为数组之和乘以数组的长度。

比方说，[1, 2, 3, 4, 5]的分数为(1 + 2 + 3 + 4 + 5) * 5 = 75。

给定一个正整数数组nums和一个整数k，请返回nums中分数**严格小于**k的非空整数子数组数目。

> 子数组是数组中的一个连续非空部分。

示例：

> 输入：nums = [2,1,4,3,5], k = 10
> 输出：6

提示：

- 1 <= nums.length <= 10^5^
- 1 <= nums[i] <= 10^5^

## 题解

### 暴力枚举

用暴力枚举的方法，即双层循环枚举所有子数组。因为提示中数据量比较大，会超时。

``` csharp
public long CountSubarrays(int[] nums, int k)
{
    if (nums is not { Length: > 0 })
    {
        return 0;
    }

    int n = nums.Length;
    long sum = 0, result = 0;
    for (int i = 0; i < n; i++)
    {
        sum = 0;
        for (int j = i; j < n; j++)
        {
            sum += nums[j];
            if (sum * (j - i + 1) < k)
            {
                result++;
            }
        }
    }

    return result;
}
```

时间复杂度：时间复杂度为O(n^2^)，n为数组长度。

空间复杂度：空间复杂度为O(1)。

### 滑动窗口

因为数组的分数和元素和与其长度成正相关，因此可以使用滑动窗口，不断在遍历过程中添加或删除元素，次数子数组的数量为left - right + 1。

``` csharp
public long CountBadPairs(int[] nums)
{
    if (nums is not { Length: > 0 })
    {
        return 0;
    }

    int n = nums.Length;
    for (int i = 0; i < n; i++)
    {
        nums[i] -= i;
    }

    Array.Sort(nums);

    long result = 0;
    for (int i = 0, j = 0; j < n; j++)
    {
        if (nums[i] != nums[j])
        {
            i = j;
        }

        result += i;
    }

    return result;
}
```

时间复杂度：时间复杂度为O(n)，n为数组长度。

空间复杂度：空间复杂度为O(1)。