# LC2364统计坏数对的数目

难度：简单
数据结构：数组
算法：暴力枚举

## 题目

给定一个下标从0开始的整数数组nums。如果i < j且j - i != nums[j] - nums[i]，那么称(i, j)是一个坏数对。

请返回nums中坏数对的总数目。

示例：

> 输入：nums = [4,1,3,3]
> 输出：5

提示：

- 1 <= nums.length <= 10^5^
- 1 <= nums[i] <= 10^9^

## 题解

### 哈希表

用暴力枚举的方法，即双层循环枚举所有数对，因为提示中数据量比较大，会超时，所以需要对算法进行优化。

根据坏数对的定义，可以知道，nums[i] - i != nums[j] - j即满足题目条件。因此，可以在遍历数组的过程中，计算与之不同的个数并累加即可。

``` csharp
public long CountBadPairs(int[] nums)
{
    if (nums is not { Length: > 0 })
    {
        return 0;
    }

    long result = 0;
    
    Dictionary<int, int> dict = new ();
    int n = nums.Length, key, count;
    for (int i = 0; i < n; i++)
    {
        count = 0;
        key = nums[i] - i;
        dict.TryGetValue(key, out count);
        // 减去非坏数对
        result += i - count;
        dict[key] = count + 1;
    }

    return result;
}
```

时间复杂度：时间复杂度为O(n)，n为数组长度。

空间复杂度：空间复杂度为O(n)。

### 握手

根据nums[i] - i != nums[j] - j，可以先将数组每个元素减i，然后排序。排序后双指针遍历数组，慢指针的索引就是与快指针可以组成坏数对的个数。

``` csharp
public long CountBadPairs(int[] nums)
{
    if (nums is not { Length: > 0 })
    {
        return 0;
    }

    int n = nums.Length;
    for (int i = 0; i < n; i++)
    {
        nums[i] -= i;
    }

    Array.Sort(nums);

    long result = 0;
    for (int i = 0, j = 0; j < n; j++)
    {
        if (nums[i] != nums[j])
        {
            i = j;
        }

        result += i;
    }

    return result;
}
```

时间复杂度：排序的时间复杂度最好为O(nlogn)，n为数组长度。

空间复杂度：空间复杂度为O(1)。