# LC0010正则表达式匹配

难度：困难
数据结构：字符串
算法：动态规划

## 题目

给定一个字符串s和一个字符规律p，请实现一个支持'.'和'*'的正则表达式匹配。

- '.'匹配任意单个字符
- '*'匹配零个或多个前面的那一个元素

所谓匹配，是要涵盖**整个**字符串s，而不是部分字符串。

示例：

> 输入：s = "aa"，p = "a"
> 输出：false
> 解释："a"无法匹配"aa"整个字符串

> 输入：s = "aa"，p = "a*"
> 输出：true
> 解释：因为'*'代表可以匹配零个或多个前面的那一个元素，在这里前面的元素就是'a'。因此，字符串"aa"可被视为'a'重复了一次。

提示：

- 1 <= s.length <= 20
- 1 <= p.length <= 20
- s只包含从a-z的小写字母
- p只包含从a-z的小写字母以及字符'.'和'*'
- 保证每次出现字符'*'时，前面都匹配到有效的字符

## 题解

### 动态规划

题目中匹配是**逐字符匹配**的过程，即每次从p中取出一个字符或字符 + '*'，并在s中进行匹配。当前字符的匹配结果会影响下一字符的匹配，因此可以使用动态规划，对匹配结果进行枚举。

使用dp[i, j]表示s的前i个字符与p的前j个字符是否能匹配。

- 当p[j]是一个字母时，则必须在s中匹配一个相同的字母，否则匹配失败，则状态转移方程为：dp[i, j] = s[i] == p[j] && dp[i - 1, j - 1]；
- 当p[j]是'.'时，可以比配s中任意一个字母，则状态转移方程为：dp[i, j] = dp[i - 1, j - 1]；
- 当p[j]是'*'时，则必须在s中匹配p[j - 1]零次或多次。当匹配零次时，即p[j - 1]p[j]匹配成功，dp[i, j] = dp[i, j - 2]；当匹配多次时，逐个匹配s[i]及其后字符，直到不能匹配为止，状态转移方程为：dp[i, j] = s[i] == p[j - 1] ? dp[i - 1, j] || dp[i, j - 2] : dp[i, j - 2]。

以上，状态转移方程dp[i, j] = p[j] != '*' ? (p[j] == '.' || (s[i] == p[j] && dp[i - 1, j - 1])) : (s[i] == p[j - 1] ? dp[i - 1, j] || dp[i, j - 2] : dp[i, j - 2])。

边界是dp[0, 0] = `true`，即两个空字符串是可以匹配的，此时**需要注意dp的下标和字符串中字符位置的对应关系**。最终的答案即为dp[m, n]，其中m和n分别是字符串s和p的长度。

``` csharp
public bool IsMatch(string s, string p)
{
    int m = s.Length, n = p.Length;
    bool[,] dp = new bool[m + 1, n + 1];
    // s和p都为空字符串时匹配成功
    dp[0, 0] = true;
    for (int i = 0; i <= m; i++)
    {
        // 索引0为空字符串，所以j从1开始匹配
        for (int j = 1; j <= n; j++)
        {
            if (p[j - 1] == '*')
            {
                dp[i, j] = dp[i, j - 2];
                if (Matches(s, p, i, j))
                    dp[i, j] = dp[i, j] || dp[i - 1, j];
            }
            else
            {
                if (Matches(s, p, i, j))
                    dp[i, j] = dp[i - 1, j - 1];
            }
        }
    }
    // 返回结果
    return dp[m, n];
}

public bool Matches(string s, string p, int i, int j)
{
    // s从空字符开始匹配都失败
    if (i == 0) return false;
    return p[j - 1] == '.' || s[i - 1] == p[j - 1];
}
```

时间复杂度：需要得到共m * n个状态，所以时间复杂度为O(nm)，其中m和n分别是字符串s和p的长度。

空间复杂度：空间复杂度为O(n)，用于存储所有状态。