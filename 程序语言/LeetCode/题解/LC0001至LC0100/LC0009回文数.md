# LC0009回文数

难度：简单
数据结构：字符串
算法：双指针

## 题目

给定一个整数x，如果x是一个回文整数，返回`true`；否则，返回`false`。

回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

示例：

> 输入：x = 121
> 输出：true

> 输入：x = -121
> 输出：false
> 解释：从左向右读，为-121。从右向左读，为121-。因此它不是一个回文数。

提示：

- -2^31^ <= x <= 2^31^-1

## 题解

由题可知，小于零或能被10整除（除了0）的数一定不是回文数。

### 双指针

将x转换为字符串，然后使用双指针从两头依次判断是否是一样的字符。

``` csharp
public bool IsPalindrome(int x)
{
    // 排除特殊情况
    if (x == 0) return true;
    if (x < 0 || (x != 0 && x % 10 == 0)) return false;

    // 转换为字符串
    string s = x.ToString();
    // 双指针
    int left = 0, right = s.Length - 1;
    while (left < right)
    {
        if (s[left++] != s[right--]) return false;
    }
    return true;
}
```

时间复杂度：需要遍历字符串的一半，时间复杂度为O(n)，n为字符串长度。

空间复杂度：使用了字符串，因此空间复杂度为O(n)。

### 反转一半数字

回文数的前半部分和反转后的后半部分相同，因此可以考虑反转数字的后半部分，并与前半部分相比较。

对于一个数字，不断地对10取模、整除10可以得到每一位，将得到的每一位乘10、加上下一位即可得到其反转。如果继续这个过程，可以得到更多位数的反转。

在反转过程中，原数字需要不断整除10，反转的数字要不断乘10，因此当原数字小于或等于反转数字时，反转数字的位数已经达到最初数字位数的一半。

``` csharp
public bool IsPalindrome(int x)
{
    // 排除特殊情况
    if (x == 0) return true;
    if (x < 0 || (x != 0 && x % 10 == 0)) return false;

    int revertedNumber = 0;
    while (x > revertedNumber)
    {
        revertedNumber = revertedNumber * 10 + x % 10;
        x /= 10;
    }
    // 需要排除奇数长度时最中间的数字
    return x == revertedNumber || x == revertedNumber / 10;
}
```

时间复杂度：每次迭代都会将原始数字整除10，因此迭代次数为x位数的一半，因此时间复杂度为O(log~10~n)，n为x的值。

空间复杂度：只需要常数空间存放若干变量，所以空间复杂度为O(1)。