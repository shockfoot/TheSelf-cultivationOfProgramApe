# 0021合并两个有序链表

难度：简单
数据结构：链表
算法：暴力枚举、递归

## 题目

将两个升序链表合并为一个新的**升序**链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

示例：

> 输入：l1 = [1,2,4]，l2 = [1,3,4]
> 输出：[1,1,2,3,4,4]

提示：

- 两个链表的节点数目范围是[0, 50]
- 0 &lt;= Node.val &lt;= 100
- l1和l2均按**非递减顺序**排列

## 题解

### 暴力枚举

可以同时遍历两个链表，比较两个结点的值，将较小的添加到结果之中，然后移动到该链表的下一结点。

当两个链表长度不同时，只能遍历到较短链表的末尾，但是由于链表是有序的，此时另一链表余下的结点都比结果中所有结点大，因此只需要简单的将非空链表接在结果后即可。

``` csharp
public ListNode<int> MergeTwoLists(ListNode<int> list1, ListNode<int> list2)
{
    if (list1 == null) return list2;
    if (list2 == null) return list1;

    ListNode<int> dummy = new ListNode<int>(0), sentry = dummy;
    while (list1 != null && list2 != null)
    {
        if (list1.val >= list2.val)
        {
            sentry.next = list2;
            list2 = list2.next;
        }
        else
        {
            sentry.next = list1;
            list1 = list1.next;
        }
        sentry = sentry.next;
    }
    // 连接非空链表剩余部分
    sentry.next = list1 == null ? list2 : list1;
    return dummy.next;
}
```

时间复杂度：需要遍历两个链表，因此时间复杂度为O(n+m)，其中n和m分别为两个链表的长度。

空间复杂度：空间复杂度为O(1)。

### 递归

经过分析，每次合并操作都是结点值较小链表的剩余结点和另一链表进行合并操作，因此可以递归地对较小值结点后的结点和另一链表进行合并。

``` csharp
public ListNode<int> MergeTwoLists(ListNode<int> list1, ListNode<int> list2)
{
    // 边界条件
    if (list1 == null)
    {
        return list2;
    }
    else if (list2 == null)
    {
        return list1;
    }
    // 递归合并
    else if (list1.val >= list2.val)
    {
        list2.next = MergeTwoLists(list1, list2.next);
        return list2;
    }
    else
    {
        list1.next = MergeTwoLists(list1.next, list2);
        return list1;
    }
}
```

时间复杂度：每个结点都要递归一次，因此时间复杂度为O(n+m)。

空间复杂度：空间复杂度为O(n+m)，主要用于递归栈的开销。