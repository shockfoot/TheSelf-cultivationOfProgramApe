# LC0004寻找两个正序数组的中位数

难度：困难
数据结构：数组
算法：暴力枚举、二分查找

## 题目

给定两个大小分别为m和n的正序（从小到大）数组nums1和nums2。请找出并返回这两个正序数组的**中位数**。

算法的时间复杂度应该为O(log(m + n))。

示例：

> 输入：nums = [1, 2]，nums2 = [3, 4]
> 输出：2.5
> 解释：合并数组 = [1, 2, 3, 4]，中位数 = (2+3)/2 = 2.5

提示：

- nums1.length = m
- nums2.length = n
- 0 <= m <= 1000
- 0 <= n <= 1000
- 1 <= m + n <= 2000
- -10^6^ <= nums1[i]，nums2[i] <= 10^6^

## 题解

### 暴力枚举

直接将两个有序数组合并，然后根据合并数组长度直接定位到中位数。

``` csharp
public double FindMedianSortedArrays(int[] nums1, int[] nums2)
{
    int m = nums1.Length, n = nums2.Length, l = m + n;
    // 使用两个指针将两数组合并成一个新数组
    int[] total = new int[l];
    int pointer1 = 0, pointer2 = 0;
    for (int i = 0; i < l; i++)
    {
        if (pointer1 < m && (pointer2 >= n || nums1[pointer1] <= nums2[pointer2]))
        {
            total[i] = nums1[pointer1];
            pointer1++;
        }
        else
        {
            total[i] = nums2[pointer2];
            pointer2++;
        }
    }

    // 直接定位到中位数
    pointer1 = l / 2;
    double rel = total[pointer1];
    if (l % 2 == 0)
    {
        rel += total[pointer1 - 1];
        rel = rel / 2d;
    }

    return rel;
}
```

时间复杂度：需要遍历两个数组，时间复杂度为O(m + n)。

空间复杂度：开辟了一个长度为m+n的数组保存合并后的两个数组，因此空间复杂度为O(m + n)。

### 暴力枚举优化

其实，在遍历过程中无需真正的对两个有序数组合并，只需要确定中位数的位置即可，因此可以节省合并数组的内存开销。

``` csharp
public double FindMedianSortedArrays(int[] nums1, int[] nums2)
{
    int m = nums1.Length, n = nums2.Length, l = m + n;
    // 不开辟数组，但需要两个值保存中位数
    int left = 0, right = 0;
    int pointer1 = 0, pointer2 = 0;
    for (int i = 0; i <= l / 2; i++)
    {
        // 每次遍历时记录左边的值
        left = right;
        if (pointer1 < m && (pointer2 >= n || nums1[pointer1] <= nums2[pointer2]))
        {
            right = nums1[pointer1];
            pointer1++;
        }
        else
        {
            right = nums2[pointer2];
            pointer2++;
        }
    }

    double rel = right;
    if (l % 2 == 0)
    {
        rel += left;
        rel = rel / 2d;
    }

    return rel;
}
```

时间复杂度：时间复杂度为O(m + n)。

空间复杂度：空间复杂度为O(1)。

### 二分查找

在上述方法中，每次遍历便去掉一个不可能是中位数的值，即一个一个排除。由于数组是有序的，可以使用二分一半一半的排除。

在有序数组中求中位数，其实就是**求第k小的数**，k为数组长度的一半。

对于两有序数组nums1和nums2，要找到第k小的元素，可以比较nums1[k / 2 - 1]和nums2[k / 2 - 1]，其中'/'表示整除。

- 如果nums1[k / 2 - 1] <= nums2[k / 2 - 1]，此时可以排除nums1中的nums1[0]到nums1[k / 2 - 1]共前k / 2个元素。
- 如果nums1[k / 2 - 1] > nums2[k / 2 - 1]，此时可以排除nums2中的nums2[0]到nums2[k / 2 - 1]共前k / 2个元素。

可以看到，在比较一次后，排除了一半的数，同时可以在排除后的新数组上继续进行二分查找，并根据排除的个数，减小k的值。

当然，边界情况需要特殊处理：

- 如果nums1[k / 2 - 1]或nums2[k / 2 - 1]越界，那么只能选取对应越界数组的最后一个元素，此时排除的元素个数不一定是k / 2个，而是越界数组中剩余的个数。
- 如果一个数组已经全部排除，可以直接返回应一个数组中第k小的元素。
- 如果k为1，只需要返回两数组中较小的首元素即可。

``` csharp
public double FindMedianSortedArrays(int[] nums1, int[] nums2)
{
    int m = nums1.Length, n = nums2.Length, l = m + n;
    if (l % 2 == 0)
    {
        int midIndex2 = l / 2, midIndex1 = midIndex2 - 1;
        return (GetKth(nums1, nums2, midIndex1 + 1) + GetKth(nums1, nums2, midIndex2+1)) / 2d;
    }
    else
    {
        int midIndex1 = l / 2;
        return GetKth(nums1, nums2, midIndex1 + 1);
    }
}

private int GetKth(int[] nums1, int[] nums2, int k)
{
    int m = nums1.Length, n = nums2.Length;
    // 已经排除后的索引
    int index1 = 0, index2 = 0;
    while (true)
    {
        // nums1已经全被排除
        if (index1 == m)
        {
            return nums2[index2 + k - 1];
        }
        // nums2已经全被排除
        if (index2 == n)
        {
            return nums1[index1 + k - 1];
        }
        // k为1
        if (k == 1)
        {
            return Math.Min(nums1[index1], nums2[index2]);
        }
        // 正常情况
        int half = k / 2;
        // 下一个比较的索引，需要判断是否越界
        int newIndex1 = Math.Min(index1 + half, m) - 1;
        int newIndex2 = Math.Min(index2 + half, n) - 1;
        int pivot1 = nums1[newIndex1], pivot2 = nums2[newIndex2];
        if (pivot1 <= pivot2)
        {
            k -= newIndex1 - index1 + 1;
            index1 = newIndex1 + 1;
        }
        else
        {
            k -= newIndex2 - index2 + 1;
            index2 = newIndex2 + 1;
        }
    }
}
```

时间复杂度：每轮循环将查找范围减少一半，因此时间复杂度为O(log(m+n))。

空间复杂度：空间复杂度为O(1)。

### 对较短数组二分查找

因为**中位数可以将一个集合划分为两个长度相等的子集，其中一个子集的元素总是大于另一个子集的元素，** 所以可以对两个有序数组中的一个做二分，则有以下两种情况：

- 当两数组长度和为偶数时，若在nums1的i处分割，当nums2的分割位置j在(m + n) / 2 - i，此时两数组左部元素数量和与右部元素数量和相等。只需要确保左部元素最大值小于等于右部元素最小值，则中位数为(左部最大值+右部最小值)/2。
- 当两数组长度和为奇数时，若在nums1的i处分割，当nums2的分割位置j在(m + n + 1) / 2 - i，此时两数组左部元素数量和比右部元素数量和多1。只需要确保左部元素最大值小于等于右部元素最小值，则中位数为左部最大值。

当两数组长度和为偶数时，j的分割位置(m + n) / 2 - i等同于(m + n + 1) / 2 - i。当前，因为0 <= i <= m，0 <= j <= n，所以要确保m <= n。

以上，只需要不停的调整在nums1中的分割位置i，并确保左部元素最大值小于等于右部元素最小值。

i的位置可以通过二分确定，每次缩小一半的范围。而在缩小范围过程中，要确保左部元素最大值小于等于右部元素最小值需要比较分割位置的元素：

- 当nums1[i] < nums2[j - 1]（此时i != m、j != 0），范围右边界应该缩小；
- 当nums1[i - 1] > nums2[j]（此时i != 0、j != n），范围左边界应该缩小；

此外，需要考虑边界情况：

- 当i == 0或j == 0时，即有一个数组全部分割在了右部，则当i == 0时，左部最大值为nums2[j - 1]；则当j == 0时，左部最大值为nums1[i - 1]。
当i == m或j == n时，即有一个数组全部分割在了左部，则当i == m时，右部最小值为nums2[j]；则当j == n时，右部最小值为nums1[i]。

``` csharp
public double FindMedianSortedArrays(int[] nums1, int[] nums2)
{
    // 保证nums1的长度小于nums2
    if (nums1.Length > nums2.Length)
    {
        return FindMedianSortedArrays4(nums2, nums1);
    }

    int m = nums1.Length, n = nums2.Length, l = m + n;
    int iMin = 0, iMax = m;
    while (iMin <= iMax)
    {
        int i = (iMin + iMax) / 2;
        int j = (m + n + 1) / 2 - i;
        // i要增加
        if (j != 0 && i != m && nums2[j - 1] > nums1[i]) iMin++;
        // i要减小
        else if (i != 0 && j != n && nums1[i - 1] > nums2[j]) iMax--;
        else
        {
            int maxLeft = 0;
            if (i == 0) maxLeft = nums2[j - 1];
            else if (j == 0) maxLeft = nums1[i - 1];
            else maxLeft = Math.Max(nums1[i - 1], nums2[j - 1]);
            // 奇数个只有一个中位数
            if (l % 2 == 1) return maxLeft;

            int minRight = 0;
            if (i == m) minRight = nums2[j];
            else if (j == n) minRight = nums1[i];
            else minRight = Math.Min(nums1[i], nums2[j]);
            return (maxLeft + minRight) / 2d;
        }
    }

    return 0;
}
```

时间复杂度：只对较短数组进行了二分查找，因此时间复杂度为O(log(min(m, n)))。

空间复杂度：空间复杂度为O(1)。