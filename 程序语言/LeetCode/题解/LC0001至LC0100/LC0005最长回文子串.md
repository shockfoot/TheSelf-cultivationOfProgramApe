# LC0005最长回文子串

难度：中等
数据结构：字符串
算法：动态规划

## 题目

给定一个字符串s，找到s中最长的回文子串。

如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。

示例：

> 输入：s = "babad"
> 输出："bab"
> 解释："aba"同样是符合题意的答案。

提示：

- 1 <= s.length <= 1000
- s仅由数字和英文字母组成

## 题解

### 动态规划

对于一个子串，如果它是回文串且长度大于2，则将其首尾两个字符去掉之后，它仍然是个回文串。例如对于"babab"，如果已经知道"aba"是回文串，那么"babab"则一定是回文串，因为它的首尾两个字符都是"b"。

以上，可以使用动态规划解决本题。用P(i, j)表示字符串s的第i到j个字符组成的串（用s[i..j]表示）是否为回文串，那么当其子串s[i + 1..j - 1]是回文串时，P(i, j)为`true`，其他情况（s[i + 1..j - 1]不是回文串、i &gt; j）时为`false`，状态转移方程为P(i, j) = P(i + 1, j - 1) && (s[i] == s[j])。边界条件为子串小于等于2。

如果子串长度为1则是回文串（P(i, i) == `true`），长度为2时只要两字母相同则是回文串（P(i, i + 1) = s[i] == s[i + 1]）。

> **注意**：因为状态转移方程中是从较短长度的字符串向较长长度字符串进行转移的，所以在循环时也应从较短字符串开始。

``` csharp
public string LongestPalindrome(string s)
{
    if (s == null || s.Length < 2)
    {
        return s;
    }

    int length = s.Length;
    // 最长回文串的起始位置和长度
    int relStart = 0, maxLength = 1;
    // dp[i,j]表示子串s[i..j]是否是回文串
    bool[,] dp = new bool[length,length];
    // 所有长度为1的子串都是回文串
    for (int i = 0; i < length; i++)
    {
        dp[i, i] = true;
    }
    // 枚举所有子串：从长度为2的开始
    for (int l = 2; l <= length; l++)
    {
        // 左边界
        for (int i = 0; i < length; i++)
        {
            // 由长度和左边界可以确定右边界
            int j = i + l - 1;
            // 右边界越界则退出当前循环
            if (j >= length) break;

            // 两端字符不相同一定不是回文串
            if (s[i] != s[j])
            {
                dp[i, j] = false;
            }
            else
            {
                // 两端字符相同长度小于等于3的串是回文串
                if (j - i < 3)
                {
                    dp[i, j] = true;
                }
                // 和去掉首尾两字母后的串具有相同的回文性
                else
                {
                    dp[i, j] = dp[i + 1, j - 1];
                }
            }
            // 记录最长回文串的长度和位置
            if (dp[i, j] && j - i + 1 > maxLength)
            {
                relStart = i;
                maxLength = j - i + 1;
            }
        }
    }

    return s.Substring(relStart, maxLength);
}
```

时间复杂度：需要确定所有子串的状态（动态规划的状态总数为O(n^2^)），每个状态需要的转移时间为O(1)，因此时间复杂度为O(n^2^)，n为字符串长度。

空间复杂度：开辟了一个二维数组保用于存储动态规划各个状态，因此空间复杂度为O(n^2^)。

### 中心扩展

观察动态规划的状态转移方程，有状态转移链：某一边界情况 ->; ... ->; P(i + 1, j - 1) -> P(i, j)。可以发现，**所有的状态在转移时的可能性都是唯一的**，即可以根据每一种边界情况就可以得出所有状态。边界条件即为子串长度小于等于2。

以上，枚举每一种边界情况，并从对应的子串不断地向两边扩展。如果两边的字符相同则继续扩展；如果不同则停止扩展，因为之后的子串都不可能是回文串。

``` csharp
public string LongestPalindrome(string s)
{
    if (s == null || s.Length == 0)
    {
        return s;
    }

    int length = s.Length;
    // 最长回文串的起始位置和长度
    int start = 0, end = 0;
    // 枚举所有边界情况
    for (int i = 0; i < length; i++)
    {
        // 长度为1时
        int length1 = ExpandAroundCenter(s, i, i, length);
        // 长度为2时
        int length2 = ExpandAroundCenter(s, i, i + 1, length);
        int len = Math.Max(length1, length2);
        // 记录最长回文串的起始和结束索引
        if (len > end - start)
        {
            start = i - (len - 1) / 2;
            end = i + len / 2;
        }
    }

    return s.Substring(start, end - start + 1);
}

private int ExpandAroundCenter(string s, int left, int right, int length)
{
    // 当两边字符相同时向两侧扩展
    while (left >= 0 && right < length && s[left] == s[right])
    {
        left--;
        right++;
    }

    return right - left - 1;
}
```

时间复杂度：长度为1和2的边界情况分别有n和n - 1种，每种情况最多或扩展n次，因此时间复杂度为O(n^2^)，n为字符串长度。

空间复杂度：只需要常数个变量，空间复杂度为O(1)。