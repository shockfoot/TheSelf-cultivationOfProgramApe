# 0019删除链表的倒数第n个结点

难度：中等
数据结构：链表
算法：暴力枚举、哈希表、双指针

## 题目

给你一个链表，删除链表的倒数第n个结点，并且返回链表的头结点。

有效字符串需满足：

1. 左括号必须**用相同类型的右括号闭合**。
2. 左括号必须**以正确的顺序闭合**。
3. 每个右括号都有一个对应的相同类型的左括号。

示例：

> 输入：head = [1,2,3,4,5]，n = 2
> 输出：[1,2,3,5]

提示：

- 链表中结点的数目为sz
- 1 &lt;= sz &lt;= 30
- 0 &lt;= Node.val &lt;= 100
- 1 &lt;= n &lt;= sz

## 题解

在对链表进行操作时，为了方便统一链表头结点和其他结点的操作，通常在头结点之前置一哑结点（Dummy Node）。

特别地，在某些语言中，由于需要自行对内存进行管理。对于**是否需要释放被删除节点对应的空间**这一问题应根据实际情况而定。下面的代码中默认不释放空间。

### 暴力枚举

通过遍历链表确定其长度L，然后再遍历链表找到需要删除的结点的前一个结点（从哑结点开始位置为L-n+1）。

> n从1开始编号。

``` csharp
public class ListNode<T>
{
    /// <summary>
    /// 获取单链表长度
    /// </summary>
    public static int GetLength(ListNode<T> head)
    {
        int length = 0;
        while (head != null)
        {
            length++;
            head = head.next;
        }
        return length;
    }
}

public ListNode<int> RemoveNthFromEnd(ListNode<int> head, int n)
{
    ListNode<int> dummy = new ListNode<int>(0, head);
    int length = ListNode<int>.GetLength(head), aim = length - n + 1;
    ListNode<int> pre = dummy;
    for (int i = 1; i < aim; i++)
    {
        pre = pre.next;
    }
    pre.next = pre.next.next;
    return dummy.next;
}
```

时间复杂度：需要遍历两次链表，时间复杂度为O(L)，L为链表长度。

空间复杂度：空间复杂度为O(1)。

### 哈希表

由于题中链表总长有限，可以使用哈希表（此处使用数组）实现时间复杂度为O(1)的结点查找，从而实现一次遍历。

``` csharp
public ListNode<int> RemoveNthFromEnd(ListNode<int> head, int n)
{
    ListNode<int> dummy = new ListNode<int>(0, head), cur = dummy;
    ListNode<int>[] nodeList = new ListNode<int>[31];
    int length = 0;
    while (cur != null)
    {
        nodeList[length] = cur;
        length++;
        cur = cur.next;
    }
    nodeList[length - n - 1].next = nodeList[length - n].next;
    return dummy.next;
}
```

时间复杂度：遍历一次链表，时间复杂度为O(L)。

空间复杂度：使用一维数组存储链表所有结点，空间复杂度为O(L)。

### 双指针

使用双指针，使双指针相差n+2，这样，当快指针到达链表末尾时，慢指针正好在需要删除结点的前驱上，这样可以不需要获取链表长度即可定位到目标结点的前驱。

``` csharp
public ListNode<int> RemoveNthFromEnd(ListNode<int> head, int n)
{
    ListNode<int> dummy = new ListNode<int>(0, head), fast = head, slow = dummy;
    while (fast != null)
    {
        fast = fast.next;
        if (n > 0)
        {
            n--;
        }
        else
        {
            slow = slow.next;
        }
    }
    slow.next = slow.next.next;
    return dummy.next;
}
```

时间复杂度：遍历一次链表，时间复杂度为O(L)。

空间复杂度：仅使用常数个变量，空间复杂度为O(1)。