# LC0011盛最多水的容器

难度：中等
数据结构：数组
算法：暴力枚举、双指针

## 题目

给定一个长度为n的整数数组height。有n条垂线，第i条线的两个端点是(i, 0)和(i, height[i])。

找出其中的两条线，使得它们与x轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

> **注意**：不能倾斜容器。

示例：

![LC0011盛最多水的容器](LC0011盛最多水的容器.jpg)

> 输入：[1,8,6,2,5,4,8,3,7]
> 输出：49
> 解释：图中垂直线代表输入数组[1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为49。

提示：

- n == height.length
- 2 <= n <= 10^5^
- 0 <= height[i] <= 10^4^

## 题解

### 暴力枚举

双循环计算每一个容器的容量，记录最大的即可。

``` csharp
public int MaxArea(int[] height)
{
    int rel = 0, length = height.Length;
    for (int i = 0; i < length - 1; i++)
    {
        for (int j = i + 1; j < length; j++)
        {
            rel = Math.Max(rel, Math.Min(height[i], height[j]) * (j - i));
        }
    }
    return rel;
}
```

时间复杂度：时间复杂度为O(n^2^)，n为数组的长度。

空间复杂度：空间复杂度为O(1)。

### 双指针

容器的容量通过宽乘高算得。一开始让容器的宽最大，即双指针从数组两端开始，每次移动一个指针，让宽度减1。而每次移动时，移动高度较小的指针以**确保在宽减少的同时高至少不减少**。

此处给出推理：

假设当前左指针i指向数组0的位置，值为x，右指针j指向数组最后一个元素，值为y，并且x <= y，那么容量为x \* (j - i)。此时，如果移动右指针（右指针只能向左移动）后指向y'，此时不管y'与x的大小关系如何，容量Min(x, y') \* (j - 1 - i)都不会大于x \* (j - i)，即左指针不应该再作为容器的边界，应当移动较小的左指针而不是右指针。反之亦然。

每次移动一次指针都将问题规模减小1，此时左右指针相当于指向了一个新的、规模减小1的数组的左右边界，因此可以像上述一样考虑新数组的移动选择，进而在问题规模不断缩小的过程中可以得到容量的最大值。

``` csharp
public int MaxArea(int[] height)
{
    int length = height.Length, rel = 0, left = 0, right = length - 1;
    while (left < right)
    {
        // 左指针值小时
        if (height[left] <= height[right])
        {
            rel = Math.Max(rel, height[left] * (right - left));
            left++;
        }
        // 右指针值小时
        else
        {
            rel = Math.Max(rel, height[right] * (right - left));
            right--;
        }
        // 用三元运算符
        // rel = height[left] <= height[right] ? Math.Max(rel, (right - left)* height[left++]) :
        // Math.Max(rel, (right - left) * height[right--]);
    }
    return rel;
}
```

在移动时可以考虑移动多次，即如果移动后指针指向的值并不比当前大，则可以继续移动。

``` csharp
public int MaxArea(int[] height)
{
    int length = height.Length, rel = 0, left = 0, right = length - 1;
    while (left < right)
    {
        if (height[left] <= height[right])
        {
            int shortSlab = height[left];
            rel = Math.Max(rel, shortSlab * (right - left));
            left++;
            while (height[left] <= shortSlab && left < right)
                left++;
        }
        else
        {
            int shortSlab = height[right];
            rel = Math.Max(rel, shortSlab * (right - left));
            right--;
            while (height[right] <= shortSlab && right > left)
                right--;
        }
    }
    return rel;
}
```

时间复杂度：只需要遍历一遍数组，时间复杂度为O(n)。

空间复杂度：空间复杂度为O(1)。