# LC0001两数和

难度：简单
数据结构：数组
算法：暴力枚举、哈希表

## 题目

给定一个整数数组nums和一个整数目标值target，请在该数组中找出**和为目标值**target的那**两个**整数，并返回它们的数组下标。

可以假设每种输入只会对应一个答案。但是，数组中同一个元素再答案里不能重复出现。

可以按任意顺序返回答案。

示例：

> 输入：nums = [3, 2, 3, 7]，target = 6
> 输出：[0, 2]
> 解释：nums[0] + nums[2] = 6

提示：

- 2 <= nums.length <= 10^4^
- -10^9^ <= nums[i] <= 10^9^
- -10^9^ <= target <= 10^9^
- 只会存在一个有效答案

## 题解

### 双循环暴力枚举

遍历数组每一个数x，再遍历一遍数组，检查数组中的数与当前数的和是否等于目标值。

``` csharp
public int[] TwoSum(int[] nums, int target)
{
    // 输入合法性检查
    if (nums == null || nums.Length < 2)
    {
        return null;
    }

    int n = nums.Length;
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
        {
            // 同一个数不能多次使用
            if (i == j) continue;
            // 是否满足目标值
            if (nums[i] + nums[j] == target)
            {
                return new int[] { i, j };
            }
        }
    }

    return null;
}
```

时间复杂度：

- 最佳情况下，数组前两个数就是结果，时间复杂度为O(1)；
- 最坏情况下，数组最后两个数才是结果，外层循环共n - 1次，内层每次都遍历n次，共进行了(n - 1)n次判断，时间复杂度为O(n^2^)。
- 通常情况下，时间复杂度为O(n^2^)。

空间复杂度：只使用常数个变量，因此空间复杂度为O(1)。

### 双循环枚举优化

在遍历过程中可以发现，x之前的每个数都和x匹配过，因此不需要进行匹配。

``` csharp
public int[] TwoSum(int[] nums, int target)
{
    // 输入合法性检查
    if (nums == null || nums.Length < 2)
    {
        return null;
    }

    int n = nums.Length;
    for (int i = 0; i < n - 1; i++)
    {
        // 仅在当前数后面的数中匹配
        for (int j = i + 1; j < n; j++)
        {
            // 是否满足目标值
            if (nums[i] + nums[j] == target)
            {
                return new int[] { i, j };
            }
        }
    }

    return null;
}
```

时间复杂度：

- 最佳情况下，数组前两个数就是结果，时间复杂度为O(1)；
- 最坏情况下，数组最后两个数才是结果，共进行了(n - 1) + (n - 2) + ... + 1 = n(n - 1) / 2次判断，时间复杂度为O(n^2^)；
- 通常情况下，时间复杂度为O(n^2^)。

空间复杂度：只使用常数个变量，因此空间复杂度为O(1)。

### 哈希表

根据题意，需要在数组中根据x，查找targt - x，而使用哈希表可以进行快速的查找。因此，创建一个哈希表，存储x和其索引。在遍历每一个x时，先查找哈希表中是否存在targt - x，如果没有，则将x添加到表中，继续遍历直到结束。

``` csharp
public int[] TwoSum(int[] nums, int target)
{
    // 输入合法性检查
    if (nums == null || nums.Length < 2)
    {
        return null;
    }

    int n = nums.Length;
    // 字典映射值和索引
    Dictionary<int, int> num2IndexDic = new Dictionary<int, int>(n);
    for (int i = 0; i < n; i++)
    {
        if (num2IndexDic.ContainsKey(target - nums[i]))
        {
            return new int[] { num2IndexDic[target - nums[i]], i };
        }
        if (!num2IndexDic.ContainsKey(nums[i]))
        {
            num2IndexDic.Add(nums[i], i);
        }
    }

    return null;
}
```

时间复杂度：

- 最佳情况下，数组前两个数就是结果，时间复杂度为O(1)；
- 最坏情况下，数组最后两个数才是结果，共遍历了n - 1个数，时间复杂度为O(n)；
- 通常情况下，时间复杂度为O(n)。

空间复杂度：主要用于哈希表的开销，空间复杂度为O(n)。