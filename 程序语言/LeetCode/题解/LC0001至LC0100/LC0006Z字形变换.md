# LC0006Z字形变换

难度：中等
数据结构：字符串
算法：暴力枚举、数学推导

## 题目

将一个字符串s，根据给定的行数numRows，以从上到下、从左到右进行Z字形变换。

比如字符串"PAYPALISHIRING"，行数为3时，按Z字形变换排列如下：

> P   A   H   N
> A P L S I I G
> Y   I   R

之后，输出需要从左往右逐行读取，产生一个新字符串，如"PAHNAPLSIIGYIR"。

示例：

> 输入：s = "PAYPALISHIRING"，numRows = 4
> 输出："PINALSIGYAHRPI"
> 解释：
> P     I     N
> A   L S   I G
> Y A   H R
> P     I

提示：

- 1 <= s.length <= 1000
- s仅英文字母（小写和大写）、','和'.'组成
- 1 <= numRows <= 1000

## 题解

特殊情况：只有一行或一列时，变换后的字符串和其本身相同；当字符串长度为1时不需要变换。

### 暴力枚举

创建一个二维数组，遍历字符串，依次在数组中按Z字形变换顺序填充遍历到的字符，最后按行拼接非空字符即可。

二维数组的行数即为numRows，列数需要计算。根据题意，需要往下填充numRows个字符，然后往右上方继续填充numRows - 2个字符，最后回到第一行，因此每个周期需要填充numRows \* 2 - 2个字符，每个周期有numRows - 1列。如果最后一个周期不完整，可以将其视为一个完整周期。以上，二维数组列数为周期数向上取整乘以numRows - 1。

``` csharp
public string Convert(string s, int numRows)
{
    if (string.IsNullOrEmpty(s))
    {
        return s;
    }

    int length = s.Length;
    if (numRows == 1 || numRows >= length || length <= 1)
    {
        return s;
    }
    
    // 因此每个周期需要的字符数
    int period = numRows * 2 - 2;
    // 向上取整，将最后一个周期视作完整周期
    int cols = (length + period - 1) * (numRows - 1) / period;
    char[,] mat = new char[numRows, cols];
    // 遍历字符串
    for (int i = 0, x = 0, y = 0; i < length; i++)
    {
        mat[x, y] = s[i];
        // 当前字符索引取余后小于行数说明还在往下填
        if (i % period < numRows - 1)
        {
            x++;
        }
        // 否则往右上填
        else
        {
            x--;
            y++;
        }
    }

    // 得到结果
    StringBuilder sb = new StringBuilder(length);
    for (int i = 0; i < numRows; i++)
    {
        for (int j = 0; j < cols; j++)
        {
            if (mat[i,j] != 0)
            {
                sb.Append(mat[i, j]);
            }
        }
    }

    return sb.ToString();
}
```

时间复杂度：遍历字符串需要O(n)时间，n为字符串长度；遍历二维数组需要O(rn)时间，r为行数，列数可以视为O(n)，因此时间复杂度为O(rn)，主要用于遍历二维数组。

空间复杂度：空间复杂度为O(rn)，主要用于二维数组的开销，输出结果不计入空间复杂度。

### 暴力枚举优化

在枚举时二维数组中有大量的空间未使用，可以对此进行优化。

在填充字符时可以发现，每次填充都是填充在某行的右侧，因此可以将二维数组更换成一维列表数组，每次填充时追加在改行列表末尾即可。

``` csharp
public string Convert(string s, int numRows)
{
    if (string.IsNullOrEmpty(s))
    {
        return s;
    }

    int length = s.Length;
    if (numRows == 1 || numRows >= length || length <= 1)
    {
        return s;
    }

    StringBuilder[] mat = new StringBuilder[numRows];
    // 初始化每行
    for (int i = 0; i < numRows; i++)
    {
        mat[i] = new StringBuilder();
    }
    // 遍历字符串，使用flag记录是否转向
    for (int i = 0, flag = 1, rowIndex = 0; i < length; i++)
    {
        mat[rowIndex].Append(s[i]);
        rowIndex += flag;
        // 行索引到达行数两端时转向
        if (rowIndex == 0 || rowIndex == numRows - 1)
        {
            flag = -flag;
        }
    }

    // 得到结果
    StringBuilder sb = new StringBuilder(length);
    for (int i = 0; i < numRows; i++)
    {
        sb.Append(mat[i].ToString());
    }

    return sb.ToString();
}
```

时间复杂度：只需要遍历字符串，因此时间复杂度为O(n)。

空间复杂度：优化后的一维列表数组只需要O(n)。

### 数学推导

二维数组的索引可以直接转换为一维数组索引。

分析发现，Z字形变换每个周期内字符数period为numRows \* 2 - 2个，对于第一行和最后一行，每个周期内仅有1个字符，二维数组索引为j + i，j为当前周期已经越过的字符数；对于中间行，每个周期内有两个字符，第一个的二维索引为j + i，第二个的二维索引为j + period - i。

> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j = 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j = period&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j = period\*2
> 0+j&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0+j&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0+j
> 1+j&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j+period-1&nbsp;&nbsp;1+t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j+period-1&nbsp;&nbsp;1+j&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j+period-1
> 2+j&nbsp;&nbsp;j+period-2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2+t&nbsp;&nbsp;j+period-2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2+j&nbsp;&nbsp;j+period-2
> 3+j&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3+t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3+j

``` csharp
public string Convert(string s, int numRows)
{
    if (string.IsNullOrEmpty(s))
    {
        return s;
    }

    int length = s.Length;
    if (numRows == 1 || numRows >= length || length <= 1)
    {
        return s;
    }

    StringBuilder sb = new StringBuilder(length);
    // 每个周期需要的字符数为
    int period = numRows * 2 - 2;
    // 枚举每一行
    for (int i = 0; i < numRows; i++)
    {
        // 枚举每一行的每一个字符
        for (int j = 0; j + i < length; j += period)
        {
            // 添加周期内的第一个字符
            sb.Append(s[j + i]);
            // 中间行添加周期内的第二个字符
            if (i > 0 && i < numRows - 1 && j + period - i < length)
            {
                sb.Append(s[j + period - i]);
            }
        }
    }

    return sb.ToString();
}
```

时间复杂度：只需要遍历字符串中的每个字符，因此时间复杂度为O(n)。

空间复杂度：O(1)。