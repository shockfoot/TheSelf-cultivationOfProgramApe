# LC0007整数反转

难度：中等
算法：暴力枚举、数学推导

## 题目

给定一个32位的有符号整数x，返回将x中的数字部分反转后的结果。

如果反转后整数超过32位的有符号整数的范围[−2^31^, 2^31^ − 1]，就返回0。

**假设环境不允许存储64位整数（有符号或无符号）。**

示例：

> 输入：x = -1230
> 输出：-321

提示：

- −2^31^ <= x <= −2^31^-1

## 题解

### 暴力枚举

使用字符串反转整数的每一位，然后再转换成整数，使用`try-catch`以在溢出时捕获异常。

``` csharp
public int Reverse(int x)
{
    if (x == 0)
    {
        return 0;
    }

    StringBuilder sb = new StringBuilder(11);
    // 先存储符号
    if (x < 0)
    {
        sb.Append("-");
        x = -x;
    }

    // 反转存储每一位
    while (x != 0)
    {
        sb.Append(x % 10);
        x /= 10;
    }

    int ans = 0;
    // 如果溢出则什么都不做
    try
    {
        ans = int.Parse(sb.ToString());
    }
    catch { }

    return ans;
}
```

时间复杂度：要反转十进制整数的每一位，因此时间复杂度为O(log~10~|x|)。

空间复杂度：需要存储十进制整数的每一位，因此空间复杂度为O(log~10~|x|)。

### 数学推导

记ans为反转后的数字，digit为x的最后一位。

为了防止溢出，在每次获取到digit后，都要判断ans \* 10 + digit是否超出范围。

已知`int.MaxValue`（2^31^ − 1 = 2147483647）可以写成(int.MaxValue / 10) \* 10 + int.MaxValue % 10，即(int.MaxValue / 10) * 10 + 7。

当x大于0时，ans \* 10 + digit <= (int.MaxValue / 10) \* 10 + 7，经计算即(ans - int.MaxValue / 10) * 10 <= 7 - digit。

- 当ans > int.MaxValue / 10时，由于digit >= 0，不等式不成立。
- 当ans == int.MaxValue / 10时，当且仅当digit <= 7，不等式成立（当ans == int.MaxValue / 10时若还能追加位数，说明x与`int.MaxValue`位数相同，此时digit必是x的最高位，所以digit <= 2）。
- 当ans < int.MaxValue / 10时，由于digit <= 9，不等式恒成立。

以上，当且仅当ans <= int.MaxValue / 10时，不等式成立。当x小于0时同理。所以−2^31^ <= ans \* 10 + digit <= 2^31^ − 1等价于int.MinValue / 10^ <= ans \* 10 + digit <= int.MaxValue / 10。

``` csharp
public int Reverse(int x)
{
    int ans = 0;
    while (x != 0)
    {
        // 溢出
        if (ans < int.MinValue / 10 || ans > int.MaxValue / 10)
        {
            return 0;
        }

        ans = ans * 10 + x % 10;
        x /= 10;
    }

    return ans;
}
```

时间复杂度：要反转十进制整数的每一位，因此时间复杂度为O(log~10~|x|)。

空间复杂度：O(1)。