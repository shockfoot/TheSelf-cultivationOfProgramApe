# LC0013罗马数字转整数

难度：简单
数据结构：字符串
算法：暴力枚举

## 题目

罗马数字包含以下七种字符：I、V、X、L、C、D和M。

> 字符  数值
> I     1
> V     5
> X     10
> L     50
> C     100
> D     500
> M     1000

例如，罗马数字2写做II，即为两个并列的1。12写做XII，即为X+II。27写做XXVII，即为XX+V+II。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如4不写做IIII，而是IV。数字1在数字5的左边，所表示的数等于大数5减小数1得到的数值4。同样地，数字9表示为IX。这个特殊的规则只适用于以下六种情况：

- I可以放在V（5）和X（10）的左边，来表示4和9。
- X可以放在L（50）和C（100）的左边，来表示40和90。 
- C可以放在D（500）和M（1000）的左边，来表示400和900。

给定一个罗马数字，将其转换成整数。

示例：

> 输入：s = "LVIII"
> 输出：58
> 解释：L = 50，V = 5，III = 3。

提示：

- 1 &lt;= s.length &lt;= 15
- s仅含字符（'I'、'V'、'X'、'L'、'C'、'D'、'M'）。
- 题目数据保证s是一个有效的罗马数字，且表示整数在范围[1, 3999]内。
- 题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。
- IL和IM这样的例子并不符合题目要求，49应该写作XLIX，999应该写作CMXCIX。

## 题解

### 暴力枚举

从右往左遍历，记录当前遇到的最大的数字，若当前数更大则结果加上当前数；否则减去当前数。

``` csharp
public static int RomanToInt(string s)
{
    Dictionary<char, int> Symbols = new Dictionary<char, int>()
    {
        { 'I', 1 }, { 'V', 5 }, { 'X', 10 }, { 'L', 50 },
        { 'C', 100 }, { 'D', 500 }, { 'M', 1000 },
    };
    int rel = 0;
    int max = 0;
    for (int i = s.Length - 1; i >= 0; i--)
    {
        int cur = Symbols[s[i]];
        if (cur >= max)
        {
            rel += cur;
            max = cur;
        }
        else
        {
            rel -= cur;
        }
    }
    return rel;
}
```

类似地有

``` csharp
public static int RomanToInt(string s)
{
    int rel = 0;
    for (int i = s.Length - 1; i >= 0; i--)
    {
        switch (s[i])
        {
            case 'I':
                // 如果rel大于等于5则说明之前出现过V或X，此时出现的I应该减去
                rel += (rel >= 5 ? -1 : 1);
                break;
            case 'V':
                rel += 5;
                break;
            case 'X':
                // 如果rel大于等于50则说明之前出现过L或C，此时出现的X应该减去
                rel += (rel >= 50 ? -1 : 1) * 10;
                break;
            case 'L':
                rel += 50;
                break;
            case 'C':
                // 如果rel大于等于500则说明之前出现过D或M，此时出现的C应该减去
                rel += (rel >= 500 ? -1 : 1) * 100;
                break;
            case 'D':
                rel += 500;
                break;
            case 'M':
                rel += 1000;
                break;
        }
    }
    return rel;
}
```

时间复杂度：遍历字符串s，因此时间复杂度为O(n)，n为字符串长度。

空间复杂度：空间复杂度为O(1)。