# LC0008字符串转整数

难度：中等
数据结构：字符串
算法：暴力枚举、状态机

## 题目

实现一个`myAtoi(string s)`函数，使其能将字符串转换成一个32位有符号整数（类似C/C++中的`atoi()`函数）。

函数`myAtoi(string s)`的算法如下：

1. 读入字符串并丢弃无用的前导空格。
2. 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。确定最终结果是负数还是正数。如果两者都不存在，则假定结果为正。
3. 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。
4. 将前面步骤读入的这些数字转换为整数（即，"123" -> 123，"0032" -> 32）。如果没有读入数字，则整数为0。必要时更改符号（从步骤2开始）。
5. 如果整数数超过32位有符号整数范围[−2^31^, 2^31^ − 1]，需要截断这个整数，使其保持在这个范围内。具体来说，小于−2^31^的整数应该被固定为−2^31^，大于2^31^ − 1的整数应该被固定为2^31^ − 1。
6. 返回整数作为最终结果。

注意：

- 本题中的空白字符只包括空格字符' '。
- 除前导空格或数字后的其余字符串外，请勿忽略任何其他字符。

**假设环境不允许存储64位整数（有符号或无符号）。**

示例：

> 输入：s = "   -42 with words"
> 输出：-42

提示：

- 0 &lt;= s.length &lt;= 200
- s由英文字母（大写和小写）、数字（0-9）、' '、'+'、'-'和'.'组成

## 题解

### 暴力枚举

直接遍历字符串的每一位，判断该位数字是否合法，若合法则将该位数字添加到结果的末位。

对于整数溢出判断，可以根据题*LC0007整数反转*中的数学推导得出。

``` csharp
public int MyAtoi(string s)
{
    s = s.Trim();
    // 特殊情况
    if (s.Length == 0) return 0;
    if (!char.IsDigit(s[0]) && s[0] != '-' &&
        s[0] != '+')
        return 0;

    int length = s.Length;
    int rel = 0;
    // 判断正负
    bool isNegative = s[0] == '-';
    // 如果第一个字符是符号则从第二个字符开始转换
    int index = char.IsDigit(s[0]) ? 0 : 1;
    // 如果是数字则进行转换
    while (index < length && char.IsDigit(s[index]))
    {
        // 判断是否溢出
        if (isNegative)
        {
            // 负数溢出
            if (-rel < int.MinValue / 10 || (-rel == int.MinValue / 10 && s[index] > '8'))
                return int.MinValue;
        }
        else
        {
            // 正数溢出
            if (rel > int.MaxValue / 10 || (rel == int.MaxValue / 10 && s[index] >= '8'))
                return int.MaxValue;
        }
        // 推进结果位数
        rel = rel * 10 + (s[index++] - '0');
    }
    return isNegative ? -rel : rel;
}
```

时间复杂度：需要依次处理字符串的每一位，因此时间复杂度为O(n)，n位字符串长度。

空间复杂度：只需要常数空间存储，因此空间复杂度为O(1)。

### 状态机

字符串的逐字符解析往往涉及复杂的流程和条件状况，可以使用状态机进行处理。

在逐字符解析字符串时，状态机一直处于某种状态，并根据输入字符和转移条件转移到下一个状态，因此只需要建立所有状态之间的转移条件映射表即可。

| | ' ' | '+'/'-' | 数字 | 其他 |
| --- | --- | --- | --- | --- |
| 开始状态Start | Start | Signed | Number | End |
| 符号状态Signed | End | End | Number | End |
| 数字状态Number | End | End | Number | End |
| 结束状态End | End | End | End | End |

``` csharp
public int MyAtoi(string s)
{
    // 创建状态机
    FSM fsm = new FSM();
    int length = s.Length;
    for (int i = 0; i < length; i++)
    {
        // 逐字符解析
        fsm.GetChar(s[i]);
    }
    // 如果发生溢出则直接返回边界值，否则处理符号
    return fsm.IsOverflow ? fsm.Result : (fsm.Result * fsm.Sign);
}

/// <summary>
/// 有限状态机
/// </summary>
private class FSM
{
    /// <summary>
    /// 状态枚举
    /// </summary>
    private enum EState
    {
        Start,
        Signed,
        Number,
        End
    }

    public readonly char Block = ' ';
    public readonly char NegativeSing = '-';
    public readonly char PositiveSing = '+';

    private int result;
    private int sign;
    /// <summary>
    /// 是否溢出。因为不能之间返回结果，因此设置标记，如果溢出了则result直接存界值，
    /// 后续状态转移不做逻辑处理，结果自带符号
    /// </summary>
    private bool isOverflow;
    private EState currentState;
    private Dictionary<EState, EState[]> map;

    public int Result { get { return result; } }
    public int Sign { get { return sign; } }
    public bool IsOverflow { get { return isOverflow; } }

    public FSM()
    {
        result = 0;
        sign = 1;
        isOverflow = false;
        currentState = EState.Start;
        map = new Dictionary<EState, EState[]>()
        {
            { EState.Start, new EState[] { EState.Start, EState.Signed, EState.Number, EState.End } },
            { EState.Signed, new EState[] { EState.End, EState.End, EState.Number, EState.End } },
            { EState.Number, new EState[] { EState.End, EState.End, EState.Number, EState.End } },
            { EState.End, new EState[] { EState.End, EState.End, EState.End, EState.End } }
        };
    }

    /// <summary>
    /// 解析字符
    /// </summary>
    public void GetChar(char c)
    {
        // 根据字符进入相应的状态
        currentState = map[currentState][GetStateConditionIndex(c)];
        switch (currentState)
        {
            case EState.Signed:
                sign = c == PositiveSing ? 1 : -1;
                break;
            case EState.Number:
                // 没有溢出才进行逻辑处理
                if (isOverflow == false)
                {
                    // 判断是否溢出
                    if (sign == -1)
                    {
                        // 负数溢出
                        if (-result < int.MinValue / 10 || (-result == int.MinValue / 10 && c > '8'))
                        {
                            result = int.MinValue;
                            isOverflow = true;
                            break;
                        }
                    }
                    else
                    {
                        // 正数溢出
                        if (result > int.MaxValue / 10 || (result == int.MaxValue / 10 && c >= '8'))
                        {
                            result = int.MaxValue;
                            isOverflow = true;
                            break;
                        }
                    }
                    // 推进结果位数
                    result = result * 10 + (c - '0');
                }
                break;
        }
    }

    /// <summary>
    /// 获取条件映射索引
    /// </summary>
    private int GetStateConditionIndex(char c)
    {
        int index = 3;
        if (c == Block)
        {
            index = 0;
        }
        else if (c == NegativeSing || c == PositiveSing)
        {
            index = 1;
        }
        else if (char.IsDigit(c))
        {
            index = 2;
        }
        return index;
    }
}
```

时间复杂度：时间复杂度为O(n)。

空间复杂度：状态机只需要常数空间存储，因此空间复杂度为O(1)。