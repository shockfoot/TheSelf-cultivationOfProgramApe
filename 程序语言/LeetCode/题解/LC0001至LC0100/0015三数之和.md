# 0015三数之和

难度：中等
数据结构：数组
算法：双指针

## 题目

给你一个整数数组nums，判断是否存在三元组[nums[i], nums[j], nums[k]]满足i != j、i != k且j != k，同时还满足nums[i]+nums[j]+nums[k] == 0。请你返回所有和为0且不重复的三元组。

> 注意：答案中不可以包含重复的三元组。

示例：

> 输入：nums = [-1,0,1,2,-1,-4]
> 输出：[[-1,-1,2]，[-1,0,1]]
> 解释：
> nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0
> nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0
> nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0
> 不同的三元组是[-1,0,1]和[-1,-1,2]。
> 注意，输出的顺序和三元组的顺序并不重要。

提示：

- 3 &lt;= nums.length &lt;= 3000
- -10^5^ &lt;= nums[i].length &lt;= 10^5^

## 题解

### 暴力枚举

可以使用三个循环遍历三次数组中的每个值，枚举出所有的和为零的三个数。

由于不能返回重复的三个数，因此需要对数组先做排序处理，这样在遍历时，一样的数只需要枚举一次即可。

``` csharp
public static IList<IList<int>> ThreeSum(int[] nums)
{
    List<IList<int>> rel = new List<IList<int>>();
    int length = nums.Length;
    // 排序
    Array.Sort(nums);
    // 枚举第一个数
    for (int first = 0; first < length; first++)
    {
        // 枚举的数不同时才进行下一次枚举
        if (first > 0 && nums[first] == nums[first - 1])
            continue;
        int target = -nums[first];
        // 枚举第二个数
        for (int second = first + 1; second < length; second++)
        {
            // 相同的数不在枚举
            if (second > first + 1 && nums[second] == nums[second - 1])
                continue;
            // 枚举第三个数
            for (int third = second + 1; third < length; third++)
            {
                // 同样地，不枚举相同的数
                if (third > second + 1 && nums[third] == nums[third - 1])
                    continue;
                // 判断三数和是否为目标值
                if (nums[second] + nums[third] == target)
                {
                    List<int> turple = new List<int>() { nums[first], nums[second], nums[third] };
                    rel.Add(turple);
                }
            }
        }
    }
    return rel;
}
```

时间复杂度：排序的时间复杂度可以为O(n)或O(logn)，n为数组长度，三个循环遍历用时为O(n^3^)，所以时间复杂度为O(n^3^)。

空间复杂度：对数组使用了排序，可以看做是使用额外是数组存储了排序后的数组，因此空间复杂度为O(n)。

### 双指针

在上述方法中，第二个数和第三个数有关系：nums[second]+nums[third] = nums[first]。当nums[second]增加时，nums[third]势必要减少。对于有序数组，当枚举下一个nums[second]时，nums[third]不能大于上一轮枚举中的值。因此，可以在枚举第二个数时，同步缩小第三个数的枚举范围，即使用双指针，左指针从头开始枚举nums[second]，右指针数组末尾枚举nums[third]，每枚举一个nums[second]，都缩小若干个third。

``` csharp
public static IList<IList<int>> ThreeSum(int[] nums)
{
    List<IList<int>> rel = new List<IList<int>>();
    int length = nums.Length;
    // 排序
    Array.Sort(nums);
    // 枚举第一个数
    for (int first = 0; first < length; first++)
    {
        // 枚举的数不同时才进行下一次枚举
        if (first > 0 && nums[first] == nums[first - 1])
            continue;
        int target = -nums[first];
        // 指示第三个数的左指针
        int third = length - 1;
        // 枚举第二个数
        for (int second = first + 1; second < length; second++)
        {
            // 相同的数不在枚举
            if (second > first + 1 && nums[second] == nums[second - 1])
                continue;
            // 枚举第三个数
            while (second < third && nums[second] + nums[third] > target)
            {
                third--;
            }
            // 如果第三个数和第二个数是同一个不成立
            if (second == third)
                break;
            // 判断三数和是否为目标值
            if (nums[second] + nums[third] == target)
            {
                List<int> turple = new List<int>() { nums[first], nums[second], nums[third] };
                rel.Add(turple);
            }
        }
    }
    return rel;
}
```

时间复杂度：同样地，排序的时间复杂度可以为O(n)或O(logn)，n为数组长度，两个循环遍历用时为O(n^2^)，所以时间复杂度为O(n^2^)。

空间复杂度：对数组使用了排序，可以看做是使用额外是数组存储了排序后的数组，因此空间复杂度为O(n)。