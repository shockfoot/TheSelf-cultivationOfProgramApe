# LC0002两数相加

难度：中等
数据结构：链表
算法：暴力枚举、递归

## 题目

给定两个**非空**链表，表示两个非负整数。它们每位数字都是按照**逆序**的方式存储，并且每个结点只能存储**一位**数字。

``` csharp
/// <summary>
/// 单链表结点
/// </summary>
public class ListNode<T>
{
    public T val;
    public ListNode<T> next;
    public ListNode(T val = default(T), ListNode<T> next = null)
    {
        this.val = val;
        this.next = next;
    }
}
```

请将两个数相加，并以相同形式返回一个表示和的链表。

可以假设除了数字0以外，这两个数都不会以0开头。

示例：

> 输入：l1 = [9, 9, 9, 9, 9, 0, 9]，l2 = [9, 9, 9]
> 输出：[8, 9, 9, 0, 0, 1, 9]
> 解释：9099999 + 999 = 9100998

提示：

- 每个链表中的结点数在范围[1, 100]内
- 0 <= Node.val <= 9
- 题目数据保证列表表示的数字不含前导0

## 题解

因为链表所表示的数字是逆序的，所以遍历链表是按个、十、百......的顺序遍历数字，因此两个链表相同位置的数字可以直接相加。

### 暴力枚举

创建一个结果链表，然后遍历输入的两个链表，逐结点计算每位的和sum，并和当前位的进位值carry相加，则结果链表中相应位的数字为(sum + carry) % 10，下一位的进位值为(sum + carry) / 10。

如果两个链表长度不同，则可认为短链表的后面有若干个0。

另外，注意遍历结束后检查是否需要下一位的进位。

``` csharp
public ListNode<int> AddTwoNumbers(ListNode<int> l1, ListNode<int> l2)
{
    int sum = 0;
    // 哨兵
    ListNode<int> dummy = new ListNode<int>(), cur = dummy;
    while (l1 != null || l2 != null || sum > 0)
    {
        if (l1 != null)
        {
            sum += l1.val;
        }
        if (l2 != null)
        {
            sum += l2.val;
        }
        cur.next = new ListNode<int>(sum % 10);
        cur = cur.next;
        sum /= 10;
        if (l1 != null)
        {
            l1 = l1.next;
        }
        if (l2 != null)
        {
            l2 = l2.next;
        }
    }

    return dummy.next;
}
```

需要注意的是，此处为了方便对结果链表进行统一的操作（在第一次循环时无法往空链表中添加新的结点），为结果链表设置了一个头结点。头结点不存储数据。返回结果为头结点的后继。

时间复杂度：需要完整遍历两个链表，因此时间复杂度为O(n)，n为两个链表长度的最大值。

空间复杂度：返回值不计入空间复杂度，整个过程只使用两个临时变量，因此空间复杂度为O(1)。

### 递归

链表是非常适合使用递归的数据结构之一。此题中，两个链表上每个结点的操作都非常相似，即计算两个链表上相同位置结点值与进位值的和，因此只需要得到前一位的进位值、处理完当前位并向下一位传递进位值即可。

``` csharp
public ListNode<int> AddTwoNumbers(ListNode<int> l1, ListNode<int> l2)
{
    return AddTwoNumbers(l1, l2, 0);
}

private ListNode<int> AddTwoNumbers(ListNode<int> l1, ListNode<int> l2, int carry)
{
    // 两个链表都为空时结束递归
    if (l1 == null && l2 == null)
    {
        // 判断是否仍需要进位
        return carry > 0 ? new ListNode<int>(carry) : null;
    }

    // 当l1为null时l2必不为null，交换两个表，简化代码
    if (l1 == null)
    {
        l1 = l2;
        l2 = null;
    }

    // 处理当前值并向下一位传递
    carry += l1.val + (l2 == null ? 0 : l2.val);
    l1.val = carry % 10;
    l1.next = AddTwoNumbers(l1.next, l2 == null ? null : l2.next, carry / 10);

    return l1;
}
```

时间复杂度：需要完整遍历两个链表，因此时间复杂度为O(n)，n为两个链表长度的最大值。

空间复杂度：空间复杂度为O(n)，是递归使用的栈空间开销。