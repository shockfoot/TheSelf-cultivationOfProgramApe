# 0014最长公共前缀

难度：简单
数据结构：字符串
算法：暴力枚举、分治

## 题目

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串""。

示例：

> 输入：strs = ["flower","flow","flight"]
> 输出："fl"

提示：

- 1 &lt;= strs.length &lt;= 200
- 0 &lt;= strs[i].length &lt;= 200
- strs[i]仅由小写英文字母组成。

## 题解

### 暴力枚举

依次遍历字符串数组中的每个字符串，对于每个字符串，更新最长公共前缀。在遍历过程中，如果最长公共前缀已经是空""，可以提前返回。

``` csharp
public string LongestCommonPrefix(string[] strs)
{
    if (strs == null || strs.Length == 0) return string.Empty;

    string rel = strs[0];
    // 依次遍历每个字符串
    for (int i = 1; i < strs.Length; i++)
    {
        rel = LongestCommonPerfix(rel, strs[i]);
        if (rel.Length == 0) break;
    }
    return rel;
}

/// <summary>
/// 获取两字符串的最长公共前缀
/// </summary>
public string LongestCommonPerfix(string str1, string str2)
{
    int length = Math.Min(str1.Length, str2.Length);
    int index = 0;
    while (index < length && str1[index] == str2[index])
    {
        index++;
    }
    return str1.Substring(0, index);
}
```

类似地可以纵向遍历所有字符串的每一字符，比较相同列上的字符是否相同，如果相同则继续比较下一个，否则当前字符之前的部分为最长公共前缀。

``` csharp
public string LongestCommonPrefix(string[] strs)
{
    if (strs == null || strs.Length == 0) return string.Empty;

    int count = strs.Length, length = strs[0].Length;
    // 遍历每列
    for (int i = 0; i < length; i++)
    {
        char c = strs[0][i];
        // 遍历每个字符串的当前列
        for (int j = 0; j < count; j++)
        {
            if (j == strs[j].Length || strs[j][i] != c)
            {
                return strs[0].Substring(0, i);
            }
        }
    }
    return strs[0];
}
```

时间复杂度：最好情况下，遍历每个字符串，每个字符串都比较1此，时间复杂度为O(n)，n为字符串数组长度；最坏情况下，每个字符串的每个字符都要比较，因此时间复杂度为O(mn)，m为字符串的平均长度。

空间复杂度：空间复杂度为O(1)。

### 分治

用LCP(s~1~...s~n~)表示字符串s~1~到s~n~的最长公共前缀，则有：LCP(s~1~...s~n~) = LCP(LCP(LCP(s~1~...s~2~), s~3~),... s~n~)。

LCP的计算满足结合律：LCP(s~1~...s~n~) = LCP(LCP(s~1~...s~k~), LCP(s~k+1~...s~n~))，1 &lt; k &lt; n。

以上，可以使用分治法将LCP(s~1~...s~n~)分解成两个子问题LCP(s~1~...s~k~)与LCP(s~k+1~...s~n~)，并对子问题分别求解，然后对两个子问题的解计算LCP，即为原问题的解。

``` csharp
public string LongestCommonPrefix(string[] strs)
{
    if (strs == null || strs.Length == 0) return string.Empty;
    return LongestCommonPerfix(strs, 0, strs.Length - 1);
}

public string LongestCommonPerfix(string[] strs, int start, int end)
{
    if (start == end) return strs[start];

    int mid = start + (end - start) / 2;
    // 从中间将字符串数组分成两个子数组
    string left = LongestCommonPerfix(strs, start, mid);
    string right = LongestCommonPerfix(strs, mid + 1, end);
    // 计算两个子数组的最长公共前缀
    return LongestCommonPerfix(left, right);
}
```

时间复杂度：时间复杂度为O(mn)。

空间复杂度：主要用于递归的开销，递归层数为logn，每层需要m的空间存储返回结果，因此空间复杂度为O(mlogn)。
