# LC3272统计好整数的数目

难度：困难
数据结构：
算法：暴力枚举

## 题目

如果一个整数x满足以下条件，那么它被称为k回文整数。

- x是一个**回文整数**（如果一个数从前和从后读相同，则为回文）。
- x能被k整除。

如果一个整数的数位重新排列后能得到一个k回文整数，那么称这个整数为**好整数**。比方说，k = 2，那么2020可以重新排列得到2002，2002是一个k回文串，所以2020是一个好整数。而1010无法重新排列数位得到一个k回文整数。

给定两个正整数n和k。请返回n个数位的整数中，有多少个好整数。

注意，任何整数在重新排列数位之前或者之后都不能有前导0。比方说1010不能重排列得到101。

示例：

> 输入：n = 3, k = 5
> 输出：27

> 输入：n = 1, k = 4
> 输出：2
> 解释：两个好整数分别是4和8。

提示：

- 1 <= n <= 10
- 1 <= k <= 9

## 题解

### 暴力枚举

n位数的范围为[10^n - 1^, 10^n^)。根据回文整数的定义，回文整数的左半边顺序与右半边倒序相同，如果知道了左半边的数字，就可以确定右半边的数字，因此：

- 如果n为偶数：则回文整数的左半边n / 2位的正序与右半边n / 2位的逆序相同。左半边n / 2位的取值范围为[10^n / 2 - 1^, 10^n / 2^)，共10^n / 2^ - 10^n / 2 - 1^个数。
- 如果n为奇数：则回文整数的左半边(n - 1) / 2位的正序与右半边(n - 1) / 2位的逆序相同，中间第(n + 1) / 2位的取值范围为[0, 9]。左半边(n + 1) / 2位的取值范围为[10^(n + 1) / 2 - 1^, 10^(n + 1) / 2^)，共10^(n + 1) / 2^ - 10^(n - 1) / 2^个数。

根据以上推论可知长度为n时，一共存在10^[(n + 1) / 2]^ - 10^[(n - 1) / 2]^个回文整数。题目给定的n的取值范围为[1, 10]，最多存在不超过10^5^个不同的k回文数，因此可以枚举找到所有的k回文整数。

设m = [(n - 1) / 2]，base = 10^m^。直接枚举回文整数的左半边，其取值范围在[base, 10 x base)，即可生成长度为n的回文整数。此时如果该回文整数能被k整除，则该回文整数为k回文整数。

根据定义，如果一个整数的数位重新排列后能得到一个k回文整数，则该整数为好整数，即如果一个整数与k回文整数具有相同的数字构成且不含前导0则该整数为好整数，题目要求找到所有长度为n的好整数的数目。由于已经找到所有合法的k回文整数，此时问题转换为求给定字符串的不同排列组合数目。

在计算时由于不同的k回文整数可能由相同的数位字符组成，此时为了避免重复计算，可以将每个回文整数构成的字符串进行规则化，可将字符串按照字典序进行排序，这样即可保证相同的数位字符的唯一性。

接下来考虑排列组合的问题，由于相同的字符可能出现多次，即需要考虑**多重组合数**。假设给定的长度为n的字符串中'0'到'9'出现的次数分别为c^0^、c^1^、...、c^9^。如不考虑前导0的前提下，此时可以组成的排列数为：n! / (c~i~!)，i属于[0, 9]。

在考虑不能有前导0的情况下，此时首先需要从n个字符中选择一个不为'0'的字符放在首位，一共有n - c^0^个不为'0'的字符。剩余的n − 1个字符可任意排列，一共有(n − 1)!种组合方案，此时在不考虑重复元素的情况下组合方案数为：(n − c^0^)(n −1 )!。由于部分元素存在重复，此时需要除以重复元素的排列组合，此时组合方案数即为：(n − c^0^)(n −1 )! / (c~i~!)，i属于[0, 9]。

枚举记录的无重复的字符串s，并统计s中字符'0'到'9'出现的数目，并存储在数组cnt中，根据cnt按照排列组合计算出s可以构成的不同组合的方案数目，即s可以构成的好整数的数目，此时累加到结果ans中，返回最终结果即可。

``` csharp
public long CountGoodIntegers(int n, int k)
{
    HashSet<string> set = new HashSet<string>();
    
    int low = (int)Math.Pow(10, (n - 1) / 2);
    int high = low * 10;
    int skip = n & 1;

    // 枚举k回文整数
    for (int i = low; i < high; i++)
    {
        string s = i.ToString();
        s += new string(s.Reverse().Skip(skip).ToArray());
        long palindromicInteger = long.Parse(s);
        if (palindromicInteger % k == 0)
        {
            char[] chars = s.ToCharArray();
            Array.Sort(chars);
            set.Add(new string(chars));
        }
    }

    long[] factorial = new long[n + 1];
    factorial[0] = 1;
    for (int i = 1; i <= n; i++)
    {
        factorial[i] = factorial[i - 1] * i;
    }

    long ans = 0;
    foreach (var s in set)
    {
        // 各数字出现次数
        int[] count = new int[10];
        foreach (var c in s)
        {
            count[c - '0']++;
        }

        // 计算排列组合
        long tot = (n - count[0]) * factorial[n - 1];
        foreach (var c in count)
        {
            tot /= factorial[c];
        }

        ans += tot;
    }

    return ans;
}
```

时间复杂度：O(nlogn x 10^m^)，其中n表示给定的数字，m = [(n - 1) / 2]。由于最多有10^m^个k回文数，此时枚举所有的k回文数需要的时间为O(10^m^)，每个k回文数有n个数位，需要对n个数位进行排序，排序需要的时间为O(nlogn)，计算n个阶乘需要的时间为O(n)，因此总的时间复杂度为OO(nlogn x 10^m^)。

空间复杂度：O(n x 10^m^)。需要枚举所有可能的k回文数，最多有10^m^个k回文数，每个回文数有n个数位，在哈希表中存储需要的空间为O(n)。