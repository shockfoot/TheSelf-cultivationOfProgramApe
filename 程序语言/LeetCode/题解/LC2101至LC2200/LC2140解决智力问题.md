# LC2140解决智力问题

难度：中等
数据结构：数组
算法：动态规划

## 题目

给定一个下标从0开始的二维整数数组questions，其中questions[i] = [points~i~, brainpower~i~]。

这个数组表示一场考试里的一系列题目，需要**按顺序**（也就是从问题0开始依次解决），针对每个问题选择**解决**或者**跳过**操作。解决问题i将获得points~i~的分数，但是将**无法**解决接下来的brainpower~i~个问题（即只能跳过接下来的brainpower~i~个问题）。如果跳过问题i，则可以对下一个问题决定使用哪种操作。

- 比方说，给定`questions = [ [3, 2], [4, 3], [4, 4], [2, 5] ]`：
- - 如果问题0被解决了， 那么可以获得3分，但不能解决问题1和2。
- - 如果跳过问题0，且解决问题1，将获得4分但是不能解决问题2和3。

请返回这场考试里能获得的**最高**分数。

示例：

> 输入：questions = [ [3, 2], [4, 3], [4, 4], [2, 5] ]
> 输出：5
> 解释：解决问题0和3得到最高分。解决问题0：获得3分，但接下来2个问题都不能解决。不能解决问题1和2，解决问题3获得2分，总得分为：3 + 2 = 5。没有别的办法获得5分或者多于5分。

提示：

- 1 <= questions.length <= 10^5^
- questions[i].length == 2
- 1 <= points~i~, brainpower~i~ <= 10^5^

## 题解

### 动态规划

一看到这个题目，就在想是否可以用贪心算法，即在解决当前问题时，判断后面将要跳过的方法中是否有分数比当前问题更高的。如果没有，则解决当前问题，否则跳过当前问题。在写代码途中发现，每个问题的决定会影响下一个问题的决定，即每个问题的决定之间不是独立的，所以无法使用贪心算法。

以上，此题应当使用动态规划来解决。

用dp[i]表示解决前i道题可以获得的最高分数。根据是否可以解决第i道题可以分为以下情况：

- 不解决：dp[i] = dp[i - 1]。
- 解决：dp[i] = points[i] + max(0, max dp[j])，j属于[0, i − 1]且j + brainpower[j] < i，即判断第i道题是否可以解决。
​
所以dp[i]的状态转移方程为dp[i] = max(dp[i - 1], points[i] + max(0, max dp[j]))，j属于[0, i − 1]且j + brainpower[j] < i。

此外，可以从**无后效性**考虑。对于每道题目，解决与否会**影响后面**一定数量题目的结果，但**不会影响前面**题目的解决，因此可以考虑从反方向定义状态，即考虑解决每道题本身及以后的题目可以获得的最高分数。

此时，仍用dp[i]表示解**第i道题及以后的题目**可以获得的最高分数。根据是否解决第i道题目可以分为以下情况：

- 不解决第i道题目：dp[i] = dp[i + 1]。
- 解决第i道题目：只能解决下标大于i + brainpower[i]的题目，因此解决这些题目的最高分数为dp[i + brainpower[i] + 1]（当i > n的情况下，dp[i] = 0），所以dp[i] = points[i] + dp[i + brainpower[i] + 1]。

所以dp[i]的状态转移方程为dp[i] = max(dp[i + 1], points[i] + dp[i + brainpower[i] + 1])。

在实际计算中，考虑到i > n的边界条件，可以在定义dp数组时预留dp[n] = 0以表示未解决任何题目。则上述状态转移方程可变为dp[i] = max(dp[i + 1], points[i] + dp[min(n, i + brainpower[i] + 1)])。

最终，dp[0]即为考试中可以获得的最高分数。

``` csharp
public long MostPoints(int[][] questions)
{
    if (questions == null || questions.Length <= 0)
    {
        return 0;
    }

    if (questions.Length == 1)
    {
        return questions[0][0];
    }

    int length = questions.Length;
    long[] dp = new long[length + 1];
    for (int i = length - 1; i >= 0; i--)
    {
        dp[i] = Common.Math.Max(dp[i + 1],questions[i][0] + dp[Common.Math.Mi(length, i + questions[i][1] + 1)]);
    }

    return dp[0];
}
```

时间复杂度：需要遍历整个数组，因此时间复杂度为O(n)，n为数组长度。

空间复杂度：需要存储动态规划数组，所以空间复杂度为O(n)。