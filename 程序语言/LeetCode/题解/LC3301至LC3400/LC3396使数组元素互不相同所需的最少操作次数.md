# LC3396使数组元素互不相同所需的最少操作次数

难度：简单
数据结构：数组
算法：暴力枚举、递归

## 题目

给定一个整数数组nums，需要确保数组中的元素**互不相同**。为此，可以执行以下操作任意次：

- 从数组的开头移除3个元素。如果数组中元素少于3个，则移除所有剩余元素。

返回使数组元素互不相同所需的**最少操作次数**。

> 注意：空数组也视作为数组元素互不相同。

示例：

> 输入：nums = [1,2,3,4,2,3,3,5,7]
> 输出：2
> 解释：
> - 第一次操作：移除前3个元素，数组变为[4, 2, 3, 3, 5, 7]。
> - 第二次操作：再次移除前3个元素，数组变为[3, 5, 7]，此时数组中的元素互不相同。

提示：

- 1 <= nums.length <= 100
- 1 <= nums[i] <= 100

## 题解

### 暴力枚举

先判断数组是否元素互不相同，如果是，则直接返回0，否则进行一次移除操作，并继续判断数组是否元素互不相同。

``` csharp
public int MinimumOperations(int[] nums)
{
    if (nums is not { Length: > 1 })
    {
        return 0;
    }

    int times = 0, n = nums.Length;
    for (int i = 0; i < n; i += 3)
    {
        if (CheckUnique(nums, i))
        {
            return times;
        }

        times++;
    }

    return times;
}

private bool CheckUnique(int[] nums, int start)
{
    int n = nums.Length;
    HashSet<int> set = new HashSet<int>(n - start);
    for (int i = start; i < n; i++)
    {
        if (!set.Add(nums[i]))
        {
            return false;
        }
    }

    return true;
}
```

时间复杂度：时间复杂度为O(n^2^)，n为数组长度。

空间复杂度：需要用哈希表记录已经出现的元素，空间复杂度为O(n)。

### 递归

原理同暴力枚举。

``` csharp
public int MinimumOperations(int[] nums)
{
    return RemoveAndCheck(nums, 0);
}

private int RemoveAndCheck(int[] nums, int times)
{
    if (nums is not { Length: > 1 })
    {
        return times;
    }

    int n = nums.Length;
    if (n - times * 3 <= 0)
    {
        return times;
    }

    int start = times * 3;
    if (n - start <= 0)
    {
        return times;
    }
        
    HashSet<int> set = new HashSet<int>(n - start);
    bool isUnique = true;
    for (int i = start; i < n; i++)
    {
        if (!set.Add(nums[i]))
        {
            isUnique = false;
            break;
        }
    }

    return isUnique ? times : RemoveAndCheck(nums, ++times);
}
```

时间复杂度：时间复杂度为O(n^2^)，n为数组长度。

空间复杂度：需要用哈希表记录已经出现的元素，空间复杂度为O(n)。

### 倒序遍历

从后往前遍历数组，确定互不相同元素的个数，然后根据数组元素总数确定需要进行多少次操作。

``` csharp
public int MinimumOperations(int[] nums)
{
    if (nums is not { Length: > 1 })
    {
        return 0;
    }

    int n = nums.Length;
    HashSet<int> set = new HashSet<int>(n);
    for (int i = n - 1; i >= 0; i--)
    {
        if (!set.Add(nums[i]))
        {
            return i / 3 + 1;
        }
    }

    return 0;
}
```

时间复杂度：只需要遍历一遍数组，因此时间复杂度为O(n)，n为数组长度。

空间复杂度：需要用哈希表记录已经出现的元素，空间复杂度为O(n)。