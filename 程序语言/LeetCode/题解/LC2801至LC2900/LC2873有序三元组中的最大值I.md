# LC2873有序三元组中的最大值I

难度：简单
数据结构：数组
算法：暴力枚举、贪心算法

## 题目

给定一个下标从0开始的整数数组nums。请从所有满足i < j < k的下标三元组(i, j, k)中，找出并返回下标三元组的最大值。如果所有满足条件的三元组的值都是负数，则返回0。

下标三元组(i, j, k)的值等于(nums[i] - nums[j]) * nums[k]。

示例：

> 输入：nums = [12,6,1,2,7]
> 输出：77
> 解释：下标三元组(0, 2, 4)的值是(nums[0] - nums[2]) * nums[4] = 77。

提示：

- 1 <= nums.length <= 100
- 1 <= nums[i] <= 10^6^

## 题解

### 暴力枚举

对每个下标三元组进行枚举，返回最大值。

``` csharp
public long MaximumTripletValue(int[] nums)
{
    if (nums is not { Length: > 2 })
    {
        return 0;
    }

    if (nums.Length == 3)
    {
        return Common.Math.Max(0L, GetTripletValu(nums, 0, 1, 2));
    }

    long maxValue = 0;

    for (int k = nums.Length - 1; k >= 2; k--)
    {
        for (int j = k - 1; j >= 1; j--)
        {
            for (int i = j - 1; i >= 0; i--)
            {
                maxValue = Common.Math.Ma(maxValue, GetTripletValue(nums,i, j, k));
            }
        }
    }
        
    return maxValue;
}
    
private long GetTripletValue(int[] nums, int i, int j, int k)
{
    return GetTripletValue(nums[i], nums[j], nums[k]);
}

private long GetTripletValue(int i, int j, int k)
{
    return 1L * (i - j) * k;
}
```

时间复杂度：需要遍历三遍数组，因此时间复杂度为O(n^3^)，n为数组长度。

空间复杂度：空间复杂度为O(1)。

### 贪心算法一

根据下标三元组计算公式，当j和k固定时，nums[i]越大，下标三元组的值越大。因此，可以在遍历j的同时，记录最大的nums[i]即可。

``` csharp
public long MaximumTripletValue(int[] nums)
{
    if (nums is not { Length: > 2 })
    {
        return 0;
    }

    if (nums.Length == 3)
    {
        return Common.Math.Max(0L, GetTripletValue(nums, 0, 1, 2));
    }

    long maxValue = 0;
    int maxIIndex, n = nums.Length;

    for (int k = 2; k < n; k++)
    {
        maxIIndex = 0;
        for (int j = 1; j < k; j++)
        {
            maxValue = Common.Math.Max(maxValue, GetTripletValue(nums, maxIIndex, j, k));
            if (nums[maxIIndex] < nums[j])
            {
                maxIIndex = j;
            }
        }
    }
        
    return maxValue;
}
```

时间复杂度：需要遍历两遍数组，因此时间复杂度为O(n^2^)，n为字符串长度。

空间复杂度：空间复杂度为O(1)。

### 贪心算法二

类型上述分析，当j固定时，nums[i]和nums[k]越大，下标三元组的值越大。因此，可以先维护两个左端数组和右端数组，以便在遍历j时计算下标三元组的最大值。

``` csharp
public long MaximumTripletValue(int[] nums)
{
    if (nums is not { Length: > 2 })
    {
        return 0;
    }

    if (nums.Length == 3)
    {
        return Common.Math.Max(0L, GetTripletValue(nums, 0, 1, 2));
    }

    int n = nums.Length;
    int[] leftMax = new int[n], rightMax = new int[n];
    for (int j = 1; j < n; j++)
    {
        leftMax[j] = Common.Math.Max(leftMax[j - 1], nums[j - 1]);
        rightMax[n - j - 1] = Common.Math.Max(rightMax[n - j], nums[n - j]);
    }
        
    long maxValue = 0;
    for (int j = 0; j < n; j++)
    {
        maxValue = Common.Math.Max(maxValue, GetTripletValue(leftMax[j], nums[j], rightMax[j]));
    }
    return maxValue;
}
```

时间复杂度：需要遍历整个数组，因此时间复杂度为O(n)，n为字符串长度。

空间复杂度：空间复杂度为O(1)。

### 贪心算法三

类型上述分析，当k固定时，nums[i] - nums[j]越大，下标三元组的值越大。因此，可以在遍历k时维护最大的nums[i]和最大的nums[i] - nums[j]。

``` csharp
public long MaximumTripletValue(int[] nums)
{
    if (nums is not { Length: > 2 })
    {
        return 0;
    }

    if (nums.Length == 3)
    {
        return Common.Math.Max(0L, GetTripletValue(nums, 0, 1, 2));
    }

    int n = nums.Length;

    long maxValue = 0, maxNumsI = 0, maxNumsIMinusJ = 0;
    for (int k = 0; k < n; k++)
    {
        maxValue = Common.Math.Max(maxValue, maxNumsIMinusJ * nums[k]);
        maxNumsIMinusJ = Common.Math.Max(maxNumsIMinusJ, maxNumsI - nums[k]);
        maxNumsI = Common.Math.Max(maxNumsI, nums[k]);
    }
        
    return maxValue;
}
```

时间复杂度：需要遍历整个数组，因此时间复杂度为O(n)，n为字符串长度。

空间复杂度：空间复杂度为O(1)。