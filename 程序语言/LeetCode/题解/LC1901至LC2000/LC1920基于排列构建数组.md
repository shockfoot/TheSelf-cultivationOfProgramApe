# LC1920基于排列构建数组

难度：简单
数据结构：数组
算法：暴力枚举、位运算

## 题目

给定一个从0开始的排列nums（下标也从0开始）。请构建一个**同样长度**的数组ans，其中，对于每个i（0 <= i < nums.length），都满足ans[i] = nums[nums[i]]。返回构建好的数组ans。

从0开始的排列nums是一个由0到nums.length - 1（0和nums.length - 1也包含在内）的不同整数组成的数组。

示例：

> 输入：nums = [0,2,1,5,3,4]
> 输出：[0,1,2,4,5,3]

提示：

- 1 <= nums.length <= 1000
- 0 <= digits[i] < nums.length
- nums中的元素互不相同

## 题解

### 暴力枚举

创建一个和nums等长的数组，遍历nums并依次填充元素。

``` csharp
public int[] BuildArray(int[] nums)
{
    if (nums is not { Length: > 1 })
    {
        return nums;
    }

    int n = nums.Length;
    int[] result = new int[n];
    for (int i = 0; i < n; i++)
    {
        result[i] = nums[nums[i]];
    }

    return result;
}
```

时间复杂度：只需要遍历一遍数组，时间复杂度为O(n)，n为数组长度。

空间复杂度：空间复杂度为O(n)。

### 位运算

由题可知，不断迭代i，最终一定会回到起点i。因此，在每次迭代i时对元素进行“搬家”，如果要在原数组中操作，需要标记元素是否已经“搬家”。由于nums中元素都是非负数，因此可以用负数标记元素是否已经“搬家”。

由于nums中可能存在0，因此需要对元素加1后取相反数。

根据补码的定义，有-x = (~x) + 1。

所以有：-(x + 1) = -x - 1 = (~x) + 1 - 1 = ~x。所以对已经“搬家”过的元素取反即可。

操作结束后，对所有元素再取反复原即可。

``` csharp
public int[] BuildArray(int[] nums)
{
    if (nums is not { Length: > 1 })
    {
        return nums;
    }

    int n = nums.Length;
    for (int i = 0; i < n; i++)
    {
        if (nums[i] < 0)
        {
            continue;
        }

        int x = nums[i];
        int cur = i;
        while(nums[cur] != i)
        {
            int next = nums[cur];
            nums[cur] = ~nums[next];
            cur = next;
        }
        nums[cur] = ~x;
    }

    for (int i = 0; i < n; i++)
    {
        nums[i] = ~nums[i];
    }

    return nums;
}
```

时间复杂度：时间复杂度为O(n)，n为数组长度。

空间复杂度：空间复杂度为O(1)。