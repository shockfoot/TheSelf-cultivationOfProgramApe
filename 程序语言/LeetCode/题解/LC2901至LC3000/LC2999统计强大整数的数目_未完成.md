# LC2999统计强大整数的数目

难度：简单
数据结构：数组
算法：暴力枚举、贪心算法

## 题目

给定三个整数start、finish和limit，以及一个表示**正**整数的下标从0开始的字符串s。

如果一个正整数x末尾部分是s（即s是x的后缀），且x中的每个数位不大于limit，那么可称x是**强大的**。

请返回区间[start..finish]内强大整数的个数。

示例：

> 输入：start = 1, finish = 6000, limit = 4, s = "124"
> 输出：5
> 解释：区间[1..6000]内的强大数字有124、1124、2124、3124和4124。这些整数的各个数位都<= 4且"124"是它们的后缀。这个区间内总共只有这5个强大整数。

> 输入：start = 1000, finish = 2000, limit = 4, s = "3000"
> 输出：0
> 解释：区间[1000..2000]内的整数都小于3000，所以"3000"不可能是这个区间内任何整数的后缀。

提示：

- 1 <= start <= finish <= 10^15^
- 1 <= limit <= 9
- 1 <= s.length <= floor(log~10~(finish)) + 1
- s中每个数字都小于等于limit
- s不包含任何前导0

## 题解

### 暴力枚举

任何以s为后缀的正整数x都可以表示为：x = i * 10^s.length^ + (int)s。

由于s中每个数字都小于等于limit，因此只要i中的每个数字都小于等于limit，那么x就满足题目条件。

``` csharp
public long NumberOfPowerfulInt(long start, long finish, int limit, string s)
{
    int count = 0;
    
    long num = long.Parse(s);
    long power = (long)Math.Pow(10, s.Length);

    bool isStrong;
    long x, digit;
    for (int i = 0;; i++)
    {
        x = i * power + num;
        if (x < start)
        {
            continue;
        }

        if (x > finish)
        {
            break;
        }

        isStrong = true;
        while (x > 0)
        {
            digit = x % 10;
            if (digit > limit)
            {
                isStrong = false;
                break;
            }
            x /= 10;
        }

        if (isStrong)
        {
            count++;
        }
    }

    return count;
}
```

时间复杂度：时间复杂度为O(nm)，n为i的个数，m为i的位数。

空间复杂度：空间复杂度为O(1)。

### 动态规划

暴力枚举对于范围很大的区间，不但会超时，还会进行很多不必要的枚举。实际上，只需要判断有多少个满足题目的i以使x在范围区间即可。

定义dp[i]表示第i位及其之后数位所能够组成满足条件的数字数量。

``` csharp
public long MaximumTripletValue(int[] nums)
{
    if (nums is not { Length: > 2 })
    {
        return 0;
    }

    if (nums.Length == 3)
    {
        return Common.Math.Max(0L, GetTripletValue(nums, 0, 1, 2));
    }

    long maxValue = 0;
    int maxIIndex, n = nums.Length;

    for (int k = 2; k < n; k++)
    {
        maxIIndex = 0;
        for (int j = 1; j < k; j++)
        {
            maxValue = Common.Math.Max(maxValue, GetTripletValue(nums, maxIIndex, j, k));
            if (nums[maxIIndex] < nums[j])
            {
                maxIIndex = j;
            }
        }
    }
        
    return maxValue;
}
```

时间复杂度：需要遍历两遍数组，因此时间复杂度为O(n^2^)，n为字符串长度。

空间复杂度：空间复杂度为O(1)。

### 贪心算法二

类型上述分析，当j固定时，nums[i]和nums[k]越大，下标三元组的值越大。因此，可以先维护两个左端数组和右端数组，以便在遍历j时计算下标三元组的最大值。

``` csharp
public long MaximumTripletValue(int[] nums)
{
    if (nums is not { Length: > 2 })
    {
        return 0;
    }

    if (nums.Length == 3)
    {
        return Common.Math.Max(0L, GetTripletValue(nums, 0, 1, 2));
    }

    int n = nums.Length;
    int[] leftMax = new int[n], rightMax = new int[n];
    for (int j = 1; j < n; j++)
    {
        leftMax[j] = Common.Math.Max(leftMax[j - 1], nums[j - 1]);
        rightMax[n - j - 1] = Common.Math.Max(rightMax[n - j], nums[n - j]);
    }
        
    long maxValue = 0;
    for (int j = 0; j < n; j++)
    {
        maxValue = Common.Math.Max(maxValue, GetTripletValue(leftMax[j], nums[j], rightMax[j]));
    }
    return maxValue;
}
```

时间复杂度：需要遍历整个数组，因此时间复杂度为O(n)，n为字符串长度。

空间复杂度：空间复杂度为O(1)。

### 贪心算法三

类型上述分析，当k固定时，nums[i] - nums[j]越大，下标三元组的值越大。因此，可以在遍历k时维护最大的nums[i]和最大的nums[i] - nums[j]。

``` csharp
public long MaximumTripletValue(int[] nums)
{
    if (nums is not { Length: > 2 })
    {
        return 0;
    }

    if (nums.Length == 3)
    {
        return Common.Math.Max(0L, GetTripletValue(nums, 0, 1, 2));
    }

    int n = nums.Length;

    long maxValue = 0, maxNumsI = 0, maxNumsIMinusJ = 0;
    for (int k = 0; k < n; k++)
    {
        maxValue = Common.Math.Max(maxValue, maxNumsIMinusJ * nums[k]);
        maxNumsIMinusJ = Common.Math.Max(maxNumsIMinusJ, maxNumsI - nums[k]);
        maxNumsI = Common.Math.Max(maxNumsI, nums[k]);
    }
        
    return maxValue;
}
```

时间复杂度：需要遍历整个数组，因此时间复杂度为O(n)，n为字符串长度。

空间复杂度：空间复杂度为O(1)。