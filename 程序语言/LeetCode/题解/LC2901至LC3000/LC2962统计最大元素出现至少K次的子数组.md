# LC2962统计最大元素出现至少K次的子数组

难度：中等
数据结构：数组
算法：暴力枚举、滑动窗口

## 题目

给定一个整数数组nums和一个正整数k。请统计有多少满足**nums中的最大元素至少出现k次的子数组**，并返回满足这一条件的子数组的数目。

> 子数组是数组中的一个连续非空部分。

示例：

> 输入：nums = [1,3,2,3,3], k = 2
> 输出：6
> 解释：包含元素3至少2次的子数组为：[1,3,2,3]、[1,3,2,3,3]、[3,2,3]、[3,2,3,3]、[2,3,3]和[3,3]。

提示：

- 1 <= nums.length <= 10^5^
- 1 <= nums[i], k <= 10^5^

## 题解

### 暴力枚举

用暴力枚举的方法，即双层循环枚举所有子数组。因为提示中数据量比较大，会超时。

``` csharp
public long CountSubarrays(int[] nums, int k)
{
    if (nums is not { Length: > 0 })
    {
        return 0;
    }

    int n = nums.Length;
    int max = nums[0];

    for (int i = 1; i < n; i++)
    {
        if (max < nums[i])
        {
            max = nums[i];
        }
    }

    long result = 0;
    int count = 0;
    for (int i = 0; i < n; i++)
    {
        count = 0;
        for (int j = i; j < n; j++)
        {
            if (nums[j] == max)
            {
                count++;
            }

            if (count >= k)
            {
                result++;
            }
        }
    }

    return result;
}
```

时间复杂度：时间复杂度为O(n^2^)，n为数组长度。

空间复杂度：空间复杂度为O(1)。

### 滑动窗口

使用滑动窗口在子数组的左右两个max之间滑动，更新子数组个数。

``` csharp
public long CountSubarrays(int[] nums, int k)
{
    if (nums is not { Length: > 0 })
    {
        return 0;
    }

    int n = nums.Length;
    int max = nums[0];

    for (int i = 1; i < n; i++)
    {
        if (max < nums[i])
        {
            max = nums[i];
        }
    }

    long result = 0;
    int count = 0;
    for (int left = 0, i = 0; i < n; i++)
    {
        if (nums[i] == max)
        {
            count++;
        }

        while (count == k)
        {
            if (nums[left] == max)
            {
                count--;
            }
            left++;
        }
        
        result += left;
    }

    return result;
}
```

时间复杂度：时间复杂度为O(n)，n为数组长度。

空间复杂度：空间复杂度为O(1)。