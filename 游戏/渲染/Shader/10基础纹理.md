纹理最初的目的是使用一张图片来控制模型的外观。使用纹理映射（Texture Mapping）技术，可以把一张图**逐纹素**（Texel）地控制模型表面颜色。

在建模的时，通常会利用**纹理展开技术**把**纹理映射坐标**（Texture-mapping Coordinates）存储在每个顶点上。纹理映射坐标定义了该顶点在纹理中对应的2D坐标。通常，这些坐标使用一个二维变量(u,v)来表示，其中u是横向坐标，而v是纵向坐标。因此，纹理映射坐标也被称为**UV坐标**。

顶点UV坐标的范围通常都被归一化到[0,1]范围内。需要注意的是，纹理采样时使用的纹理坐标不一定是在[0,1]范围内。实际上，不在[0,1]范围内的纹理坐标有时会非常有用。与之关系紧密的是纹理的平铺模式，它将决定渲染引擎在遇到不在[0,1]范围内的纹理坐标时如何进行纹理采样。

在OpenGL里，纹理空间的原点位于左下角，而DirectX中原点位于左上角。Unity在绝大多数情况下会自动处理差异问题。Unity使用的纹理空间是符合OpenGL的传统的，即原点位于左下角。

# 单张纹理

在Blinn-Phong光照模型中使用单张纹理来代替物体的漫反射颜色。

（1）声明需要使用的属性：主色调（控制物体整体颜色）、基础纹理、高光反射颜色以及光泽度。

``` CG
Properties
{
    _Color ("Color Tint", Color) = (1, 1, 1, 1)
    _MainTex ("Main Texture", 2D) = "white" {}
    _Specular ("Specular", Color) = (1, 1, 1, 1)
    _Gloss ("Gloss", Range(8.0, 256)) = 20
}
```

（2）设置Pass光照模式。

``` CG
Tags { "LightMode" = "ForwardBase" }
```

（3）在CG代码块中指明顶点着色器和片元着色器，引用内置文件。

``` CG
#pragma vertex vert
#pragma fragment frag

#include "Lighting.cginc"
```

（4）声明与属性相匹配的变量。其中，**需要为纹理类型的属性额外声明一个`float4`类型的变量，格式为`纹理名_ST`，以得到纹理的缩放（Scale）和平移（Translation），其中xy是缩放值，zw是偏移值。**

``` CG
fixed4 _Color;
sampler2D _MainTex;
float4 _MainTex_ST;
fixed4 _Specular;
float _Gloss;
```

（5）定义顶点着色器输入：计算光照通常需要法线，此外添加纹理后需要获取纹理坐标，因此顶点着色器输入中除了位置还定义了法线信息和第一组纹理坐标信息。

``` CG
struct a2v
{
    float4 vertex : POSITION;
    float3 normal : NORMAL;
    float4 texcoord : TEXCOORD0;
};
```

（6）定义顶点着色器输出：需要将顶点着色器处理好的顶点信息和转换得到的UV坐标传递给片元着色器。

``` CG
struct v2f
{
    float4 pos : SV_POSITION;
    float3 worldNormal : TEXCOORD0;
    float3 worldPos : TEXCOORD1; 
    float2 uv : TEXCOORD2;
};
```

（7）顶点着色器：获取世界空间下的顶点法线、顶点位置，将纹理坐标转换为UV坐标（通过`_MainTex_ST`对纹理坐标进行转换，也可以使用Unity内置宏`TRANSFORM_TEX`（传入顶点纹理坐标和纹理名，内部将纹理名拼接`_ST`进行转换））。

``` CG
v2f vert(a2v v)
{
    v2f o;
    o.pos = UnityObjectToClipPos(v.vertex);
    o.worldNormal = mul(v.normal, (float3x3)unity_WorldToObject);
    o.worldPos = mul(unity_ObjectToWorld, v.vertex);
    o.uv = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw; // o.uv = TRANSFORM_TEX(v.texcoord.xy, _MainTex);

    return o;
}
```

（8）片元着色器：利用UV坐标进行纹理采样，使用采样结果获取材质反射率，计算光照。

```CG
fixed4 frag(v2f i) : SV_Target
{
    fixed3 worldLight = normalize(UnityWorldSpaceLightDir(i.worldPos));
    fixed3 worldNormal = normalize(i.worldNormal);

    fixed3 aldedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;
                
    fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * aldedo;
    fixed3 diffuse = _LightColor0.rgb * aldedo * saturate(dot(worldNormal, worldLight));
                
    fixed3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));
    fixed3 helfDir = normalize(worldLight + viewDir);
    fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(saturate(dot(worldNormal, helfDir)), _Gloss);

    fixed3 color = ambient + diffuse + specular;

    return fixed4(color.r, color.g, color.b, 1.0);
}
```

（9）设置FallBack

```CG
FallBack "Specular"
```

# 纹理属性

- 纹理类型Texture Type：选择合适的类型以为Shader传递正确的纹理。
- 根据灰度值生成透明通道Alpha from Grayscale：勾选后，透明通道的值将由每个像素的灰度值生成。
- 平铺模式Wrap Mode：纹理坐标超出[0,1]后如何被平铺。Repeat模式是丢弃整数部分，用小数部分采样，即纹理重复；Clamp模式截取坐标到边界。
- 滤波模式Filter Mode：纹理由于变换产生拉伸时采用的滤波模式。Point、Bilinear、Trilinear得到的图片滤波效果依次提升但消耗的性能也依次增大。纹理滤波会影响放大或缩小纹理时得到的图片质量。
- 最大尺寸Max Size：如果导入的纹理大小超过了Max Size，Unity将会把该纹理缩放为这个最大分辨率。理想情况下，导入的纹理可以是非正方形的，但长宽的大小应该是2的幕。如果使用了非2的幕大小（Non Power of Two，NPOT）的纹理，那么这些纹理往往会占用更多的内存空间，而且GPU读取该纹理的速度也会有所下降。有些平台甚至不支持NPOT纹理，此时Unity在内部会把它缩放成最近的2的幕大小。出于性能和空间的考虑，应该尽量使用2的幕大小的纹理。
- 纹理模式Format：决定了Unity内部使用哪种格式来存储该纹理。
- 压缩模式Compression：此对于不需要使用很高精度的纹理（如用于漫反射颜色的纹理），应该尽量使用压缩格式。

纹理缩小比放大更复杂，此时纹理中的多个像素会对应一个目标像素。纹理缩小更加复杂的原因在于处理抗锯齿问题，一个最常使用的方法就是使用**多级渐远纹理**（Mipmapping）技术。其中"mip"是拉丁文"multum in parvo"的缩写，即“在一个小空间中有许多东西”。多级渐远纹理技术将原纹理提前用滤波处理来得到很多更小的图像，形成了一个图像金字塔，每一层都是对上一层图像降采样的结果。这样在实时运行时，就可以快速得到结果像素，例如当物体远离摄像机时，可以直接使用较小的纹理。但缺点是需要使用一定的空间用于存储这些多级渐远纹理，通常会多占用33%的内存空间。这是一种典型的用空间换取时间的方法。在Unity中，可以在纹理导入面板中勾选Generate Mip Maps开启多级渐远纹理技术。同时，还可以选择生成多级渐远纹理时是否使用线性空间（用于伽玛校正，）以及采用的滤波器等。

在内部实现上，Point模式使用了最近邻（Nearest Neighbor）滤波，在放大或缩小时，它的采样像素数目通常只有一个，因此图像会看起来有种像素风格的效果。而Bilinear滤波则使用了线性滤波，对于每个目标像素，它会找到4个邻近像素，然后对它们进行线性插值混合后得到最终像素，因此图像看起来像被模糊了。而Trilinear滤波几乎和Bilinear一样，只是Trilinear还会在多级渐远纹理之间进行混合。如果一张纹理没有使用多级渐远纹理技术，那么Trilinear得到的结果是和Bilinear就一样的。通常选择Bilinear滤波模式。需要注意的是，对于不希望纹理看起来是模糊的，例如对于一些类似棋盘的纹理，希望它就是像素风的，这时选择Point模式。