纹理的另一种常见的应用就是凹凸映射（Bump Mapping）。凹凸映射的目的是使用一张纹理来修改模型表面的法线，以便为模型提供更多的细节。这种方法不会真的改变模型的顶点位置，只是让模型看起来好像是“凹凸不平”的，但可以从模型的轮廓处看出“破绽”。

有两种主要的方法可以用来进行凹凸映射：一种方法是使用一张**高度纹理**（Height Map）模拟**表面位移**（Displacement），然后得到一个修改后的法线值，这种方法也被称为**高度映射**（Height
Mapping）；另一种方法则是使用一张**法线纹理**（Normal Map）来直接存储表面法线，这种方法被称为**法线映射**（Normal Mapping）。

# 高度纹理

高度图中存储的是强度值（Intensity），用于表示模型表面局部的海拔高度。颜色越浅表明该位置的表面越向凸起，而颜色越深表明该位置越向里凹。这种方法非常直观，可以从高度图中明确地知道一个模型表面的凹凸情况，但计算更加复杂，在实时计算时不能直接得到表面法线，而是由像素的灰度值计算而得，因此需要消耗更多的性能。

高度图通常会和法线映射一起使用，用于给出表面凹凸的额外信息，即使用法线映射来修改光照。

# 法线纹理

法线纹理中存储的是表面的法线方向。由于法线方向的分量范围在[-1,l]，而像素的分量范围为[O,1]，因此需要做一个映射：

> pixel = (normal + 1) / 2

这就要求在Shader中对法线纹理进行纹理采样后，还需要对结果进行一次反映射以得到原先的法线方向：

> normal = pixel * 2 - 1

由于方向是相对于坐标空间来说的，那么法线纹理中存储的法线方向在哪个坐标空间中呢？对于模型顶点自带的法线，它们是定义在模型空间中的，因此一种直接的想法就是将修改后的模型空间中的表面法线存储在一张纹理中，这种纹理被称为是**模型空间的法线纹理**（Object-space Normal Map）。模型空间下的法线纹理看起来是“五颜六色”的。这是因为所有法线所在的坐标空间是同一个坐标空间（模型空间），而每个点存储的法线方向是各异的，经过映射后存储到纹理中的颜色便不同。

然而，在实际制作中往往会采用模型顶点的**切线空间**（Tangent Space）存储法线。对于模型的每个顶点，它都有一个属于自己的切线空间，这个切线空间的原点就是该顶点本身，而Z轴是顶点的法线方向（*n*），X轴是顶点的切线方向（*t*），Y轴可由法线和切线叉积得到，也被称为是副切线（Bitangent，*b*）或副法线。这种纹理被称为是**切线空间的法线纹理**（Tangent-space Normal Map）。切线空间下的法线纹理看起来几乎全部是浅蓝色的。这是因为每个法线方向所在的坐标空间是不一样的（顶点各自的切线空间）。这种法线纹理其实就是存储了每个点在各自的切线空间中的法线扰动方向。也就是说，如果一个点的法线方向不变，那么在它的切线空间中，新的法线方向就是Z轴方向，即值为(0,0,1)，经过映射后存储在纹理中就对应了RGB(0.5,0.5,1)的浅蓝色。这些蓝色实际上说明顶点的大部分法线是和模型本身法线一样的，不需要改变。

总体来说，模型空间下的法线纹理更符合入类的直观认识，而且法线纹理本身也很直观，容
易调整，因为不同的法线方向就代表了不同的颜色。但美术人员往往更喜欢使用切线空间下的法线纹理。

实际上，法线本身存储在哪个坐标系中都是可以的（甚至可以选择存储在世界空间下）。但问题是，法线主要用于后续的光照计算。而选择哪个坐标系意味着需要把不同信息转换到相应的坐标系中。例如，如果选择了切线空间，则需要把从法线纹理中得到的法线方向从切线空间转换到世界空间（或其他空间）中。

总体来说，使用模型空间来存储法线的优点如下：

- 实现简单，更加直观。模型空间来存储法线甚至不需要模型原始的法线和切线等信息，也就是说，计算更少，生成它也非常简单。而如果要生成切线空间下的法线纹理，由于模型的切线一般是和UV方向相同，因此想要得到效果比较好的法线映射就要求纹理映射也是连续的。
- 在纹理坐标的缝合处和尖锐的边角部分，可见的突变（缝隙）较少，即可以提供平滑的边界。这是因为模型空间下的法线纹理存储的是同一坐标系下的法线信息，因此在边界处通过插值得到的法线可以平滑变换。而切线空间下的法线纹理中的法线信息是依靠纹理坐标的方向得到的结果，可能会在边缘处或尖锐的部分造成更多可见的缝合迹象。

但使用切线空间有更多优点：

- 自由度高。模型空间下的法线纹理记录的是绝对法线信息，仅可用于创建它时的那个模型，而应用到其他模型上效果就完全错误了。而切线空间下的法线纹理记录的是相对法线信息，这意味着，即便把该纹理应用到一个完全不同的网格上，也可以得到一个合理的结果。
- 可进行UV动画。比如可以移动一个纹理的UV坐标来实现一个凹凸移动的效果，但使用模型空间下的法线纹理会得到完全错误的结果。原因同上。这种UV动画在水或者火山熔岩这种类型的物体上会经常用到。
- 可以重用法线纹理。比如一个砖块，仅使用一张法线纹理就可以用到所有的6个面上。原因同上。
- 可压缩。由于切线空间下的法线纹理中法线的Z方向总是正方向，因此可以仅存储XY方向，而推导得到Z方向。而模型空间下的法线纹理由于每个方向都是可能的，因此必须存储3个方向的值，不可压缩。

# 实践

在计算光照模型时需要统一各个方向矢量所在的坐标空间。由于法线纹理中存储的法线是切线空间下的方向，因此通常有两种选择：在切线空间下进行光照计算（需要把光照方向、视觉方向变换到切线空间下）或在世界空间下进行光照计算（需要把采样得到的法线方向变换到世界空间下）。

从效率上来说，第一种方法往往要优于第二种方法，因为可以在顶点着色器中就完成对光照方向和视觉方向的变换，而第二种方法需要先对法线纹理进行采样，所以变换过程必须在片元着色器中实现，这意味需要在片元着色器中进行一次矩阵操作。但从通用性角度来说，第二种方法要优于第一种方法，因为有时需要在世界空间下进行一些计算，例如在使用Cubemap进行环境映射时，需要使用世界空间下的反射方向对Cubemap进行采样。如果同时需要进行法线映射，就需要把法线方向变换到世界空间下。当然，也可以选择其他坐标空间进行计算，例如模型空间等，但切线空间和世界空间是最为常用的两种空间。

## 切线空间下

基本思路是：在片元着色器中通过纹理采样得到切线空间下的法线，然后再与切线空间下的视觉方向、光照方向等进行计算，得到最终的光照结果。为此，需要在顶点着色器中把视觉方向和光照方向从模型空间变换到切线空间中，即需要知道从模型空间到切线空间的变换矩阵。这个变换矩阵的逆矩阵，即从切线空间到模型空间的变换矩阵是非常容易求得的，我们在顶点看色器中按切线X轴、副切线Y轴、法线Z轴的顺序**按列**排列即可得到（3D数学之05坐标空间）。如果一个变换中仅存在平移和旋转变换，那么这个变换的逆矩阵就等于它的转置矩阵，而从切线空间到模型空间的变换正是符合这样要求的变换。因此，从模型空间到切线空间的变换矩阵就是从切线空间到模型空间的变换矩阵的转置矩阵，即把切线X轴、副切线Y轴、法线Z轴的顺序**按行**排列即可得到。

（1）声明需要使用的属性：主色调（控制物体整体颜色）、基础纹理、法线纹理、凹凸程度（控制法线纹理的影响程度）、高光反射颜色以及光泽度。

``` CG
Properties
{
    _Color ("Color Tint", Color) = (1, 1, 1 )
    _MainTex ("Main Texture", 2D) = "white" { }
    _BumpMap ("Normal Map", 2D) = "bump" { }
    _BumpScale ("Bump Scale", Range(-1.0, 1.0)) = 1.0
    _Specular ("Specular", Color) = (1, 1, 1 )
    _Gloss ("Gloss", Range(8.0, 256)) = 20
}
```

（2）设置Pass光照模式。

``` CG
Tags { "LightMode" = "ForwardBase" }
```

（3）在CG代码块中指明顶点着色器和片元着色器，引用内置文件。

``` CG
#pragma vertex vert
#pragma fragment frag

#include "Lighting.cginc"
```

（4）声明与属性相匹配的变量。同样地，为两个纹理额外声明两个以"_ST"后缀的变量。

``` CG
fixed4 _Color;
sampler2D _MainTex;
float4 _MainTex_ST;
sampler2D _BumpMap;
float4 _BumpMap_ST;
float _BumpScale;
fixed4 _Specular;
float _Gloss;
```

（5）定义顶点着色器输入：需要在顶点着色器中计算切线空间下的光照方向和视觉方向，因此需要通过法线、切线（**切线选择四维矢量，使用w分量决定副切线的方向**）求取副切线以获取转换到切线空间的变换矩阵；当然，需要传入纹理坐标。

``` CG
struct a2v
{
    float4 vertex : POSITION;
    float3 normal : NORMAL;
    float4 tangent : TANGENT;
    float4 texcoord : TEXCOORD0;
};
```

（6）定义顶点着色器输出：存储两个纹理的UV坐标（使用四维矢量，xy为主纹理的UV坐标，zw为法线纹理的UV坐标，为了减少插值寄存器的使用数目）和转换后的切线空间下的光照和视觉方向。

``` CG
struct v2f
{
    float4 vertex : SV_POSITION;
    float4 uv : TEXCOORD0;
    float3 lightDir : TEXCOORD1;
    float3 viewDir : TEXCOORD2;
};
```

（7）顶点着色器：分别将主纹理和法线纹理坐标转换为UV坐标；**使用顶点法线和顶点切线的叉积求取副切线，并使用切线的w分量确定副切线方向，以这三个方向矢量（模型空间下）按列构建切线空间到模型空间的变换矩阵，因此从模型空间到切线空间的变换矩阵为切线空间到模型空间的变换矩阵的转置，即将切线、副切线、法线（模型空间下）按行构建即可（CG中矩阵按行优先填充）。** 也可以使用Unity内置宏TANGENT_SPACE_ROTATION得到改变换矩阵。之后，利用构建的变换矩阵即可将光照和视觉方向从模型空间转换到切线空间。

``` CG
v2f vert(a2v v)
{
    v2f o;
    o.vertex = UnityObjectToClipPos(i.vertex);

    o.uv.xy = i.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    o.uv.zw = i.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw;

    float3 binormal = cross(normalize(i.normal), normalize(i.tangent)) * i.tangent.w;
    float3x3 rotation = float3x3(i.tangent.xyz, binormal, i.normal);

    o.lightDir = mul(rotation, ObjSpaceLightDir(i.vertex)).xyz;
    o.viewDir = mul(rotation, ObjSpaceViewDir(i.vertex)).xyz;

    return o;
}
```

（8）片元着色器：对法线纹理进行采样得到切线空间下的法线方向，并在切线空间下计算光照即可。需要注意的是，法线纹理中存储的是法线经过映射后得到 像素值，因此需要反映射。

如果没有在Unity中将该法线纹理设置为Normal Map类型，需要在代码中手动进行反映射：首先把采样结果的xy分量按公式映射回法线方向，然后乘以`_BumpScale`（控制凹凸程度）来得到切线空间下法线的xy分量。由于法线都是单位矢量，并且切线空间下法线纹理可以保证法线方向的z分量始终为正，因此其z分量可以由x、y计算而得。

如果没有在Unity中将该法线纹理设置为Normal Map类型，那么使用上述方法进行反映射会得到错误的结果。这是因为，Unity会根据平台来选择不同的压缩方法来优化法线纹理的存储，此时`_BumpMap`的rgb分量不再是切线空间下法线方向的xyz值了。在这种情况下，可以使用Unity内置函数`UnpackNormal`来得到正确的法线方向。

```CG
fixed4 frag(v2f i) : SV_Target
{
    fixed3 tangentLightDir = normalize(i.lightDir);
    fixed3 tangentViewDir = normalize(i.viewDir);

    // 采样法线纹理
    fixed4 packedNormal = tex2D(_BumpMap, i.uv.zw);
    fixed3 tangentNormal;

    // 如果纹理不是法线纹理类型需要手动映射
    // tangentNormal.xy = (packedNormal.xy * 2 - 1) * _BumpScale;
    // tangentNormal.z = sqrt(1.0 - saturate(dot(tangentNormal.xy, tangentNormal.xy)));

    // 如果是法线纹理需要Unity映射
    tangentNormal = UnpackNormal(packedNormal);
    tangentNormal.xy *= _BumpScale;
    tangentNormal.z = sqrt(1.0 - saturate(dot(tangentNormal.xy, tangentNormal.xy)));

    fixed3 albedo = tex2D(_MainTex, i.uv.xy).rgb * _Color.rgb;

    fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;
    fixed3 diffuse = _LightColor0.rgb * albedo * saturate(dot(tangentNormal, tangentLightDir));

    fixed3 halfDir = normalize(tangentLightDir + tangentViewDir);
    fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(saturate(dot(tangentNormal, halfDir)), _Gloss);

    fixed3 color = ambient + diffuse + specular;
    return fixed4(color.r, color.g, color.b, 1.0);
}
```

（9）设置FallBack

```CG
FallBack "Specular"
```

## 世界空间下

在世界空间下计算光照模型时，需要在片元着色器中把法线方向从切线空间变换到世界空间下。这种方法的基本思想是：在顶点着色器中计算从切线空间到世界空间的变换矩阵并把它传递给片元着色器。变换矩阵的计算可以由顶点的切线、副切线和法线在世界空间下的表示**按列**构建。最后，只需要在片元着色器中把法线纹理中的法线方向从切线空间变换到世界空间下即可。尽管这种方法需要更多的计算，但在需要使用Cubemap进行环境映射等情况下，就需要使用这种方法。

（1）定义顶点着色器输出：在世界空间下计算时，顶点着色器只需要输出切线空间到世界空间的变换矩阵即可。由于一个插值寄存器最多只能存储`float4`类型的变量，因此对于矩阵类型的数据，需要拆分存储。此处，将该变换矩阵按行拆分存储在三个`float4`类型的变量中，其中w分量用于存储顶点的世界坐标（为了充分利用插值寄存器的存储空间）。

``` CG
struct v2f
{
    float4 vertex : SV_POSITION;
    float4 uv : TEXCOORD0;
    float4 TtWX : TEXCOORD1;
    float4 TtWY : TEXCOORD2;
    float4 TtWZ : TEXCOORD3;
};
```

（2）顶点着色器：分别将主纹理和法线纹理坐标转换为UV坐标；得到顶点在世界空间下的坐标、法线、切线、副切线，并按列构建从切线空间变换到世界空间的变换矩阵，同时存储顶点的世界坐标。

``` CG
v2f vert(a2v v)
{
    v2f o;
    o.vertex = UnityObjectToClipPos(i.vertex);

    o.uv.xy = i.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    o.uv.zw = i.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw;

    float3 worldPos = mul(unity_ObjectToWorld, i.vertex).xyz;
    fixed3 worldNormal = UnityObjectToWorldNormal(i.normal);
    fixed3 worldTangent = UnityObjectToWorldDir(i.tangent.xyz);
    fixed3 worldBinormal = cross(worldNormal, worldTangent) * i.tangent.w;

    o.TtWX = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
    o.TtWY = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
    o.TtWZ = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);

    return o;
}
```

（3）片元着色器：获得世界空间下的光照和视觉方向，对法线纹理采样并获得世界空间下的法线（通过用变换矩阵的每一行与法线相乘得到）。计算光照部分如前述。

```CG
fixed4 frag(v2f i) : SV_Target
{
    float3 worldPos = float3(i.TtWX.w, i.TtWY.w, i.TtWZ.w);

    fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(worldPos));
    fixed3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));

    fixed3 bump = UnpackNormal(tex2D(_BumpMap, i.uv.zw));
    bump.xy *= _BumpScale;
    bump.z = sqrt(1.0 - saturate(dot(bump.xy, bump.xy)));
    bump = normalize(half3(dot(i.TtWX.xyz, bump), dot(i.TtWY.xyz, bump), dot(i.TtWZ.xyz, bump)));
    ...
}
```

从视觉表现上，在切线空间下和在世界空间下计算光照几乎没有任何差别。

# Unity中的法线纹理类型

上述提到，将法线纹理设置为Normal Map会影响对法线的处理，这是因为Unity针对不同平台对纹理进行了压缩，此时需要通过内置函数`UnpackNormal`才能对法线纹理进行正确采样。以下是UnityCG.cginc中`UnpackNormal`函数的内部实现。

``` CG
inline fixed3 UnpackNormalDXT5nm (fixed4 packednormal)
{
    fixed3 normal;
    normal.xy = packednormal.wy * 2 - 1;
    normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));
    return normal;
}

// Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)
// Note neutral texture like "bump" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5
fixed3 UnpackNormalmapRGorAG(fixed4 packednormal)
{
    // This do the trick
   packednormal.x *= packednormal.w;

    fixed3 normal;
    normal.xy = packednormal.xy * 2 - 1;
    normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));
    return normal;
}

inline fixed3 UnpackNormal(fixed4 packednormal)
{
#if defined(UNITY_NO_DXT5nm)
    return packednormal.xyz * 2 - 1;
#elif defined(UNITY_ASTC_NORMALMAP_ENCODING)
    return UnpackNormalDXT5nm(packednormal);
#else
    return UnpackNormalmapRGorAG(packednormal);
#endif
}

fixed3 UnpackNormalWithScale(fixed4 packednormal, float scale)
{
#if defined(UNITY_ASTC_NORMALMAP_ENCODING)
    // (y, y, y, x), preferred for ASTC
    packednormal.x = packednormal.w;
#elif !defined(UNITY_NO_DXT5nm)
    // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)
    // Note neutral texture like "bump" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5
    packednormal.x *= packednormal.w;
#endif // UNITY_NO_DXT5nm
    fixed3 normal;
    normal.xy = (packednormal.xy * 2 - 1) * scale;
    normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));
    return normal;
}
```

从上述代码中可以看到，Unity针对某些平台会进行DXT5nm格式的压缩，因此需要针对这种格式解码。DXT5nm格式的法线纹理中，纹素的alpha通道（即w分量）对应了法线的x分量，green通道对应了法线的y分量，而纹理的red和blue通道则会被舍弃，法线的z分量可以由xy分量推导而得。为什么之前的普通纹理不能按这种方式压缩，而法线就需要使用DXT5nm格式来进行压缩呢？这是因为，按之前的处理方式，法线纹理被当成一个和普通纹理无异的图，但实际上，它只有两个通道是真正必不可少的，因为第三个通道的值可以用另外两个推导出来（法线是单位向量，并且切线空间下的法线方向的z分量始终为正）。使用这种压缩方法就可以减少法线纹理占用的内存空间。

当把纹理类型设置成Normal Map后，还有一个复选框是Create from Grayscale，它是用于从高度图中生成法线纹理的。高度图本身记录的是相对高度，是一张灰度图，白色表示相对更高，黑色表示相对更低。当把一张高度图导入Unity后，除了需要把它的纹理类型设成Nonnal Map外，还需要勾选Create from Grayscale，这样就可以得到切线空间下的法线纹理了。

当勾选了Create from Grayscale后，还多出了两个选项——Bumpiness和Filtering。其中
Bumpiness用于控制凹凸程度，而Filtering决定使用哪种方式来计算凹凸程度，它有两种选项：Smooth使得生成后的法线纹理会比较平滑，Sharp使用Sobel滤波（一种边缘检测时使用的滤波器）来生成法线。Sobel滤波的实现非常简单，只要在一个3x3的滤波器中计算x和y方向上的导数，然后从中得到法线即可。具体方法是：对于高度图中的每个像素，考虑它与水平方向和竖直方向上的像素差，把它们的差当成该点对应的法线在x和y方向上的位移，然后使用之前提到的映射函数存储成到法线纹理的r和g分量即可。