# 概述

在Unity中，着色器分为三大类：

- 渲染管线中的着色器：用来计算图像。
- 通用计算着色器：独立于渲染管线，仅在GPU上执行通用计算。
- 光线追踪着色器：用于执行与光线追踪相关的计算。

渲染管线中的着色器可分为：

- 顶点/片元着色器。
- **表面着色器**（Surface Shaders）：Unity推荐和鼓励使用的着色器，是对顶点/片元着色器的封装，最终会被编译成能被硬件识别的顶点着色器和片元着色器。
- **固定函数着色器**（Fixed Function Shaders）：固定管线中的固定功能的着色器，是针对硬件能够执行的命令编写的着色器，功能有限但速度快、支持性好，只能使用ShaderLab编写。

着色器和材质、贴图的关系：

- 着色器实际上是一段程序，定义了渲染所需的各种代码、属性和指令，负责将输入的顶点数据以指定的方式和输入的贴图或者颜色等组合起来，然后输出。绘图单元可以依据输出绘制图像。
- 将输入的贴图或颜色等数据，加上着色器以及对着色器的特定的参数设置打包存储在一起即为**材质**（Material）。材质允许开发者在Inspector面板修改着色器属性，并将材质应用到指定对象。
- **贴图**（Texture）是要处理的初始数据之一。

Unity中用于渲染管线的着色器通常是`Shader`类的实例，是对着色器程序、渲染状态（如更改GPU的指令等）和其他信息的封装，允许开发者在同一个文件中定义多个着色器程序并告诉Unity如何使用它们。

在Unity中可以通过以下两种方式创建着色器对象。无论使用何种方式创建，Unity内部的处理方式都是一样的。

- Project窗口右键创建：
- - Standard Surface Shader标准表面着色器：包含标准光照模型的表面着色器模板。
- - Unlit Shader无光照着色器：不包含光照但包含雾效的基本的顶点/片元着色器。
- - Image Effect Shader图片效果着色器：实现屏幕后处理效果。
- - Compute Shader计算着色器：旨在利用GPU的并行性进行通用性计算。
- 通过Shader Graph创建。

# 着色器资产

Unity中的着色器资产是一个扩展名为.shader的文本文件。当选择一个着色器资产时，Inspector面板会显示该资产的基本信息，并提供用于编译和检查已编译代码的功能。

导入设置Imported Settings中有：

- Default Maps默认纹理：用于设置着色器默认纹理。

导入对象Imported Object用于查看和编辑与该资产本身相关的设置以及着色器编译器对它的处理方式。

- 是否为表面着色器和固定函数着色器。如果是，可以查看Unity生成的代码。
- 选择编译选项和查看已编译的着色器代码，可以分析和优化着色器。
- 渲染队列。
- 是否关闭批处理。
- 关键词。
- 属性列表。

# 着色器编译

每次构建项目时，Unity会编译构建所需的所有着色器，即针对每个所需的图形API编译每个所需的着色器。在构建时，Unity可以检测到一些未被游戏使用着色器变量，并从构建数据中剥离它们。

在Unity编辑器中时，Unity不会提前编译所有内容，这是因为针对每个所需的图形API编译每个所需的着色器可能需要很长时间。Unity编辑器通常会：

- 在导入着色器时执行最小的处理，如生成表面着色器等。
- 当需要显示着色器时检查Library/ShaderCache中是否存在事先编译好的着色器。如果有，则使用之；如果没有，则编译所需的着色器并将结果保存到缓存中。

着色器编译使用名为UnityShaderCompiler的进程。可启动多个UnityShaderCompiler编译器进程（通常每个CPU核心对应一个），这样在Unity编辑器下运行时就可以并行完成着色器编译。当Unity编辑器不编译着色器时，编译器进程不执行任何操作，也不消耗计算机资源。

如果有许多经常更改的着色器，那么着色器缓存文件夹可能会变得非常大。删除着色器缓存文件夹是安全的；只会导致Unity重新编译着色器。

在Unity编辑器下运行时，所有“尚未编译”的着色器都将被编译，因此即使编辑器不会使用这些着色器，它们也会存在于游戏数据中。

不同平台使用不同的编译器编译着色器：

- DirectX使用Microsoft的FXC HLSL编译器。
- OpenGL（Core或ES版本）先使用Microsoft的FXC HLSL编译器，然后使用HLSLcc将字节代码转换为GLSL。
- Metal先使用Microsoft的FXC HLSL编译器，然后使用HLSLcc将字节代码转换为Metal。
- Vulkan先使用Microsoft的FXC HLSL编译器，然后使用HLSLcc将字节代码转换为SPIR-V。
- 其他平台（如游戏主机平台）使用其各自的编译器。
- 表面着色器使用HLSL和MojoShader来完成代码生成分析步骤。

着色器编译分为几个步骤：

- 预处理：使用预处理器为编译器准备着色器源代码。在以前，Unity使用平台编译器提供的预处理器。现在Unity使用自己的预处理器，也叫缓存着色器预处理（Caching Shader Preprocessor）。

# 着色器加载

Unity通过以下方式从构建的应用程序中加载编译过的着色器：

1. 当Unity加载场景或资源时，**加载该场景或资源需要的所有已编译的着色器到CPU内存**。默认情况下，Unity将所有着色器解压到CPU内存的其他区域，可以控制在不同平台上着色器使用的内存大小；
2. Unity第一次使用着色器渲染时，会将着色器及其数据传递给图形API和图形驱动程序；
3. 图形驱动程序创建GPU可用的着色器并上传到显存中。

这种方法确保Unity和图形驱动程序在使用着色器之前避免加载、处理和存储着色器，但当图形驱动程序第一次创建GPU可用的着色器时可能会出现明显的停滞。

Unity会**缓存每个GPU可用的着色器**，以避免重复创建。

当不再有任何对象引用着色器时，Unity将着色器完全从CPU和GPU内存中移除。

如果着色器中包含多个子着色器，当Unity首次使用着色器对象渲染以及更改活动渲染管线、着色器的LOD值时，Unity会尝试选择并使用**与平台硬件兼容、等于或低于当前着色器LOD值、与渲染管线兼容的子着色器**。如果可以运行的子着色器有多个，则选择第一个；如果Unity找不到需要的着色器，则会尝试选择一个类似的着色器；如果找不到类似的着色器，则会使用洋红色显示渲染的对象。可以启用严格的着色器匹配选项来阻止Unity尝试选择类似的着色器。

Unity可以识别使用相同着色器变体的几何体并将其合批以实现更高效的渲染。对于合批的几何体：

1. Unity确定其应该渲染运行的子着色器中的哪些通道；
2. 对于其渲染的每个通道，如果当前渲染状态和通道中定义的渲染状态不匹配，Unity会根据通道中的定义设置渲染状态，然后GPU使用相应的着色器变体渲染几何体。

# 着色器结构

着色器对象包含：

- 关于自身的信息，如着色器名称。
- 后备着色器对象，是当前着色器无法渲染时的备选对象。
- 至少一个子着色器。
- 附加信息，如共享着色器代码、自定义编辑器显示等。

**子着色器**（SubShader）用于将着色器对象分成多个部分，分别兼容不同的硬件、渲染管线或运行时的设置。一个子着色器通常包含：

- 有关此子着色器与哪些硬件、渲染管线或运行时设置兼容的信息。
- 标签。
- LOD（Level of Detail，细节层次）值
- 至少一个通道。

**通道**（Pass）是着色器对象的基本元素，可以使用单独的通道定义着色器对象的不同部分。通道通常包含设置GPU状态的指令、在GPU上运行的代码等。

- 标签。
- 运行着色器代码之前更新渲染状态的说明。
- 至少包含一个着色器变体（着色器程序）。

**着色器变体**（Shader Variants）是指通道中包含的着色器程序。着色器变体共享通用代码，通过启用或禁用给定关键字，使其具有不同功能，数量取决于着色器程序中定义的关键字和目标平台。