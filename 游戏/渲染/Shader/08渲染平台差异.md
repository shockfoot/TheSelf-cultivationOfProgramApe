Unity的优点之一是其强大的跨平台性——写一份代码可以运行在很多平台上。 绝大多数情况下，Unity隐藏了实现细节，但有时开发者需要自己处理它们。

# 纹理坐标差异

**OpenGL和DirectX的屏幕空间坐标是有差异的。** 在水平方向上，两者的数值变化方向是相同的，但在竖直方向上，两者是相反的。在OpenGL（OpenGL ES也是）中，(0,0)点对应了屏幕的左下角，而在DirectX （MetaI也是）中，(0,0)点对应了左上角。

需要注意的是，开发者不仅可以把渲染结果输出到屏幕上，还可以输出到不同的渲染目标中。此时，需要使用渲染纹理（Render Texture）来保存这些渲染结果。

大多数情况下，屏幕坐标空间的差异不会造成任何影响。但当要使用渲染到纹理技术，把屏幕图像渲染到一张渲染纹理中时，如果不采取任何措施的话，会出现纹理翻转的情况。幸运的是，Unity在背后处理了这种翻转问题——当在DirectX平台上使用渲染到纹理技术时，Unity会翻转屏幕图像纹理，以便在不同平台上达到一致性。

在一种特殊情况下Unity不会进行这个翻转操作，即开启抗锯齿（在
Edit->Project Settings->Quality->Anti Aliasing中开启）并在此时使用了渲染到纹理技术。此时，Unity首先渲染得到屏幕图像，再由硬件进行抗锯齿处理后，得到一张渲染纹理以进行后续处理。此时，在DirectX平台下得到的输入屏幕图像并不会被Unity翻转，也就是说， 此时对屏幕图像的采样坐标是需要符合DirectX平台规定的。如果屏幕特效只需要处理一张渲染图像，仍然不需要在意纹理的翻转问题，这是因为在调用`Graphics.Blit`函数时，Unity已经对屏幕图像的采样坐标进行了处理，只需要按正常的采样过程处理屏幕图像即可。但如果需要同时处理多张渲染图像（前提是开启了抗锯齿），例如需要同时处理屏幕图像和法线纹理，这些图像在竖直方向的朝向就可能是不同的（只有在DirectX这样的平台上才有这样的问题）。这种时候，就需要自己在顶点着色器中翻转某些渲染纹理（例如深度纹理或其他由脚本传递过来的纹理）的纵坐标使之都符合DirectX平台的规则。

# Shader语法差异

DirectX 9/11对Shader的语法更加严格，如必须提供和变量类型相匹配的参数数目，必须对所有`out`修饰的参数进行初始化。

DirectX 9/11不支持在顶点着色器中使用`tex2D`函数。`tex2D`是一个对纹理进行采样的函数。之所以DirectX 9/11不支持顶点阶段中的`tex2D`运算是因为在顶点着色器阶段Shader无法得到UV偏导，而`tex2D`函数需要这样的偏导信息（这和纹理采样时使用的数学运算有关）。如果的确需要在顶点着色器中访问纹理，需要使用`tex2Dlod`函数来替代，而且还需要添加`#pragma target 3.0`, 因为`tex2Dlod`是Shader Model 3.0中的特性。

# Shader语义差异

一些语义在某些平台下是等价的，例如`SV_POSITION`与`POSITION`。但在另一些平台上，这些语义是不等价的。为了让Shader能够在所有平台上正常工作，应该尽可能使用下面的语义来描述Shader的输入输出变量：

- 使用`SV_POSITION`来描述顶点着色器输出的顶点位置。一些Shader使用了`POSITION`，但这些Shader无法在索尼PS4平台上或使用了细分着色器的情况下正常工作。
- 使用`SV_Targ`来描述片元着色器的输出颜色。一些Shader使用了`COLOR`或`COLORO`，同样的，这些Shader无法在索尼PS4上正常工作。